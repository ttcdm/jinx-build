diff --git a/.github/workflows/check.yml b/.github/workflows/check.yml
index 30bf575..8c9fc1f 100644
--- a/.github/workflows/check.yml
+++ b/.github/workflows/check.yml
@@ -1,4 +1,4 @@
-name: Build Vinix kernel
+name: Build willowos kernel
 
 on:
   pull_request:
@@ -11,7 +11,7 @@ on:
       - "**.md"
 
 jobs:
-  vinix-build:
+  willowos-build:
     runs-on: ubuntu-latest
     steps:
       - uses: actions/checkout@v6
@@ -25,40 +25,40 @@ jobs:
       - name: Download kernel dependencies
         run: cd kernel && ./get-deps
 
-      - name: Attempt to build the Vinix kernel (debug)
+      - name: Attempt to build the willowos kernel (debug)
         run: |
           set -e
           cd kernel
           make PROD=false \
-            CFLAGS="-Ulinux -U__linux -U__linux__ -U__gnu_linux__ -D__vinix__ -O2 -g -pipe" \
+            CFLAGS="-Ulinux -U__linux -U__linux__ -U__gnu_linux__ -D__willowos__ -O2 -g -pipe" \
             V="$(realpath ../v/v)"
           make clean
 
-      - name: Attempt to build the Vinix kernel (prod)
+      - name: Attempt to build the willowos kernel (prod)
         run: |
           set -e
           cd kernel
           make PROD=true \
-            CFLAGS="-Ulinux -U__linux -U__linux__ -U__gnu_linux__ -D__vinix__ -O2 -g -pipe" \
+            CFLAGS="-Ulinux -U__linux -U__linux__ -U__gnu_linux__ -D__willowos__ -O2 -g -pipe" \
             V="$(realpath ../v/v)"
           make clean
 
-      - name: Attempt to build the util-vinix (debug)
+      - name: Attempt to build the util-willowos (debug)
         run: |
           set -e
-          cd util-vinix
+          cd util-willowos
           make PROD=false \
-            VFLAGS="-os vinix -gc none" \
-            CFLAGS="-Ulinux -U__linux -U__linux__ -U__gnu_linux__ -D__vinix__ -O2 -g -pipe" \
+            VFLAGS="-os willowos -gc none" \
+            CFLAGS="-Ulinux -U__linux -U__linux__ -U__gnu_linux__ -D__willowos__ -O2 -g -pipe" \
             V="$(realpath ../v/v)"
           make clean
 
-      - name: Attempt to build the util-vinix (prod)
+      - name: Attempt to build the util-willowos (prod)
         run: |
           set -e
-          cd util-vinix
+          cd util-willowos
           make PROD=true \
-            VFLAGS="-os vinix -gc none" \
-            CFLAGS="-Ulinux -U__linux -U__linux__ -U__gnu_linux__ -D__vinix__ -O2 -g -pipe" \
+            VFLAGS="-os willowos -gc none" \
+            CFLAGS="-Ulinux -U__linux -U__linux__ -U__gnu_linux__ -D__willowos__ -O2 -g -pipe" \
             V="$(realpath ../v/v)"
           make clean
diff --git a/.github/workflows/nightly.yml b/.github/workflows/nightly.yml
index df2d97f..f5be2f0 100644
--- a/.github/workflows/nightly.yml
+++ b/.github/workflows/nightly.yml
@@ -1,11 +1,11 @@
-name: Nightly Vinix rebuild
+name: Nightly willowos rebuild
 
 on:
   schedule:
     - cron: '0 0 * * *'
 
 jobs:
-  vinix-build:
+  willowos-build:
     runs-on: ubuntu-latest
     steps:
       - name: Checkout code
@@ -26,14 +26,14 @@ jobs:
       #- name: Build full distro and ISO
       #  run: JINX_CLEAN_WORKDIRS=yes PKGS_TO_INSTALL='*' make all
 
-      #- name: Rename vinix.iso
-      #  run: mv vinix.iso vinix-nightly-full-$(date +'%Y%m%d').iso
+      #- name: Rename willowos.iso
+      #  run: mv willowos.iso willowos-nightly-full-$(date +'%Y%m%d').iso
 
       - name: Build base distro and ISO
         run: JINX_CLEAN_WORKDIRS=yes make all
 
-      - name: Rename vinix.iso
-        run: mv vinix.iso vinix-nightly-base-$(date +'%Y%m%d').iso
+      - name: Rename willowos.iso
+        run: mv willowos.iso willowos-nightly-base-$(date +'%Y%m%d').iso
 
       - name: Set TAG_DATE variable
         run: echo "TAG_DATE=$(date +'%Y-%m-%d')" >> $GITHUB_ENV
@@ -46,8 +46,8 @@ jobs:
         with:
           name: Nightly build ${{ env.TAG_DATE }}
           tag_name: nightly-${{ env.TAG_DATE }}
-          body: Image of an up to date Vinix nightly build.
+          body: Image of an up to date willowos nightly build.
           files: |
-            vinix-nightly-*.iso
+            willowos-nightly-*.iso
         env:
           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
diff --git a/.gitignore b/.gitignore
index d29dc98..c29bc03 100644
--- a/.gitignore
+++ b/.gitignore
@@ -6,7 +6,7 @@
 /sources
 /sysroot
 /iso_root
-/vinix.iso
+/willowos.iso
 /initramfs.tar
 /.vscode
 /.jinx-cache
diff --git a/GNUmakefile b/GNUmakefile
index 3b4c0ed..65ff8f1 100644
--- a/GNUmakefile
+++ b/GNUmakefile
@@ -1,11 +1,11 @@
-QEMUFLAGS ?= -M q35,smm=off -m 8G -cdrom vinix.iso -serial stdio -smp 4
+QEMUFLAGS ?= -M q35,smm=off -m 8G -cdrom willowos.iso -serial stdio -smp 4
 
 .PHONY: all
 all:
-	rm -f vinix.iso
-	$(MAKE) vinix.iso
+	rm -f willowos.iso
+	$(MAKE) willowos.iso
 
-vinix.iso: jinx
+willowos.iso: jinx
 	./build-support/makeiso.sh
 
 .PHONY: debug
@@ -19,11 +19,11 @@ jinx:
 	rm -rf jinx-repo
 
 .PHONY: run-kvm
-run-kvm: vinix.iso
+run-kvm: willowos.iso
 	qemu-system-x86_64 -enable-kvm -cpu host $(QEMUFLAGS)
 
 .PHONY: run-hvf
-run-hvf: vinix.iso
+run-hvf: willowos.iso
 	qemu-system-x86_64 -accel hvf -cpu host $(QEMUFLAGS)
 
 ovmf/ovmf-code-x86_64.fd:
@@ -35,7 +35,7 @@ ovmf/ovmf-vars-x86_64.fd:
 	curl -Lo $@ https://github.com/osdev0/edk2-ovmf-nightly/releases/latest/download/ovmf-vars-x86_64.fd
 
 .PHONY: run-uefi
-run-uefi: vinix.iso ovmf/ovmf-code-x86_64.fd ovmf/ovmf-vars-x86_64.fd
+run-uefi: willowos.iso ovmf/ovmf-code-x86_64.fd ovmf/ovmf-vars-x86_64.fd
 	qemu-system-x86_64 \
 		-enable-kvm \
 		-cpu host \
@@ -44,20 +44,20 @@ run-uefi: vinix.iso ovmf/ovmf-code-x86_64.fd ovmf/ovmf-vars-x86_64.fd
 		$(QEMUFLAGS)
 
 .PHONY: run-bochs
-run-bochs: vinix.iso
+run-bochs: willowos.iso
 	bochs -f bochsrc
 
 .PHONY: run-lingemu
-run-lingemu: vinix.iso
-	lingemu runvirt -m 8192 --diskcontroller type=ahci,name=ahcibus1 --disk vinix.iso,disktype=cdrom,controller=ahcibus1
+run-lingemu: willowos.iso
+	lingemu runvirt -m 8192 --diskcontroller type=ahci,name=ahcibus1 --disk willowos.iso,disktype=cdrom,controller=ahcibus1
 
 .PHONY: run
-run: vinix.iso
+run: willowos.iso
 	qemu-system-x86_64 $(QEMUFLAGS)
 
 .PHONY: clean
 clean:
-	rm -rf iso_root sysroot vinix.iso initramfs.tar
+	rm -rf iso_root sysroot willowos.iso initramfs.tar
 
 .PHONY: distclean
 distclean: clean
diff --git a/README.md b/README.md
index 79a216b..9682278 100644
--- a/README.md
+++ b/README.md
@@ -1,10 +1,10 @@
-# Vinix
+# willowos
 
-Vinix is an effort to write a modern, fast, and useful operating system in [the V programming language](https://vlang.io).
+willowos is an effort to write a modern, fast, and useful operating system in [the V programming language](https://vlang.io).
 
 Join the [Discord chat](https://discord.gg/S5Nm6ZDU38).
 
-## What is Vinix all about?
+## What is willowos all about?
 
 - Keeping the code as simple and easy to understand as possible, while not sacrificing
 performance and prioritising code correctness.
@@ -15,16 +15,16 @@ virtual machines.
 - Exploring V capabilities in bare metal programming and improving the compiler in response to the uncommon needs of bare metal programming.
 - Having fun.
 
-**Note: Vinix is still pre-alpha software not meant for daily or production usage!**
+**Note: willowos is still pre-alpha software not meant for daily or production usage!**
 
 ![Screenshot 0](/screenshot0.png?raw=true "Screenshot 0")
 ![Screenshot 1](/screenshot1.png?raw=true "Screenshot 1")
 
 ## Download latest nightly image
 
-You can grab a pre-built nightly Vinix image at https://github.com/vlang/vinix/releases
+You can grab a pre-built nightly willowos image at https://github.com/vlang/willowos/releases
 
-Make sure to boot the ISO with enough memory (8+GiB) as, for now, Vinix loads its
+Make sure to boot the ISO with enough memory (8+GiB) as, for now, willowos loads its
 entire root filesystem in a ramdisk in order to be able to more easily boot
 on real hardware.
 
@@ -48,7 +48,7 @@ on real hardware.
 
 ### Distro-agnostic build prerequisites
 
-The following is a distro-agnostic list of packages needed to build Vinix.
+The following is a distro-agnostic list of packages needed to build willowos.
 
 Skip to a paragraph for your host distro if there is any.
 
diff --git a/base-files/etc/hostname b/base-files/etc/hostname
index 1618518..384d3e4 100644
--- a/base-files/etc/hostname
+++ b/base-files/etc/hostname
@@ -1 +1 @@
-vinix
+willowos
diff --git a/bochsrc b/bochsrc
index 0fbfe12..6488071 100644
--- a/bochsrc
+++ b/bochsrc
@@ -1,4 +1,4 @@
-ata0-slave: type=cdrom, path=vinix.iso, status=inserted
+ata0-slave: type=cdrom, path=willowos.iso, status=inserted
 boot: cdrom
 com1: enabled=1
 memory: guest=1024, host=1024
diff --git a/build-support/CMakeToolchain-x86_64.txt b/build-support/CMakeToolchain-x86_64.txt
index 568baac..0894b28 100644
--- a/build-support/CMakeToolchain-x86_64.txt
+++ b/build-support/CMakeToolchain-x86_64.txt
@@ -1,10 +1,10 @@
-set(CMAKE_SYSTEM_NAME Vinix)
+set(CMAKE_SYSTEM_NAME willowos)
 set(CMAKE_SYSTEM_PROCESSOR x86_64)
 
 set(CMAKE_FIND_ROOT_PATH /sysroot)
 
-set(CMAKE_C_COMPILER x86_64-vinix-mlibc-gcc)
-set(CMAKE_CXX_COMPILER x86_64-vinix-mlibc-g++)
+set(CMAKE_C_COMPILER x86_64-willowos-mlibc-gcc)
+set(CMAKE_CXX_COMPILER x86_64-willowos-mlibc-g++)
 
 # search for programs in the build host directories
 SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
diff --git a/build-support/cmake-host/Platform/Vinix.cmake b/build-support/cmake-host/Platform/Vinix.cmake
deleted file mode 100644
index 54a156b..0000000
--- a/build-support/cmake-host/Platform/Vinix.cmake
+++ /dev/null
@@ -1 +0,0 @@
-include(Platform/UnixPaths)
diff --git a/build-support/config.guess b/build-support/config.guess
index 3f52ad4..f026469 100755
--- a/build-support/config.guess
+++ b/build-support/config.guess
@@ -977,11 +977,11 @@ EOF
     *:[Mm]anagarm:*:*)
 	GUESS="$UNAME_MACHINE-unknown-managarm-mlibc"
 	;;
-    x86_64:[Vv]inix:*:*|i?86:[Vv]inix:*:*)
-	GUESS="$UNAME_MACHINE-pc-vinix-mlibc"
+    x86_64:[Ww]illowos:*:*|i?86:[Ww]illowos:*:*)
+	GUESS="$UNAME_MACHINE-pc-willowos-mlibc"
 	;;
-    *:[Vv]inix:*:*)
-	GUESS="$UNAME_MACHINE-unknown-vinix-mlibc"
+    *:[Ww]illowos:*:*)
+	GUESS="$UNAME_MACHINE-unknown-willowos-mlibc"
 	;;
     *:Minix:*:*)
 	GUESS=$UNAME_MACHINE-unknown-minix
diff --git a/build-support/config.sub b/build-support/config.sub
index 957e992..ccca951 100755
--- a/build-support/config.sub
+++ b/build-support/config.sub
@@ -146,7 +146,7 @@ case $1 in
 			nto-qnx* | linux-* | uclinux-uclibc* \
 			| uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* \
 			| netbsd*-eabi* | kopensolaris*-gnu* | cloudabi*-eabi* \
-			| storm-chaos* | os2-emx* | rtmk-nova* | managarm-* | vinix-* \
+			| storm-chaos* | os2-emx* | rtmk-nova* | managarm-* | willowos-* \
 			| windows-* )
 				basic_machine=$field1
 				basic_os=$maybe_os
@@ -1326,9 +1326,9 @@ EOF
 		kernel=managarm
 		os=`echo "$basic_os" | sed -e 's|managarm|mlibc|'`
 		;;
-	vinix*)
-		kernel=vinix
-		os=`echo "$basic_os" | sed -e 's|vinix|mlibc|'`
+	willowos*)
+		kernel=willowos
+		os=`echo "$basic_os" | sed -e 's|willowos|mlibc|'`
 		;;
 	*)
 		kernel=
@@ -1830,7 +1830,7 @@ case $kernel-$os-$obj in
 		;;
 	managarm-mlibc*- | managarm-kernel*- )
 		;;
-	vinix-mlibc*- )
+	willowos-mlibc*- )
 		;;
 	windows*-msvc*-)
 		;;
diff --git a/build-support/cross_file-x86_64.txt b/build-support/cross_file-x86_64.txt
index 055ef93..745da65 100644
--- a/build-support/cross_file-x86_64.txt
+++ b/build-support/cross_file-x86_64.txt
@@ -1,14 +1,14 @@
 [binaries]
-c = 'x86_64-vinix-mlibc-gcc'
-cpp = 'x86_64-vinix-mlibc-g++'
-ar = 'x86_64-vinix-mlibc-ar'
-nm = 'x86_64-vinix-mlibc-nm'
-strip = 'x86_64-vinix-mlibc-strip'
-pkg-config = 'x86_64-vinix-mlibc-pkg-config'
+c = 'x86_64-willowos-mlibc-gcc'
+cpp = 'x86_64-willowos-mlibc-g++'
+ar = 'x86_64-willowos-mlibc-ar'
+nm = 'x86_64-willowos-mlibc-nm'
+strip = 'x86_64-willowos-mlibc-strip'
+pkg-config = 'x86_64-willowos-mlibc-pkg-config'
 llvm-config = '/base_dir/build-support/cross-llvm-config'
 
 [host_machine]
-system = 'vinix'
+system = 'willowos'
 cpu_family = 'x86_64'
 cpu = 'x86_64'
 endian = 'little'
diff --git a/build-support/limine.conf b/build-support/limine.conf
index 4ffa1cb..9a84c7f 100644
--- a/build-support/limine.conf
+++ b/build-support/limine.conf
@@ -1,6 +1,6 @@
 timeout: 3
 
-/Vinix
+/willowos
     protocol: limine
-    kernel_path: boot():/boot/vinix
+    kernel_path: boot():/boot/willowos
     module_path: boot():/boot/initramfs.tar
diff --git a/build-support/makeiso.sh b/build-support/makeiso.sh
index bc47969..e66383c 100755
--- a/build-support/makeiso.sh
+++ b/build-support/makeiso.sh
@@ -18,7 +18,7 @@ fi
 # Prepare the iso and boot directories.
 rm -rf iso_root
 mkdir -pv iso_root/boot
-cp sysroot/usr/share/vinix/vinix iso_root/boot/
+cp sysroot/usr/share/willowos/willowos iso_root/boot/
 cp initramfs.tar iso_root/boot/
 cp build-support/limine.conf iso_root/boot/
 
@@ -34,7 +34,7 @@ xorriso -as mkisofs -R -r -J -b boot/limine-bios-cd.bin \
     -no-emul-boot -boot-load-size 4 -boot-info-table -hfsplus \
     -apm-block-size 2048 --efi-boot boot/limine-uefi-cd.bin \
     -efi-boot-part --efi-boot-image --protective-msdos-label \
-    iso_root -o vinix.iso
+    iso_root -o willowos.iso
 
 # Install limine.
-host-pkgs/limine/usr/local/bin/limine bios-install vinix.iso
+host-pkgs/limine/usr/local/bin/limine bios-install willowos.iso
diff --git a/init/main.v b/init/main.v
index 9a5a938..ee41c87 100644
--- a/init/main.v
+++ b/init/main.v
@@ -7,7 +7,7 @@ import os
 fn C.sethostname(name charptr, len u64) int
 
 fn main() {
-	println('Vinix Init started')
+	println('willowos Init started')
 
 	os.setenv('HOME', '/root', true)
 	os.setenv('TERM', 'linux', true)
@@ -21,7 +21,7 @@ fn main() {
 	os.chdir('/root') or { panic('Could not move to root') }
 
 	// Read hostname from /etc/hostname and pass to the kernel.
-	hostname_file := os.read_file('/etc/hostname') or { 'vinix' }
+	hostname_file := os.read_file('/etc/hostname') or { 'willowos' }
 	mut length := u64(0)
 	for length < hostname_file.len && hostname_file[length] != `\n` {
 		length++
diff --git a/init/v.mod b/init/v.mod
index 48d090a..00612fa 100644
--- a/init/v.mod
+++ b/init/v.mod
@@ -1,6 +1,6 @@
 Module {
-	name: 'Vinix Init'
-	description: 'PID 1 for Vinix'
+	name: 'willowos Init'
+	description: 'PID 1 for willowos'
 	version: '0.0.0'
 	license: 'GPL-2.0'
 	dependencies: []
diff --git a/jinx-config b/jinx-config
index 7650c63..a26333b 100644
--- a/jinx-config
+++ b/jinx-config
@@ -16,7 +16,7 @@ fi
 
 JINX_ARCH=${ARCHITECTURE}
 
-OS_TRIPLET=$ARCHITECTURE-vinix-mlibc
+OS_TRIPLET=$ARCHITECTURE-willowos-mlibc
 
 case "$ARCHITECTURE" in
     x86_64)
diff --git a/kernel/.gitignore b/kernel/.gitignore
deleted file mode 100644
index cdf2687..0000000
--- a/kernel/.gitignore
+++ /dev/null
@@ -1,8 +0,0 @@
-/freestnd-c-hdrs
-/cc-runtime*
-/c/flanterm
-/c/nanoprintf*
-/c/uacpi
-/uacpi-repository
-/bin
-/obj
diff --git a/kernel/GNUmakefile b/kernel/GNUmakefile
deleted file mode 100644
index f3b6143..0000000
--- a/kernel/GNUmakefile
+++ /dev/null
@@ -1,181 +0,0 @@
-# Nuke built-in rules and variables.
-MAKEFLAGS += -rR
-.SUFFIXES:
-
-# This is the name that our final executable will have.
-# Change as needed.
-override OUTPUT := vinix
-
-# Install prefix; /usr/local is a good, standard default pick.
-PREFIX := /usr/local
-
-# User controllable C compiler command.
-CC := cc
-
-# User controllable archiver command.
-AR := ar
-
-# User controllable V command.
-V := v
-
-# User controllable C flags.
-CFLAGS := -g -O2 -pipe
-
-# User controllable C preprocessor flags. We set none by default.
-CPPFLAGS :=
-
-# User controllable V flags. We set none by default.
-VFLAGS :=
-
-# User controllable linker flags. We set none by default.
-LDFLAGS :=
-
-PROD :=
-
-# Ensure the dependencies have been obtained.
-ifneq ($(shell ( test '$(MAKECMDGOALS)' = clean || test '$(MAKECMDGOALS)' = distclean ); echo $$?),0)
-    ifeq ($(shell ( ! test -d freestnd-c-hdrs || ! test -d cc-runtime || ! test -d c/flanterm || ! test -f c/nanoprintf.h ); echo $$?),0)
-        $(error Please run the ./get-deps script first)
-    endif
-endif
-
-# Check if CC is Clang.
-override CC_IS_CLANG := $(shell ! $(CC) --version 2>/dev/null | grep 'clang' >/dev/null 2>&1; echo $$?)
-
-# If the C compiler is Clang, set the target as needed.
-ifeq ($(CC_IS_CLANG),1)
-    override CC += \
-        -target x86_64-unknown-none
-endif
-
-# Internal C flags that should not be changed by the user.
-override CFLAGS += \
-    -g \
-    -Wall \
-    -Wextra \
-    -std=gnu99 \
-    -nostdinc \
-    -ffreestanding \
-    -fno-omit-frame-pointer \
-    -fno-stack-protector \
-    -fno-stack-check \
-    -fno-lto \
-    -fno-PIC \
-    -ffunction-sections \
-    -fdata-sections \
-    -fno-strict-aliasing \
-    -m64 \
-    -march=x86-64 \
-    -mno-80387 \
-    -mno-mmx \
-    -mno-sse \
-    -mno-sse2 \
-    -mno-red-zone \
-    -mcmodel=kernel
-
-# Internal C preprocessor flags that should not be changed by the user.
-override CPPFLAGS := \
-    -I c \
-    -isystem freestnd-c-hdrs \
-    $(CPPFLAGS) \
-    -MMD \
-    -MP
-
-obj/flanterm/backends/fb.c.o: override CPPFLAGS += \
-    -DFLANTERM_FB_DISABLE_BUMP_ALLOC
-
-# Internal linker flags that should not be changed by the user.
-override LDFLAGS += \
-    -Wl,-m,elf_x86_64 \
-    -Wl,--build-id=none \
-    -nostdlib \
-    -static \
-    -z max-page-size=0x1000 \
-    -Wl,--gc-sections \
-    -T linker.ld
-
-override VFLAGS += \
-    -os vinix \
-    -enable-globals \
-    -nofloat \
-    -manualfree \
-    -experimental \
-    -message-limit 10000 \
-    -gc none \
-    -d no_backtrace
-
-ifeq ($(PROD),false)
-    override VFLAGS += -warn-about-allocs
-else
-    override VFLAGS += -prod
-    override CPPFLAGS += -DPROD
-endif
-
-# Use "find" to glob all *.v, *.c, and *.S files in the tree and obtain the
-# object and header dependency file names.
-override VFILES := $(shell find -L * -type f -name '*.v' | LC_ALL=C sort)
-override CFILES := $(shell cd c && find -L * -type f -name '*.c' | LC_ALL=C sort)
-override ASFILES := $(shell cd asm && find -L * -type f -name '*.S' | LC_ALL=C sort)
-override OBJ := $(addprefix obj/,$(CFILES:.c=.c.o) $(ASFILES:.S=.S.o))
-override HEADER_DEPS := $(addprefix obj/,$(CFILES:.c=.c.d) $(ASFILES:.S=.S.d))
-
-# Default target. This must come first, before header dependencies.
-.PHONY: all
-all: bin/$(OUTPUT)
-
-# Include header dependencies.
--include obj/blob.c.d $(HEADER_DEPS)
-
-# Link rules for building the C compiler runtime.
-cc-runtime-x86_64/cc-runtime.a: GNUmakefile cc-runtime/*
-	rm -rf cc-runtime-x86_64
-	cp -r cc-runtime cc-runtime-x86_64
-	$(MAKE) -C cc-runtime-x86_64 -f cc-runtime.mk \
-		CC="$(CC)" \
-		AR="$(AR)" \
-		CFLAGS="$(CFLAGS)" \
-		CPPFLAGS='-isystem ../freestnd-c-hdrs -DCC_RUNTIME_NO_FLOAT'
-
-# Link rules for the final executable.
-bin/$(OUTPUT): GNUmakefile linker.ld obj/blob.c.o $(OBJ) cc-runtime-x86_64/cc-runtime.a
-	mkdir -p "$$(dirname $@)"
-	$(CC) $(CFLAGS) $(LDFLAGS) obj/blob.c.o $(OBJ) cc-runtime-x86_64/cc-runtime.a -o $@
-
-obj/blob.c.o: GNUmakefile $(VFILES)
-	mkdir -p "$$(dirname $@)"
-	$(V) $(VFLAGS) -o obj/blob.c .
-	sed 's/call 0(/call *(/g;/Wimplicit-function-declaration/d' < obj/blob.c > obj/blob.c.tmp
-	mv obj/blob.c.tmp obj/blob.c
-	$(CC) $(CFLAGS) $(CPPFLAGS) -w -c obj/blob.c -o $@
-
-# Compilation rules for *.c files.
-obj/%.c.o: c/%.c GNUmakefile
-	mkdir -p "$$(dirname $@)"
-	$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@
-
-# Compilation rules for *.S files.
-obj/%.S.o: asm/%.S GNUmakefile
-	mkdir -p "$$(dirname $@)"
-	$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@
-
-# Remove object files and the final executable.
-.PHONY: clean
-clean:
-	rm -rf bin obj cc-runtime-x86_64
-
-# Remove everything built and generated including downloaded dependencies.
-.PHONY: distclean
-distclean: clean
-	rm -rf freestnd-c-hdrs cc-runtime c/flanterm c/nanoprintf* c/uacpi uacpi-repository
-
-# Install the final built executable to its final on-root location.
-.PHONY: install
-install: all
-	install -d "$(DESTDIR)$(PREFIX)/share/$(OUTPUT)"
-	install -m 644 bin/$(OUTPUT) "$(DESTDIR)$(PREFIX)/share/$(OUTPUT)/"
-
-# Try to undo whatever the "install" target did.
-.PHONY: uninstall
-uninstall:
-	rm -f "$(DESTDIR)$(PREFIX)/share/$(OUTPUT)/$(OUTPUT)"
-	-rmdir "$(DESTDIR)$(PREFIX)/share/$(OUTPUT)"
diff --git a/kernel/asm/int_thunks_asm.S b/kernel/asm/int_thunks_asm.S
deleted file mode 100644
index 590c4cf..0000000
--- a/kernel/asm/int_thunks_asm.S
+++ /dev/null
@@ -1,102 +0,0 @@
-.altmacro
-
-.macro THUNK num
-.global interrupt_thunk_\num
-interrupt_thunk_\num:
-.if \num != 8 && \num != 10 && \num != 11 && \num != 12 && \num != 13 && \num != 14 && \num != 17 && \num != 30
-    push $0
-.endif
-
-    cmpq $0x43, 16(%rsp) // if user
-    jne 1f
-    swapgs
-
-1:
-    push %r15
-    push %r14
-    push %r13
-    push %r12
-    push %r11
-    push %r10
-    push %r9
-    push %r8
-    push %rbp
-    push %rdi
-    push %rsi
-    push %rdx
-    push %rcx
-    push %rbx
-    push %rax
-    mov %es, %eax
-    push %rax
-    mov %ds, %eax
-    push %rax
-
-    cld
-
-    mov $0x30, %eax
-    mov %eax, %ds
-    mov %eax, %es
-    mov %eax, %ss
-
-    mov $\num, %rdi
-    mov $(\num * 8), %rax
-    lea interrupt_table(%rip), %rbx
-    add %rax, %rbx
-    mov %rsp, %rsi
-    xor %rbp, %rbp
-    call *(%rbx)
-
-    pop %rax
-    mov %eax, %ds
-    pop %rax
-    mov %eax, %es
-    pop %rax
-    pop %rbx
-    pop %rcx
-    pop %rdx
-    pop %rsi
-    pop %rdi
-    pop %rbp
-    pop %r8
-    pop %r9
-    pop %r10
-    pop %r11
-    pop %r12
-    pop %r13
-    pop %r14
-    pop %r15
-    add $8, %rsp
-
-    cmpq $0x43, 8(%rsp) // if user
-    jne 1f
-    swapgs
-
-1:
-    iretq
-.endm
-
-.macro thunkaddr num
-    .quad interrupt_thunk_\num
-.endm
-
-.section .data
-
-.global interrupt_thunks
-.align 8
-interrupt_thunks:
-.set i,0
-.rept 256
-    thunkaddr %i
-    .set i,i+1
-.endr
-
-.section .text
-
-.set i,0
-.rept 256
-    THUNK %i
-    .set i,i+1
-.endr
-
-.section .note.GNU-stack,"",%progbits
diff --git a/kernel/c/ctype.h b/kernel/c/ctype.h
deleted file mode 100644
index 944fd0c..0000000
--- a/kernel/c/ctype.h
+++ /dev/null
@@ -1,5 +0,0 @@
-#ifndef _CTYPE_H
-#define _CTYPE_H
-
-
-#endif
diff --git a/kernel/c/inttypes.h b/kernel/c/inttypes.h
deleted file mode 100644
index 8790741..0000000
--- a/kernel/c/inttypes.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#ifndef _INTTYPES_H
-#define _INTTYPES_H
-
-#include <stdint.h>
-
-#endif
diff --git a/kernel/c/locale.h b/kernel/c/locale.h
deleted file mode 100644
index 1c9b756..0000000
--- a/kernel/c/locale.h
+++ /dev/null
@@ -1,5 +0,0 @@
-#ifndef _LOCALE_H
-#define _LOCALE_H
-
-
-#endif
diff --git a/kernel/c/memory.c b/kernel/c/memory.c
deleted file mode 100644
index 06f12d6..0000000
--- a/kernel/c/memory.c
+++ /dev/null
@@ -1,54 +0,0 @@
-#include <stdint.h>
-#include <stddef.h>
-#include <string.h>
-
-void *memcpy(void *restrict dest, const void *restrict src, size_t n) {
-    uint8_t *restrict pdest = (uint8_t *restrict)dest;
-    const uint8_t *restrict psrc = (const uint8_t *restrict)src;
-
-    for (size_t i = 0; i < n; i++) {
-        pdest[i] = psrc[i];
-    }
-
-    return dest;
-}
-
-void *memset(void *s, int c, size_t n) {
-    uint8_t *p = (uint8_t *)s;
-
-    for (size_t i = 0; i < n; i++) {
-        p[i] = (uint8_t)c;
-    }
-
-    return s;
-}
-
-void *memmove(void *dest, const void *src, size_t n) {
-    uint8_t *pdest = (uint8_t *)dest;
-    const uint8_t *psrc = (const uint8_t *)src;
-
-    if (src > dest) {
-        for (size_t i = 0; i < n; i++) {
-            pdest[i] = psrc[i];
-        }
-    } else if (src < dest) {
-        for (size_t i = n; i > 0; i--) {
-            pdest[i-1] = psrc[i-1];
-        }
-    }
-
-    return dest;
-}
-
-int memcmp(const void *s1, const void *s2, size_t n) {
-    const uint8_t *p1 = (const uint8_t *)s1;
-    const uint8_t *p2 = (const uint8_t *)s2;
-
-    for (size_t i = 0; i < n; i++) {
-        if (p1[i] != p2[i]) {
-            return p1[i] < p2[i] ? -1 : 1;
-        }
-    }
-
-    return 0;
-}
diff --git a/kernel/c/printf.c b/kernel/c/printf.c
deleted file mode 100644
index 8c0e385..0000000
--- a/kernel/c/printf.c
+++ /dev/null
@@ -1,56 +0,0 @@
-#include <stdio.h>
-#include <stdbool.h>
-#include <stdint.h>
-#include <stddef.h>
-#include <stdarg.h>
-
-#define NANOPRINTF_IMPLEMENTATION
-#define NANOPRINTF_USE_FIELD_WIDTH_FORMAT_SPECIFIERS 1
-#define NANOPRINTF_USE_PRECISION_FORMAT_SPECIFIERS 0
-#define NANOPRINTF_USE_FLOAT_FORMAT_SPECIFIERS 0
-#define NANOPRINTF_USE_LARGE_FORMAT_SPECIFIERS 1
-#define NANOPRINTF_USE_BINARY_FORMAT_SPECIFIERS 1
-#define NANOPRINTF_USE_WRITEBACK_FORMAT_SPECIFIERS 1
-#include <nanoprintf.h>
-
-void dev__serial__out(char);
-void dev__serial__panic_out(char);
-void term__print(const char *, uint64_t);
-
-static void _putchar(int character, void *extra_arg) {
-    (void)character;
-    (void)extra_arg;
-#ifndef PROD
-    dev__serial__out(character);
-#endif
-}
-
-static void _putchar_panic(int character, void *extra_arg) {
-    (void)extra_arg;
-#ifndef PROD
-    dev__serial__panic_out(character);
-#endif
-    term__print((char *)&character, 1);
-}
-
-void klock__Lock_acquire(void *);
-void klock__Lock_release(void *);
-extern char printf_lock;
-
-int printf(const char *restrict fmt, ...) {
-    va_list l;
-    va_start(l, fmt);
-    klock__Lock_acquire(&printf_lock);
-    int ret = npf_vpprintf(_putchar, NULL, fmt, l);
-    klock__Lock_release(&printf_lock);
-    va_end(l);
-    return ret;
-}
-
-int printf_panic(const char *restrict fmt, ...) {
-    va_list l;
-    va_start(l, fmt);
-    int ret = npf_vpprintf(_putchar_panic, NULL, fmt, l);
-    va_end(l);
-    return ret;
-}
diff --git a/kernel/c/pthread.h b/kernel/c/pthread.h
deleted file mode 100644
index 3d380e1..0000000
--- a/kernel/c/pthread.h
+++ /dev/null
@@ -1,14 +0,0 @@
-#ifndef _PTHREAD_H
-#define _PTHREAD_H
-
-struct __thread_data {
-    void *ptr;
-};
-
-struct __threadattr {
-    void *ptr;
-};
-
-typedef struct __thread_data *pthread_t;
-
-#endif
diff --git a/kernel/c/stdio.h b/kernel/c/stdio.h
deleted file mode 100644
index 9fe8af4..0000000
--- a/kernel/c/stdio.h
+++ /dev/null
@@ -1,17 +0,0 @@
-#ifndef _STDIO_H
-#define _STDIO_H
-
-#include <stdarg.h>
-#include <stddef.h>
-
-struct __file {
-    void *ptr;
-};
-
-typedef struct __file FILE;
-
-int printf(const char *restrict format, ...);
-int fprintf(FILE *restrict stream, const char *restrict format, ...);
-int printf_panic(const char *restrict format, ...);
-
-#endif
diff --git a/kernel/c/stdlib.h b/kernel/c/stdlib.h
deleted file mode 100644
index 9d1d329..0000000
--- a/kernel/c/stdlib.h
+++ /dev/null
@@ -1,5 +0,0 @@
-#ifndef _STDLIB_H
-#define _STDLIB_H
-
-
-#endif
diff --git a/kernel/c/string.h b/kernel/c/string.h
deleted file mode 100644
index f419538..0000000
--- a/kernel/c/string.h
+++ /dev/null
@@ -1,11 +0,0 @@
-#ifndef _STRING_H
-#define _STRING_H
-
-#include <stddef.h>
-
-void *memcpy(void *restrict dest, const void *restrict src, size_t n);
-void *memset(void *s, int c, size_t n);
-void *memmove(void *dest, const void *src, size_t n);
-int memcmp(const void *s1, const void *s2, size_t n);
-
-#endif
diff --git a/kernel/c/symbols.h b/kernel/c/symbols.h
deleted file mode 100644
index fa97eee..0000000
--- a/kernel/c/symbols.h
+++ /dev/null
@@ -1,13 +0,0 @@
-#ifndef _SYMBOLS_H
-#define _SYMBOLS_H
-
-extern char text_start[];
-extern char text_end[];
-extern char rodata_start[];
-extern char rodata_end[];
-extern char data_start[];
-extern char data_end[];
-
-extern char interrupt_thunks[];
-
-#endif
diff --git a/kernel/c/sys/time.h b/kernel/c/sys/time.h
deleted file mode 100644
index 6cce7ab..0000000
--- a/kernel/c/sys/time.h
+++ /dev/null
@@ -1,5 +0,0 @@
-#ifndef _SYS_TIME_H
-#define _SYS_TIME_H
-
-
-#endif
diff --git a/kernel/c/sys/types.h b/kernel/c/sys/types.h
deleted file mode 100644
index bfe0fee..0000000
--- a/kernel/c/sys/types.h
+++ /dev/null
@@ -1,5 +0,0 @@
-#ifndef _SYS_TYPES_H
-#define _SYS_TYPES_H
-
-
-#endif
diff --git a/kernel/c/sys/wait.h b/kernel/c/sys/wait.h
deleted file mode 100644
index bdd3d15..0000000
--- a/kernel/c/sys/wait.h
+++ /dev/null
@@ -1,5 +0,0 @@
-#ifndef _SYS_WAIT_H
-#define _SYS_WAIT_H
-
-
-#endif
diff --git a/kernel/c/unistd.h b/kernel/c/unistd.h
deleted file mode 100644
index e4d64b9..0000000
--- a/kernel/c/unistd.h
+++ /dev/null
@@ -1,5 +0,0 @@
-#ifndef _UNISTD_H
-#define _UNISTD_H
-
-
-#endif
diff --git a/kernel/get-deps b/kernel/get-deps
deleted file mode 100755
index 2630111..0000000
--- a/kernel/get-deps
+++ /dev/null
@@ -1,97 +0,0 @@
-#! /bin/sh
-
-set -ex
-
-srcdir="$(dirname "$0")"
-test -z "$srcdir" && srcdir=.
-
-cd "$srcdir"
-
-clone_repo_commit() {
-    if test -d "$2/.git"; then
-        git -C "$2" reset --hard
-        git -C "$2" clean -fd
-        if ! git -C "$2" checkout $3; then
-            rm -rf "$2"
-        fi
-    else
-        if test -d "$2"; then
-            set +x
-            echo "error: '$2' is not a Git repository"
-            exit 1
-        fi
-    fi
-    if ! test -d "$2"; then
-        git clone $1 "$2"
-        if ! git -C "$2" checkout $3; then
-            rm -rf "$2"
-            exit 1
-        fi
-    fi
-}
-
-download_by_hash() {
-    DOWNLOAD_COMMAND="curl -Lo"
-    if ! command -v "${DOWNLOAD_COMMAND%% *}" >/dev/null 2>&1; then
-        DOWNLOAD_COMMAND="wget -O"
-        if ! command -v "${DOWNLOAD_COMMAND%% *}" >/dev/null 2>&1; then
-            set +x
-            echo "error: Neither curl nor wget found"
-            exit 1
-        fi
-    fi
-    SHA256_COMMAND="sha256sum"
-    if ! command -v "${SHA256_COMMAND%% *}" >/dev/null 2>&1; then
-        SHA256_COMMAND="sha256"
-        if ! command -v "${SHA256_COMMAND%% *}" >/dev/null 2>&1; then
-            set +x
-            echo "error: Cannot find sha256(sum) command"
-            exit 1
-        fi
-    fi
-    if ! test -f "$2" || ! $SHA256_COMMAND "$2" | grep $3 >/dev/null 2>&1; then
-        rm -f "$2"
-        mkdir -p "$2" && rm -rf "$2"
-        $DOWNLOAD_COMMAND "$2" $1
-        if ! $SHA256_COMMAND "$2" | grep $3 >/dev/null 2>&1; then
-            set +x
-            echo "error: Cannot download file '$2' by hash"
-            echo "incorrect hash:"
-            $SHA256_COMMAND "$2"
-            rm -f "$2"
-            exit 1
-        fi
-    fi
-}
-
-clone_repo_commit \
-    https://codeberg.org/osdev/freestnd-c-hdrs-0bsd.git \
-    freestnd-c-hdrs \
-    a87c192f3eb66b0806740dc67325f9ad23fc2d0b
-
-clone_repo_commit \
-    https://codeberg.org/osdev/cc-runtime.git \
-    cc-runtime \
-    576a01179f3298a4795b92f42c088f9f8800b56b
-
-# 1.0.2
-clone_repo_commit \
-    https://codeberg.org/mintsuki/flanterm.git \
-    c/flanterm \
-    9d0f67b89db1d83236f9ac291339248ba3d5f479
-
-download_by_hash \
-    https://github.com/charlesnicholson/nanoprintf/raw/0281ccf0b4105b194d5afb2cbb3cf308b9129d3a/nanoprintf.h \
-    c/nanoprintf_orig.h \
-    cb4f3b6fdb061c204fc641a3fd950d89daae1097bb1585f881cff056f775f6f1
-sed '/NPF_WRITEBACK(LONG_DOUBLE/d' c/nanoprintf_orig.h >c/nanoprintf.h
-
-# 2.0.0
-clone_repo_commit \
-    https://github.com/uACPI/uACPI.git \
-    uacpi-repository \
-    4ab3a78006a930e2cda5a92f33fc84e1ec6b4a3d
-rm -rf c/uacpi
-mkdir -p c/uacpi
-cp -rp uacpi-repository/include/uacpi/* c/uacpi/
-cp -rp uacpi-repository/source/* c/uacpi/
diff --git a/kernel/linker.ld b/kernel/linker.ld
deleted file mode 100644
index 11cdfdc..0000000
--- a/kernel/linker.ld
+++ /dev/null
@@ -1,73 +0,0 @@
-/* Tell the linker that we want an x86_64 ELF64 output file */
-OUTPUT_FORMAT(elf64-x86-64)
-
-/* We want the symbol main__kmain to be our entry point */
-ENTRY(main__kmain)
-
-/* Define the program headers we want so the bootloader gives us the right */
-/* MMU permissions; this also allows us to exert more control over the linking */
-/* process. */
-PHDRS
-{
-    text    PT_LOAD;
-    rodata  PT_LOAD;
-    data    PT_LOAD;
-}
-
-SECTIONS
-{
-    /* We want to be placed in the topmost 2GiB of the address space, for optimisations */
-    /* and because that is what the Limine spec mandates. */
-    /* Any address in this region will do, but often 0xffffffff80000000 is chosen as */
-    /* that is the beginning of the region. */
-    . = 0xffffffff80000000;
-
-    text_start = .;
-
-    .text : {
-        *(.text .text.*)
-    } :text
-
-    /* Move to the next memory page for .rodata */
-    . = ALIGN(CONSTANT(MAXPAGESIZE));
-
-    text_end = .;
-    rodata_start = .;
-
-    .rodata : {
-        *(.rodata .rodata.*)
-    } :rodata
-
-    /* Move to the next memory page for .data */
-    . = ALIGN(CONSTANT(MAXPAGESIZE));
-
-    rodata_end = .;
-    data_start = .;
-
-    .data : {
-        *(.data .data.*)
-
-        /* Place the sections that contain the Limine requests as part of the .data */
-        /* output section. */
-        KEEP(*(.requests_start_marker))
-        KEEP(*(.requests))
-        KEEP(*(.requests_end_marker))
-    } :data
-
-    /* NOTE: .bss needs to be the last thing mapped to :data, otherwise lots of */
-    /* unnecessary zeros will be written to the binary. */
-    /* If you need, for example, .init_array and .fini_array, those should be placed */
-    /* above this. */
-    .bss : {
-        *(.bss .bss.*)
-        *(COMMON)
-    } :data
-
-    data_end = .;
-
-    /* Discard .note.* and .eh_frame* since they may cause issues on some hosts. */
-    /DISCARD/ : {
-        *(.eh_frame*)
-        *(.note .note.*)
-    }
-}
diff --git a/kernel/main.v b/kernel/main.v
deleted file mode 100644
index 1c747f1..0000000
--- a/kernel/main.v
+++ /dev/null
@@ -1,156 +0,0 @@
-@[has_globals]
-module main
-
-import lib.stubs
-// unused, but needed for C function stubs
-import memory
-import term
-import acpi
-import uacpi
-import x86.gdt
-import x86.idt
-import x86.isr
-import x86.smp
-import initramfs
-import fs
-import sched
-import stat
-import dev.console
-import userland
-import pipe
-import futex
-import pci
-import dev.ata
-import dev.fbdev
-import dev.fbdev.simple
-import dev.nvme
-import dev.serial
-import dev.streams
-import dev.ahci
-import dev.hda
-import dev.random
-import dev.mouse
-import syscall.table
-import socket
-import time
-import x86.hpet
-import limine
-
-#include <symbols.h>
-
-@[_linker_section: '.requests']
-@[cinit]
-__global (
-	volatile limine_base_revision = limine.LimineBaseRevision{
-		revision: 2
-	}
-)
-
-fn C._vinit(argc int, argv voidptr)
-
-fn kmain_thread() {
-	term.framebuffer_init()
-
-	table.init_syscall_table()
-	socket.initialise()
-	pipe.initialise()
-	futex.initialise()
-	fs.initialise()
-
-	fs.mount(vfs_root, '', '/', 'tmpfs') or {}
-	fs.create(vfs_root, '/dev', 0o644 | stat.ifdir) or {}
-	fs.mount(vfs_root, '', '/dev', 'devtmpfs') or {}
-
-	initramfs.initialise()
-
-	streams.initialise()
-	random.initialise()
-	fbdev.initialise()
-	fbdev.register_driver(simple.get_driver())
-	console.initialise()
-	serial.initialise()
-	mouse.initialise()
-	hda.initialize()
-
-	$if !prod {
-		ata.initialise()
-		nvme.initialise()
-		ahci.initialise()
-	}
-
-	userland.start_program(false, vfs_root, '/sbin/init', ['/sbin/init'], [], '/dev/console',
-		'/dev/console', '/dev/console') or { panic('Could not start init process') }
-
-	sched.dequeue_and_die()
-}
-
-pub fn main() {
-	kmain()
-}
-
-pub fn kmain() {
-	// Ensure the base revision is supported.
-	if limine_base_revision.revision != 0 {
-		for {}
-	}
-
-	// Initialize the memory allocator.
-	memory.pmm_init()
-
-	// Call Vinit to initialise the runtime
-	C._vinit(0, 0)
-
-	// Initialize the earliest arch structures.
-	gdt.initialise()
-	idt.initialise()
-	isr.initialise()
-
-	x2apic_mode = smp_req.response.flags & 1 != 0
-
-	// Init terminal
-	term.initialise()
-	serial.early_initialise()
-
-	// a dummy call to avoid V warning about an unused `stubs` module
-	_ := stubs.toupper(0)
-
-	memory.vmm_init()
-
-	// ACPI init
-	acpi.initialise()
-	hpet.initialise()
-
-	pci.initialise()
-
-	mut uacpi_status := uacpi.UACPIStatus.ok
-
-	uacpi_status = C.uacpi_initialize(0)
-	if uacpi_status != uacpi.UACPIStatus.ok {
-		panic('uacpi_initialize(): ${C.uacpi_status_to_string(uacpi_status)}')
-	}
-
-	uacpi_status = C.uacpi_namespace_load()
-	if uacpi_status != uacpi.UACPIStatus.ok {
-		panic('uacpi_namespace_load(): ${C.uacpi_status_to_string(uacpi_status)}')
-	}
-
-	uacpi_status = C.uacpi_set_interrupt_model(uacpi.InterruptModel.ioapic)
-	if uacpi_status != uacpi.UACPIStatus.ok {
-		panic('uacpi_interrupt_model(): ${C.uacpi_status_to_string(uacpi_status)}')
-	}
-
-	uacpi_status = C.uacpi_namespace_initialize()
-	if uacpi_status != uacpi.UACPIStatus.ok {
-		panic('uacpi_namespace_initialize(): ${C.uacpi_status_to_string(uacpi_status)}')
-	}
-
-	smp.initialise()
-
-	time.initialise()
-
-	sched.initialise()
-
-	spawn kmain_thread()
-
-	sched.await()
-}
diff --git a/kernel/modules/acpi/acpi.v b/kernel/modules/acpi/acpi.v
deleted file mode 100644
index c254980..0000000
--- a/kernel/modules/acpi/acpi.v
+++ /dev/null
@@ -1,109 +0,0 @@
-@[has_globals]
-module acpi
-
-import limine
-
-pub struct SDT {
-	signature        [4]u8
-	length           u32
-	revision         u8
-	checksum         u8
-	oem_id           [6]u8
-	oem_table_id     [8]u8
-	oem_revision     u32
-	creator_id       u32
-	creator_revision u32
-}
-
-pub struct RSDP {
-	signature    [8]u8
-	checksum     u8
-	oem_id       [6]u8
-	revision     u8
-	rsdt_addr    u32
-	length       u32
-	xsdt_addr    u64
-	ext_checksum u8
-	reserved     [3]u8
-}
-
-struct RSDT {
-	header     SDT
-	ptrs_start u8
-}
-
-__global (
-	rsdp &RSDP
-	rsdt &RSDT
-)
-
-fn use_xsdt() bool {
-	return rsdp.revision >= 2 && rsdp.xsdt_addr != 0
-}
-
-@[_linker_section: '.requests']
-@[cinit]
-__global (
-	volatile rsdp_req = limine.LimineRSDPRequest{
-		response: unsafe { nil }
-	}
-)
-
-pub fn initialise() {
-	if rsdp_req.response == unsafe { nil } {
-		panic('acpi: ACPI not supported on this machine.')
-	}
-	rsdp_ptr := rsdp_req.response.address
-
-	if rsdp_ptr == 0 {
-		panic('acpi: ACPI not supported on this machine.')
-	}
-
-	rsdp = unsafe { rsdp_ptr }
-
-	if use_xsdt() == true {
-		rsdt = unsafe { &RSDT(byteptr(usize(rsdp.xsdt_addr)) + higher_half) }
-	} else {
-		rsdt = unsafe { &RSDT(byteptr(usize(rsdp.rsdt_addr)) + higher_half) }
-	}
-
-	println('acpi: Revision:  ${rsdp.revision}')
-	println('acpi: Use XSDT:  ${use_xsdt()}')
-	println('acpi: R/XSDT at: 0x${voidptr(rsdt):x}')
-
-	// We won't support HW reduced ACPI systems
-	if fadt := find_sdt('FACP', 0) {
-		if unsafe { &SDT(fadt).length >= 116 } {
-			fadt_flags := unsafe { (&u32(fadt))[28] }
-			if fadt_flags & (1 << 20) != 0 {
-				panic('acpi: OS does not support HW reduced ACPI systems.')
-			}
-		}
-	}
-
-	madt_init()
-}
-
-pub fn find_sdt(signature string, index int) !voidptr {
-	mut count := 0
-
-	entry_count := (rsdt.header.length - sizeof(SDT)) / u32(if use_xsdt() { 8 } else { 4 })
-
-	for i := 0; i < entry_count; i++ {
-		ptr := if use_xsdt() == true {
-			unsafe { &SDT(byteptr(usize(&u64(&rsdt.ptrs_start)[i])) + higher_half) }
-		} else {
-			unsafe { &SDT(byteptr(usize(&u32(&rsdt.ptrs_start)[i])) + higher_half) }
-		}
-		if unsafe { C.memcmp(voidptr(&ptr.signature), signature.str, 4) == 0 } {
-			if count != index {
-				count++
-				continue
-			}
-			println('acpi: Found "${signature}" at 0x${voidptr(ptr):x}')
-			return voidptr(ptr)
-		}
-	}
-
-	return error('acpi: "${signature}" not found')
-}
diff --git a/kernel/modules/acpi/madt.v b/kernel/modules/acpi/madt.v
deleted file mode 100644
index 0e4a84f..0000000
--- a/kernel/modules/acpi/madt.v
+++ /dev/null
@@ -1,117 +0,0 @@
-@[has_globals]
-module acpi
-
-@[packed]
-struct MADT {
-pub:
-	header               SDT
-	local_contoller_addr u32
-	flags                u32
-	entries_begin        u8
-}
-
-@[packed]
-struct MADTHeader {
-pub:
-	id     u8
-	length u8
-}
-
-@[packed]
-struct MADTLocalApic {
-pub:
-	header       MADTHeader
-	processor_id u8
-	apic_id      u8
-	flags        u32
-}
-
-@[packed]
-struct MADTLocalX2Apic {
-pub:
-	header       MADTHeader
-	reserved     [2]u8
-	x2apic_id    u32
-	flags        u32
-	processor_id u32
-}
-
-@[packed]
-struct MADTIoApic {
-pub:
-	header   MADTHeader
-	apic_id  u8
-	reserved u8
-	address  u32
-	gsib     u32
-}
-
-@[packed]
-struct MADTISO {
-pub:
-	header     MADTHeader
-	bus_source u8
-	irq_source u8
-	gsi        u32
-	flags      u16
-}
-
-@[packed]
-struct MADTNMI {
-pub:
-	header    MADTHeader
-	processor u8
-	flags     u16
-	lint      u8
-}
-
-__global (
-	madt               &MADT
-	madt_local_apics   []&MADTLocalApic
-	madt_local_x2apics []&MADTLocalX2Apic
-	madt_io_apics      []&MADTIoApic
-	madt_isos          []&MADTISO
-	madt_nmis          []&MADTNMI
-)
-
-fn madt_init() {
-	madt = unsafe { &MADT(find_sdt('APIC', 0) or { panic('System does not have a MADT') }) }
-
-	mut current := u64(0)
-
-	for {
-		if current + (sizeof(MADT) - 1) >= madt.header.length {
-			break
-		}
-
-		header := unsafe { &MADTHeader(u64(&madt.entries_begin) + current) }
-
-		match header.id {
-			0 {
-				println('acpi/madt: Found local APIC #${madt_local_apics.len}')
-				madt_local_apics << unsafe { &MADTLocalApic(header) }
-			}
-			9 {
-				if x2apic_mode {
-					println('acpi/madt: Found local x2APIC #${madt_local_x2apics.len}')
-					madt_local_x2apics << unsafe { &MADTLocalX2Apic(header) }
-				}
-			}
-			1 {
-				println('acpi/madt: Found IO APIC #${madt_io_apics.len}')
-				madt_io_apics << unsafe { &MADTIoApic(header) }
-			}
-			2 {
-				println('acpi/madt: Found ISO #${madt_isos.len}')
-				madt_isos << unsafe { &MADTISO(header) }
-			}
-			4 {
-				println('acpi/madt: Found NMI #${madt_nmis.len}')
-				madt_nmis << unsafe { &MADTNMI(header) }
-			}
-			else {}
-		}
-
-		current += u64(header.length)
-	}
-}
diff --git a/kernel/modules/bitmap/bitmap.v b/kernel/modules/bitmap/bitmap.v
deleted file mode 100644
index f29d0b2..0000000
--- a/kernel/modules/bitmap/bitmap.v
+++ /dev/null
@@ -1,31 +0,0 @@
-module bitmap
-
-import memory
-import lib
-
-pub struct GenericBitmap {
-mut:
-	raw_bitmap voidptr
-	entry_cnt  u64
-}
-
-pub fn (mut bmp GenericBitmap) initialise(entry_cnt u64) {
-	bmp.entry_cnt = entry_cnt
-	bmp.raw_bitmap = memory.calloc(lib.div_roundup(entry_cnt, u64(8)), 1)
-}
-
-pub fn (bmp GenericBitmap) alloc() ?u64 {
-	for i := u64(0); i < bmp.entry_cnt; i++ {
-		if lib.bittest(bmp.raw_bitmap, i) == false {
-			lib.bitset(bmp.raw_bitmap, i)
-			return i
-		}
-	}
-	return none
-}
-
-pub fn (bmp GenericBitmap) free_entry(index u64) {
-	if index < bmp.entry_cnt {
-		lib.bitreset(bmp.raw_bitmap, index)
-	}
-}
diff --git a/kernel/modules/block/partition/partition.v b/kernel/modules/block/partition/partition.v
deleted file mode 100644
index 273e071..0000000
--- a/kernel/modules/block/partition/partition.v
+++ /dev/null
@@ -1,202 +0,0 @@
-module partition
-
-import memory
-import stat
-import klock
-import event.eventstruct
-import resource
-import lib
-import fs
-
-const gpt_signature = u64(0x5452415020494645)
-
-struct Partition {
-pub mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	event    eventstruct.Event
-	status   int
-	can_mmap bool
-
-	parent_device &resource.Resource
-	device_offset u64
-	sector_cnt    u64
-}
-
-@[packed]
-struct MBRPartition {
-pub mut:
-	drive_status   u8
-	starting_chs   [3]u8
-	partition_type u8
-	ending_chs     [3]u8
-	starting_lba   u32
-	sector_cnt     u32
-}
-
-struct GPTPartitionEntry {
-pub mut:
-	partition_type_guid [2]u64
-	partition_guid      [2]u64
-	starting_lba        u64
-	last_lba            u64
-	flags               u64
-	name                [9]u64
-}
-
-@[packed]
-struct GPTPartitionTableHDR {
-pub mut:
-	identifier            u64
-	version               u32
-	hdr_size              u32
-	checksum              u32
-	reserved0             u32
-	hdr_lba               u64
-	alt_hdr_lba           u64
-	first_block           u64
-	last_block            u64
-	guid                  [2]u64
-	partition_array_lba   u64
-	partition_entry_cnt   u32
-	partition_entry_size  u32
-	crc32_partition_array u32
-}
-
-fn (mut this Partition) write(handle voidptr, buffer voidptr, loc u64, count u64) ?i64 {
-	if (count + loc) > (this.sector_cnt * this.parent_device.stat.blksize) {
-		return none
-	}
-
-	return this.parent_device.write(handle, buffer, loc + this.device_offset, count)
-}
-
-fn (mut this Partition) read(handle voidptr, buffer voidptr, loc u64, count u64) ?i64 {
-	if (count + loc) > (this.sector_cnt * this.parent_device.stat.blksize) {
-		return none
-	}
-
-	return this.parent_device.read(handle, buffer, loc + this.device_offset, count)
-}
-
-fn (mut this Partition) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	return this.parent_device.ioctl(handle, request, argp)
-}
-
-fn (mut this Partition) unref(handle voidptr) ? {
-	return this.parent_device.unref(handle)
-}
-
-fn (mut this Partition) link(handle voidptr) ? {
-}
-
-fn (mut this Partition) unlink(handle voidptr) ? {
-}
-
-fn (mut this Partition) grow(handle voidptr, new_size u64) ? {
-	return this.parent_device.grow(handle, new_size)
-}
-
-fn (mut this Partition) mmap(page u64, flags int) voidptr {
-	return this.parent_device.mmap(page, flags)
-}
-
-pub fn scan_partitions(mut parent_device resource.Resource, prefix string) int {
-	lba_buffer := memory.malloc(u64(parent_device.stat.blksize))
-
-	parent_device.read(0, lba_buffer, u64(parent_device.stat.blksize), u64(parent_device.stat.blksize)) or {
-		print('block: unable to read from device\n')
-		return -1
-	}
-
-	gpt_hdr := unsafe { *&GPTPartitionTableHDR(lba_buffer) }
-
-	if gpt_hdr.identifier == gpt_signature {
-		entry_list_lba := gpt_hdr.partition_array_lba
-		entry_cnt := gpt_hdr.partition_entry_cnt
-		entry_list_size := lib.align_up(sizeof(GPTPartitionEntry) * entry_cnt, u64(parent_device.stat.blksize))
-
-		if gpt_hdr.partition_entry_size != sizeof(GPTPartitionEntry) {
-			print('gpt: fatal parsing error\n')
-			return -1
-		}
-
-		partition_entry_buffer := memory.malloc(entry_list_size)
-
-		parent_device.read(0, partition_entry_buffer, u64(entry_list_lba * parent_device.stat.blksize),
-			entry_list_size) or {
-			print('block: unable to read from device\n')
-			return -1
-		}
-
-		partition_entry_list := unsafe { &GPTPartitionEntry(partition_entry_buffer) }
-
-		for i := 0; i < entry_cnt; i++ {
-			partition_entry := unsafe { &GPTPartitionEntry(&partition_entry_list[i]) }
-
-			if partition_entry.partition_type_guid[0] == 0
-				&& partition_entry.partition_type_guid[1] == 0 {
-				continue
-			}
-
-			mut partition := &Partition{
-				device_offset: u64(partition_entry.starting_lba * parent_device.stat.blksize)
-				sector_cnt:    partition_entry.last_lba - partition_entry.starting_lba
-				parent_device: unsafe { parent_device }
-			}
-
-			partition.stat.blocks = partition.sector_cnt
-			partition.stat.blksize = parent_device.stat.blksize
-			partition.stat.size = partition.sector_cnt * partition.stat.blksize
-			partition.stat.rdev = resource.create_dev_id()
-			partition.stat.mode = 0o644 | stat.ifblk
-
-			print('gpt: partition detected [start: ${partition.device_offset:x} sector cnt: ${partition.sector_cnt}]\n')
-
-			fs.devtmpfs_add_device(partition, '${prefix}${i}')
-		}
-
-		return 0
-	}
-
-	parent_device.read(0, lba_buffer, 0, u64(parent_device.stat.blksize)) or {
-		print('block: unable to read from device\n')
-		return -1
-	}
-
-	mbr_signature := unsafe { &u16(lba_buffer)[255] }
-
-	if mbr_signature == 0xaa55 {
-		partitions := unsafe { &MBRPartition(u64(lba_buffer) + 0x1be) }
-
-		for i := 0; i < 4; i++ {
-			if unsafe { partitions[i].partition_type } == 0
-				|| unsafe { partitions[i].partition_type } == 0xee {
-				continue
-			}
-
-			partition_entry := unsafe { &MBRPartition(&partitions[i]) }
-
-			mut partition := &Partition{
-				device_offset: u64(partition_entry.starting_lba * parent_device.stat.blksize)
-				sector_cnt:    partition_entry.sector_cnt
-				parent_device: unsafe { parent_device }
-			}
-
-			partition.stat.blocks = partition.sector_cnt
-			partition.stat.blksize = parent_device.stat.blksize
-			partition.stat.size = partition.sector_cnt * partition.stat.blksize
-			partition.stat.rdev = resource.create_dev_id()
-			partition.stat.mode = 0o644 | stat.ifblk
-
-			print('mbr: partition detected [start: ${partition.device_offset:x} sector cnt: ${partition.sector_cnt}]\n')
-
-			fs.devtmpfs_add_device(partition, '${prefix}${i}')
-		}
-
-		return 0
-	}
-
-	return -1
-}
diff --git a/kernel/modules/dev/ahci/ahci.v b/kernel/modules/dev/ahci/ahci.v
deleted file mode 100644
index 8059421..0000000
--- a/kernel/modules/dev/ahci/ahci.v
+++ /dev/null
@@ -1,544 +0,0 @@
-@[has_globals]
-module ahci
-
-import pci
-import memory
-import stat
-import klock
-import event.eventstruct
-import resource
-import errno
-import block.partition
-import fs
-import katomic
-import time.sys
-
-const ahci_class = 0x1
-const ahci_subclass = 0x6
-const ahci_progif = 0x1
-const sata_ata = 0x101
-const sata_atapi = u32(0xeb140101)
-const sata_semb = u32(0xc33C0101)
-const sata_pm = u32(0x96690101)
-const hba_cmd_st = 0x1
-const hba_cmd_fre = 0x10
-const hba_cmd_fr = 0x4000
-const hba_cmd_cr = 0x8000
-const fis_reg_h2d = 0x27
-const fis_reg_d2h = 0x34
-const fis_dma_enable = 0x39
-const fis_dma_setup = 0x41
-const fis_data = 0x46
-const fis_bist = 0x58
-const fis_pio_setup = 0x5f
-const fis_device_bits = 0xa1
-const sector_size = 0x200
-
-@[packed]
-struct AHCIRegisters {
-pub mut:
-	cap       u32
-	ghc       u32
-	ints      u32
-	pi        u32
-	vs        u32
-	ccc_ctl   u32
-	ccc_ports u32
-	em_lock   u32
-	em_ctl    u32
-	cap2      u32
-	bohc      u32
-	reserved  [29]u32
-	vendor    [24]u32
-}
-
-@[packed]
-struct AHCIPortRegisters {
-pub mut:
-	clb       u32
-	clbu      u32
-	fb        u32
-	fbu       u32
-	ints      u32
-	ie        u32
-	cmd       u32
-	reserved0 u32
-	tfd       u32
-	sig       u32
-	ssts      u32
-	sstl      u32
-	serr      u32
-	sact      u32
-	ci        u32
-	sntf      u32
-	fbs       u32
-	devslp    u32
-	reserved1 [11]u32
-	vs        [10]u32
-}
-
-@[packed]
-struct AHCIHBACommand {
-pub mut:
-	flags    u16
-	prdtl    u16
-	prdbc    u32
-	ctba     u32
-	ctbau    u32
-	reserved [4]u32
-}
-
-@[packed]
-struct AHCIHBAPrdt {
-pub mut:
-	dba      u32
-	dbau     u32
-	reserved u32
-	dbc      u32
-}
-
-@[packed]
-struct AHCIHBACommandTable {
-pub mut:
-	cfis     [64]u8
-	acmd     [16]u8
-	reserved [48]u8
-	prdt     [1]AHCIHBAPrdt
-}
-
-@[packed]
-struct AHCIFISh2d {
-pub mut:
-	fis_type u8
-	flags    u8
-	command  u8
-	featurel u8
-	lba0     u8
-	lba1     u8
-	lba2     u8
-	device   u8
-	lba3     u8
-	lba4     u8
-	lba5     u8
-	featureh u8
-	countl   u8
-	counth   u8
-	icc      u8
-	control  u8
-	reserved u32
-}
-
-@[packed]
-struct AHCIFISd2h {
-	fis_type  u8
-	flags     u8
-	status    u8
-	error     u8
-	lba0      u8
-	lba1      u8
-	lba2      u8
-	device    u8
-	lba3      u8
-	lba4      u8
-	lba5      u8
-	reserved2 u8
-	countl    u8
-	counth    u8
-	reserved3 u8
-	reserved4 u8
-}
-
-struct AHCIController {
-pub mut:
-	pci_bar pci.PCIBar
-	volatile regs    &AHCIRegisters
-
-	version_min u32
-	version_maj u32
-
-	port_cnt  u32
-	cmd_slots u32
-
-	device_list []&AHCIDevice
-}
-
-struct AHCIDevice {
-pub mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	event    eventstruct.Event
-	status   int
-	can_mmap bool
-
-	parent_controller &AHCIController
-	volatile regs              &AHCIPortRegisters
-}
-
-__global (
-	ahci_controller_list []&AHCIController
-)
-
-fn (mut dev AHCIDevice) read(handle voidptr, buffer voidptr, loc u64, count u64) ?i64 {
-	if loc % dev.stat.blksize != 0 || count % dev.stat.blksize != 0 {
-		errno.set(errno.eio)
-		return none
-	}
-
-	start_blk := loc / dev.stat.blksize
-	page_cnt := count / dev.stat.blksize
-
-	aligned_buffer := voidptr(u64(memory.pmm_alloc(u64(page_cnt))) + higher_half)
-
-	if dev.rw_lba(aligned_buffer, u64(start_blk), u64(page_cnt), false) == -1 {
-		errno.set(errno.eio)
-		memory.pmm_free(aligned_buffer, u64(page_cnt))
-		return none
-	}
-
-	unsafe { C.memcpy(buffer, aligned_buffer, count) }
-
-	memory.pmm_free(voidptr(u64(aligned_buffer) - higher_half), u64(page_cnt))
-
-	return i64(count)
-}
-
-fn (mut dev AHCIDevice) write(handle voidptr, buffer voidptr, loc u64, count u64) ?i64 {
-	if loc % dev.stat.blksize != 0 || count % dev.stat.blksize != 0 {
-		errno.set(errno.eio)
-		return none
-	}
-
-	start_blk := loc / dev.stat.blksize
-	page_cnt := count / dev.stat.blksize
-
-	aligned_buffer := voidptr(u64(memory.pmm_alloc(u64(page_cnt))) + higher_half)
-	unsafe { C.memcpy(aligned_buffer, buffer, count) }
-
-	if dev.rw_lba(aligned_buffer, u64(start_blk), u64(page_cnt), true) == -1 {
-		errno.set(errno.eio)
-		memory.pmm_free(aligned_buffer, u64(page_cnt))
-		return none
-	}
-
-	memory.pmm_free(voidptr(u64(aligned_buffer) - higher_half), u64(page_cnt))
-
-	return i64(count)
-}
-
-fn (mut dev AHCIDevice) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	return resource.default_ioctl(handle, request, argp)
-}
-
-fn (mut dev AHCIDevice) unref(handle voidptr) ? {
-	katomic.dec(mut &dev.refcount)
-}
-
-fn (mut dev AHCIDevice) link(handle voidptr) ? {
-	katomic.inc(mut &dev.stat.nlink)
-}
-
-fn (mut dev AHCIDevice) unlink(handle voidptr) ? {
-	katomic.dec(mut &dev.stat.nlink)
-}
-
-fn (mut dev AHCIDevice) grow(handle voidptr, new_size u64) ? {
-	return none
-}
-
-fn (mut dev AHCIDevice) mmap(page u64, flags int) voidptr {
-	return 0
-}
-
-fn (mut d AHCIDevice) find_cmd_slot() ?u32 {
-	for i := u32(0); i < d.parent_controller.cmd_slots; i++ {
-		if ((d.regs.sact | d.regs.ci) & (1 << i)) == 0 {
-			return i
-		}
-	}
-	return none
-}
-
-fn (mut d AHCIDevice) set_prdt(cmd_hdr &AHCIHBACommand, buffer u64, interrupt u32, byte_cnt u32) &AHCIHBACommandTable {
-	mut volatile cmd_table := unsafe {
-		&AHCIHBACommandTable((u64(cmd_hdr.ctba) | (u64(cmd_hdr.ctbau) << 32)) + higher_half)
-	}
-
-	cmd_table.prdt[0].dba = u32(buffer)
-	cmd_table.prdt[0].dbau = u32(buffer >> 32)
-	cmd_table.prdt[0].dbc = byte_cnt | ((interrupt & 1) << 31)
-
-	return cmd_table
-}
-
-fn (mut d AHCIDevice) send_cmd(slot u32) {
-	for (d.regs.tfd & (0x88)) != 0 {}
-
-	d.regs.cmd &= ~hba_cmd_st
-
-	for (d.regs.cmd & hba_cmd_cr) != 0 {}
-
-	d.regs.cmd |= hba_cmd_fr | hba_cmd_st
-	d.regs.ci = 1 << slot
-
-	for d.regs.ci & (1 << slot) != 0 {}
-
-	d.regs.cmd &= ~hba_cmd_st
-	for (d.regs.cmd & hba_cmd_st) != 0 {}
-	d.regs.cmd &= ~hba_cmd_fre
-}
-
-fn (mut d AHCIDevice) rw_lba(buffer voidptr, start u64, cnt u64, rw bool) int {
-	cmd_slot := d.find_cmd_slot() or {
-		print('ahci: no free cmd slot (come back later)\n')
-		return -1
-	}
-
-	mut volatile cmd_hdr := unsafe {
-		&AHCIHBACommand((u64(d.regs.clb) | (u64(d.regs.clbu) << 32)) + higher_half +
-			cmd_slot * sizeof(AHCIHBACommand))
-	}
-
-	cmd_hdr.flags &= ~(0b11111 | (1 << 6))
-	cmd_hdr.flags |= u16(sizeof(AHCIFISh2d) / 4)
-	cmd_hdr.prdtl = 1
-
-	mut volatile cmd_table := d.set_prdt(cmd_hdr, u64(buffer) - higher_half, 1, u32(cnt * sector_size - 1))
-
-	mut volatile cmd_ptr := unsafe { &AHCIFISh2d(&cmd_table.cfis) }
-	unsafe { C.memset(cmd_ptr, 0, sizeof(AHCIFISh2d)) }
-
-	if rw == true {
-		cmd_ptr.command = 0x35
-	} else {
-		cmd_ptr.command = 0x25
-	}
-
-	cmd_ptr.fis_type = fis_reg_h2d
-	cmd_ptr.flags = (1 << 7)
-	cmd_ptr.device = 1 << 6
-
-	cmd_ptr.lba0 = u8(start & 0xff)
-	cmd_ptr.lba1 = u8((start >> 8) & 0xff)
-	cmd_ptr.lba2 = u8((start >> 16) & 0xff)
-	cmd_ptr.lba3 = u8((start >> 24) & 0xff)
-	cmd_ptr.lba4 = u8((start >> 32) & 0xff)
-	cmd_ptr.lba5 = u8((start >> 40) & 0xff)
-
-	cmd_ptr.countl = u8(cnt & 0xff)
-	cmd_ptr.counth = u8((cnt >> 8) & 0xff)
-
-	d.send_cmd(cmd_slot)
-
-	return 0
-}
-
-fn (mut d AHCIDevice) initialise() ?int {
-	cmd_slot := d.find_cmd_slot() or {
-		print('ahci: no free cmd slot (come back later)\n')
-		return none
-	}
-
-	command_list := u64(memory.pmm_alloc(1))
-
-	d.regs.clb = u32(command_list)
-	d.regs.clbu = u32(command_list >> 32)
-
-	for i := u32(0); i < 32; i++ {
-		mut volatile cmd_hdr := unsafe {
-			&AHCIHBACommand((u64(d.regs.clb) | (u64(d.regs.clbu) << 32)) + higher_half +
-				i * sizeof(AHCIHBACommand))
-		}
-
-		desc_base := u64(memory.pmm_alloc(1))
-
-		cmd_hdr.ctba = u32(desc_base)
-		cmd_hdr.ctbau = u32(desc_base >> 32)
-	}
-
-	fib_base := u64(memory.pmm_alloc(1))
-
-	d.regs.fb = u32(fib_base)
-	d.regs.fbu = u32(fib_base >> 32)
-
-	d.regs.cmd |= (1 << 0) | (1 << 4)
-
-	mut volatile cmd_hdr := unsafe {
-		&AHCIHBACommand((u64(d.regs.clb) | (u64(d.regs.clbu) << 32)) + higher_half +
-			cmd_slot * sizeof(AHCIHBACommand))
-	}
-
-	cmd_hdr.flags &= ~0b11111 | (1 << 7)
-	cmd_hdr.flags |= u16(sizeof(AHCIFISh2d) / 4)
-	cmd_hdr.prdtl = 1
-
-	mut identity := unsafe { &u16(u64(memory.pmm_alloc(1)) + higher_half) }
-
-	mut volatile cmd_table := d.set_prdt(cmd_hdr, u64(identity) - higher_half, 1, 511)
-
-	mut volatile cmd_ptr := unsafe { &AHCIFISh2d(&cmd_table.cfis) }
-	unsafe { C.memset(cmd_ptr, 0, sizeof(AHCIFISh2d)) }
-
-	cmd_ptr.command = 0xec
-	cmd_ptr.flags = (1 << 7)
-	cmd_ptr.fis_type = fis_reg_h2d
-
-	d.send_cmd(cmd_slot)
-
-	mut sector_cnt := unsafe { *(&u64(&identity[100])) }
-
-	mut serial_number := &char(memory.malloc(21))
-	mut firmware_revision := &char(memory.malloc(9))
-	mut model_number := &char(memory.malloc(41))
-
-	unsafe {
-		C.memcpy(serial_number, &u8(identity) + 20, 20)
-
-		for i := 0; i < 20; i += 2 { // swap endianess
-			tmp := serial_number[i]
-			serial_number[i] = serial_number[i + 1]
-			serial_number[i + 1] = tmp
-		}
-
-		C.memcpy(firmware_revision, &u8(identity) + 46, 8)
-
-		for i := 0; i < 8; i += 2 { // swap endianess
-			tmp := firmware_revision[i]
-			firmware_revision[i] = firmware_revision[i + 1]
-			firmware_revision[i + 1] = tmp
-		}
-
-		C.memcpy(model_number, &u8(identity) + 54, 40)
-
-		for i := 0; i < 40; i += 2 { // swap endianess
-			tmp := model_number[i]
-			model_number[i] = model_number[i + 1]
-			model_number[i + 1] = tmp
-		}
-
-		print('ahci: device: serial number: ${cstring_to_vstring(serial_number)}\n')
-		print('ahci: device: firmware revision: ${cstring_to_vstring(firmware_revision)}\n')
-		print('ahci: device: model number: ${cstring_to_vstring(model_number)}\n')
-	}
-	print('ahci: device: sector count: ${sector_cnt}\n')
-
-	d.stat.blocks = sector_cnt
-	d.stat.blksize = sector_size
-	d.stat.size = sector_cnt * sector_size
-	d.stat.rdev = resource.create_dev_id()
-	d.stat.mode = 0o644 | stat.ifblk
-
-	return 0
-}
-
-pub fn (mut c AHCIController) declare_ownership() int {
-	if c.regs.cap2 & (1 << 0) == 0 {
-		print('ahci: bios handoff not supported\n')
-		return -1
-	}
-
-	c.regs.bohc |= (1 << 1)
-
-	for c.regs.bohc & (1 << 0) == 0 {
-		asm volatile amd64 {
-			pause
-		}
-	}
-
-	sys.nsleep(25 * 1000000)
-
-	if c.regs.bohc & (1 << 4) != 0 {
-		sys.nsleep(2 * 1000000000)
-	}
-
-	if c.regs.bohc & (1 << 4) != 0 || c.regs.bohc & (1 << 0) != 0 || c.regs.bohc & (1 << 1) == 0 {
-		print('ahci: bios handoff failed\n')
-		return -1
-	}
-
-	return 0
-}
-
-pub fn (mut c AHCIController) initialise(pci_device &pci.PCIDevice) int {
-	pci_device.enable_bus_mastering()
-
-	if pci_device.is_bar_present(0x5) == false {
-		print('ahci: unable to locate BAR5\n')
-		return -1
-	}
-
-	c.pci_bar = pci_device.get_bar(0x5)
-	c.regs = unsafe { &AHCIRegisters(c.pci_bar.base + higher_half) }
-
-	c.version_maj = (c.regs.vs >> 16) & 0xffff
-	c.version_min = c.regs.vs & 0xffff
-
-	print('ahci: controller detected version ${c.version_maj:x}:${c.version_min:x}\n')
-
-	if c.regs.cap & (1 << 31) == 0 {
-		print('ahci: 64 bit addressing not supported\n')
-		return -1
-	}
-
-	c.declare_ownership()
-
-	c.regs.ghc |= (1 << 31)
-	c.regs.ghc &= ~(1 << 1)
-
-	c.port_cnt = c.regs.cap & 0b11111
-	c.cmd_slots = (c.regs.cap >> 8) & 0b11111
-
-	for i := u64(0); i < c.port_cnt; i++ {
-		if c.regs.pi & (1 << i) != 0 {
-			mut volatile port := unsafe {
-				&AHCIPortRegisters(c.pci_bar.base + sizeof(AHCIRegisters) +
-					i * sizeof(AHCIPortRegisters) + higher_half)
-			}
-
-			match port.sig {
-				sata_ata {
-					print('ahci: sata drive found on port ${i}\n')
-
-					mut device := &AHCIDevice{
-						parent_controller: unsafe { c }
-						regs:              port
-					}
-
-					device.initialise() or {
-						print('unable to init device\n')
-						continue
-					}
-
-					fs.devtmpfs_add_device(device, 'sd${c.device_list.len}')
-					partition.scan_partitions(mut device, 'sd${c.device_list.len}-')
-
-					c.device_list << device
-				}
-				sata_atapi {
-					print('ahci: enclosure management bridge found on port ${i}\n')
-				}
-				sata_pm {
-					print('ahci: port multipler found on port ${i}\n')
-				}
-				else {}
-			}
-		}
-	}
-
-	return 0
-}
-
-pub fn initialise() {
-	for device in scanned_devices {
-		if device.class == ahci_class && device.subclass == ahci_subclass
-			&& device.prog_if == ahci_progif {
-			mut ahci_device := &AHCIController{
-				regs: unsafe { nil }
-			}
-
-			if ahci_device.initialise(device) != -1 {
-				ahci_controller_list << ahci_device
-			}
-		}
-	}
-}
diff --git a/kernel/modules/dev/ata/ata.v b/kernel/modules/dev/ata/ata.v
deleted file mode 100644
index 28d2273..0000000
--- a/kernel/modules/dev/ata/ata.v
+++ /dev/null
@@ -1,350 +0,0 @@
-module ata
-
-import pci
-import stat
-import klock
-import memory
-import resource
-import fs
-import x86.kio
-import lib
-import errno
-import event.eventstruct
-import katomic
-
-const pci_class = 0x1
-
-const pci_subclass = 0x1
-
-const pci_progif = 0x80
-
-const ata_ports = [0x1f0, 0x1f0, 0x170, 0x170]
-
-const ata_bytes_per_sector = 512
-
-const ata_sectors_per_prdt = 16
-
-const ata_bytes_per_prdt = ata_bytes_per_sector * ata_sectors_per_prdt
-
-@[packed]
-struct PRDT {
-pub mut:
-	buffer_phys   u32
-	transfer_size u16
-	mark_end      u16
-}
-
-struct ATADrive {
-pub mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	event    eventstruct.Event
-	status   int
-	can_mmap bool
-	// ATA specific stuff.
-	is_master         bool
-	data_port         u16
-	error_port        u16
-	sector_count_port u16
-	lba_low_port      u16
-	lba_mid_port      u16
-	lba_hi_port       u16
-	device_port       u16
-	cmd_port          u16
-	bar4              u16
-	bmr_command       u16
-	bmr_status        u16
-	bmr_prdt          u16
-	prdt              &PRDT
-	prdt_phys         u32
-	prdt_cache        &u8
-}
-
-pub fn initialise() {
-	// Fetch and setup the PCI device.
-	mut dev := pci.get_device_by_class(pci_class, pci_subclass, pci_progif, 0) or {
-		print('ata: No suitable PCI devices found\n')
-		return
-	}
-	dev.enable_bus_mastering()
-
-	// Probe ports and add devices.
-	mut index := 0
-	for i in 0 .. ata_ports.len {
-		drive := init_ata_drive(i, mut dev) or { continue }
-		name := 'ata${index}'
-		fs.devtmpfs_add_device(drive, name)
-		print('ata: Port ${i} initialised as ${name} (${drive.stat.size} bytes)\n')
-		index += 1
-	}
-}
-
-fn init_ata_drive(port_index int, mut pci_device pci.PCIDevice) ?&ATADrive {
-	assert port_index < ata_ports.len
-
-	// Fetch the IO ports and comm addresses of the drive.
-	port := u16(ata_ports[port_index])
-	mut bar4 := u16(pci_device.read[u32](0x20))
-	if bar4 & 1 != 0 {
-		bar4 &= 0xfffffffc
-	}
-	mut dev := &ATADrive{
-		is_master:         port_index % 2 != 0
-		data_port:         port
-		error_port:        port + 1
-		sector_count_port: port + 2
-		lba_low_port:      port + 3
-		lba_mid_port:      port + 4
-		lba_hi_port:       port + 5
-		device_port:       port + 6
-		cmd_port:          port + 7
-		bar4:              bar4
-		bmr_command:       bar4
-		bmr_status:        bar4 + 2
-		bmr_prdt:          bar4 + 4
-		prdt:              &PRDT(unsafe { nil })
-		// To be filled later.
-		prdt_phys: 0
-		// To be filled later.
-		prdt_cache: unsafe { &u8(0) }
-		// To be filled later.
-	}
-
-	// Identify the drive.
-	val := if dev.is_master { 0xa0 } else { 0xb0 }
-	kio.port_out[u8](dev.device_port, u8(val))
-	kio.port_out[u8](dev.sector_count_port, 0)
-	kio.port_out[u8](dev.lba_low_port, 0)
-	kio.port_out[u8](dev.lba_mid_port, 0)
-	kio.port_out[u8](dev.lba_hi_port, 0)
-	kio.port_out[u8](dev.cmd_port, 0xec)
-
-	if kio.port_in[u8](dev.cmd_port) == 0 {
-		print('ata: Port ${port_index} is not connected\n')
-		return none
-	} else {
-		mut timeout := 0
-		for kio.port_in[u8](dev.cmd_port) & 0b10000000 != 0 {
-			if timeout == 100000 {
-				print('ata: Port ${port_index} is not answering\n')
-				return none
-			}
-			timeout += 1
-		}
-	}
-
-	// Check for non-standard ATAPI.
-	if kio.port_in[u8](dev.lba_mid_port) != 0 || kio.port_in[u8](dev.lba_hi_port) != 0 {
-		print('ata: Port ${port_index} is non-standard ATAPI\n')
-		return none
-	}
-
-	mut timeout := 0
-	for {
-		status := kio.port_in[u8](dev.cmd_port)
-		if status & 0b00000001 != 0 {
-			print('ata: Port ${port_index} errored out\n')
-			return none
-		}
-		if status & 0b00001000 != 0 {
-			break
-		}
-		if timeout == 100000 {
-			print('ata: Port ${port_index} hanged\n')
-			return none
-		}
-	}
-
-	// Storing identify info.
-	mut identify := [256]u16{}
-	for i in 0 .. identify.len {
-		identify[i] = kio.port_in[u16](dev.data_port)
-	}
-
-	// Wacky PCI things
-	mut cmd_register := pci_device.read[u32](0x4)
-	if cmd_register & (1 << 2) == 0 {
-		cmd_register |= 1 << 2
-		pci_device.write(0x4, cmd_register)
-	}
-
-	// Final touches to the dev structure and return.
-	dev.stat.blocks = unsafe { (&u64(u64(&identify[100])))[0] }
-	dev.stat.blksize = 512
-	dev.stat.size = dev.stat.blocks * dev.stat.blksize
-	dev.stat.rdev = resource.create_dev_id()
-	dev.stat.mode = 0o644 | stat.ifblk
-	dev.prdt_phys = u32(u64(memory.pmm_alloc(1)))
-	dev.prdt = unsafe { &PRDT(dev.prdt_phys + higher_half) }
-	dev.prdt.buffer_phys = u32(u64(memory.pmm_alloc(lib.div_roundup[u64](ata_bytes_per_prdt,
-		page_size))))
-	dev.prdt.transfer_size = ata_bytes_per_prdt
-	dev.prdt.mark_end = 0x8000
-	dev.prdt_cache = unsafe { &u8(u64(dev.prdt.buffer_phys) + higher_half) }
-	return dev
-}
-
-fn (mut this ATADrive) mmap(page u64, flags int) voidptr {
-	return 0
-}
-
-fn (mut dev ATADrive) read(handle voidptr, buffer voidptr, loc u64, count u64) ?i64 {
-	// Check alignment to the sector boundary.
-	if loc % ata_bytes_per_sector != 0 || count % ata_bytes_per_sector != 0 {
-		errno.set(errno.eio)
-		return none
-	}
-
-	// Actually read.
-	sector_start := loc / ata_bytes_per_sector
-	sector_count := count / ata_bytes_per_sector
-
-	dev.l.acquire()
-	defer {
-		dev.l.release()
-	}
-
-	for i := u64(0); i < sector_count; i += ata_sectors_per_prdt {
-		sector_loc := sector_start + i
-		kio.port_out[u8](dev.bmr_command, 0)
-		kio.port_out[u32](dev.bmr_prdt, dev.prdt_phys)
-		bmr_status := kio.port_in[u8](dev.bmr_status)
-		kio.port_out[u8](dev.bmr_status, bmr_status | 0x4 | 0x2)
-
-		val := if dev.is_master { 0x40 } else { 0x50 }
-		kio.port_out[u8](dev.device_port, u8(val))
-
-		actual_count := if i + ata_sectors_per_prdt > sector_count {
-			sector_count % ata_sectors_per_prdt
-		} else {
-			ata_sectors_per_prdt
-		}
-
-		kio.port_out[u8](dev.sector_count_port, u8(actual_count >> 8))
-		kio.port_out[u8](dev.lba_low_port, u8((sector_loc & 0x000000FF000000) >> 24))
-		kio.port_out[u8](dev.lba_mid_port, u8((sector_loc & 0x0000FF00000000) >> 32))
-		kio.port_out[u8](dev.lba_hi_port, u8((sector_loc & 0x00FF0000000000) >> 40))
-		kio.port_out[u8](dev.sector_count_port, u8(actual_count & 0xff))
-		kio.port_out[u8](dev.lba_low_port, u8(sector_loc & 0x000000000000FF))
-		kio.port_out[u8](dev.lba_mid_port, u8((sector_loc & 0x0000000000FF00) >> 8))
-		kio.port_out[u8](dev.lba_hi_port, u8((sector_loc & 0x00000000FF0000) >> 16))
-
-		kio.port_out[u8](dev.cmd_port, 0x25) // READ_DMA command
-		kio.port_out[u8](dev.bmr_command, 0x8 | 0x1)
-
-		for {
-			status := kio.port_in[u8](dev.cmd_port)
-			if status & 0x80 == 0 {
-				break
-			}
-			if status & 0x01 != 0 {
-				print('ata: Error reading sector ${sector_loc} on drive')
-				return none
-			}
-		}
-		kio.port_out[u8](dev.bmr_command, 0)
-
-		buffer_final := voidptr(u64(buffer) + i * ata_bytes_per_sector)
-		unsafe { C.memcpy(buffer_final, dev.prdt_cache, actual_count * ata_bytes_per_sector) }
-	}
-	return i64(count)
-}
-
-fn (mut dev ATADrive) write(handle voidptr, buffer voidptr, loc u64, count u64) ?i64 {
-	// Check alignment to the sector boundary.
-	if loc % ata_bytes_per_sector != 0 || count % ata_bytes_per_sector != 0 {
-		errno.set(errno.eio)
-		return none
-	}
-
-	// Actually write.
-	sector_start := loc / ata_bytes_per_sector
-	sector_count := count / ata_bytes_per_sector
-
-	dev.l.acquire()
-	defer {
-		dev.l.release()
-	}
-
-	for i := u64(0); i < sector_count; i += ata_sectors_per_prdt {
-		sector_loc := sector_start + i
-
-		kio.port_out[u8](dev.bmr_command, 0)
-		kio.port_out[u32](dev.bmr_prdt, dev.prdt_phys)
-		bmr_status := kio.port_in[u8](dev.bmr_status)
-		kio.port_out[u8](dev.bmr_status, bmr_status | 0x4 | 0x2)
-
-		val := if dev.is_master { 0x40 } else { 0x50 }
-		kio.port_out[u8](dev.device_port, u8(val))
-
-		actual_count := if i + ata_sectors_per_prdt > sector_count {
-			sector_count % ata_sectors_per_prdt
-		} else {
-			ata_sectors_per_prdt
-		}
-
-		// Copy buffer to DMA area.
-		buffer_final := voidptr(u64(buffer) + i * ata_bytes_per_sector)
-		unsafe { C.memcpy(dev.prdt_cache, buffer_final, actual_count * ata_bytes_per_sector) }
-
-		kio.port_out[u8](dev.sector_count_port, u8(actual_count >> 8))
-		kio.port_out[u8](dev.lba_low_port, u8((sector_loc & 0x000000FF000000) >> 24))
-		kio.port_out[u8](dev.lba_mid_port, u8((sector_loc & 0x0000FF00000000) >> 32))
-		kio.port_out[u8](dev.lba_hi_port, u8((sector_loc & 0x00FF0000000000) >> 40))
-		kio.port_out[u8](dev.sector_count_port, u8(actual_count & 0xff))
-		kio.port_out[u8](dev.lba_low_port, u8(sector_loc & 0x000000000000FF))
-		kio.port_out[u8](dev.lba_mid_port, u8((sector_loc & 0x0000000000FF00) >> 8))
-		kio.port_out[u8](dev.lba_hi_port, u8((sector_loc & 0x00000000FF0000) >> 16))
-
-		kio.port_out[u8](dev.cmd_port, 0x35) // WRITE_DMA command
-		kio.port_out[u8](dev.bmr_command, 0x1)
-
-		for {
-			status := kio.port_in[u8](dev.cmd_port)
-			if status & 0x80 == 0 {
-				break
-			}
-			if status & 0x01 != 0 {
-				print('ata: Error reading sector ${sector_loc} on drive')
-				return none
-			}
-		}
-		kio.port_out[u8](dev.bmr_command, 0)
-
-		kio.port_out[u8](dev.device_port, u8(val))
-		kio.port_out[u8](dev.cmd_port, 0xea) // Cache flush EXT command.
-		for {
-			status := kio.port_in[u8](dev.cmd_port)
-			if status & 0x80 == 0 {
-				break
-			}
-			if status & 0x01 != 0 {
-				print('ata: Error reading sector ${sector_loc} on drive')
-				return none
-			}
-		}
-	}
-
-	return i64(count)
-}
-
-fn (mut dev ATADrive) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	return resource.default_ioctl(handle, request, argp)
-}
-
-fn (mut dev ATADrive) unref(handle voidptr) ? {
-	katomic.dec(mut &dev.refcount)
-}
-
-fn (mut dev ATADrive) link(handle voidptr) ? {
-	katomic.inc(mut &dev.stat.nlink)
-}
-
-fn (mut dev ATADrive) unlink(handle voidptr) ? {
-	katomic.dec(mut &dev.stat.nlink)
-}
-
-fn (mut dev ATADrive) grow(handle voidptr, new_size u64) ? {
-	return none
-}
diff --git a/kernel/modules/dev/console/console.v b/kernel/modules/dev/console/console.v
deleted file mode 100644
index 9900599..0000000
--- a/kernel/modules/dev/console/console.v
+++ /dev/null
@@ -1,852 +0,0 @@
-@[has_globals]
-module console
-
-import x86.idt
-import x86.apic
-import x86.kio
-import event
-import event.eventstruct
-import klock
-import stat
-import term
-import fs
-import ioctl
-import resource
-import errno
-import termios
-import file
-import userland
-import proc
-import katomic
-import flanterm as _
-
-const max_scancode = 0x57
-const capslock = 0x3a
-const numlock = 0x45
-const left_alt = 0x38
-const left_alt_rel = 0xb8
-const right_shift = 0x36
-const left_shift = 0x2a
-const right_shift_rel = 0xb6
-const left_shift_rel = 0xaa
-const ctrl = 0x1d
-const ctrl_rel = 0x9d
-const console_buffer_size = 1024
-const console_bigbuf_size = 4096
-
-__global (
-	console_convtab_numpad_numlock map[u8]u8
-	console_res                    = &Console(unsafe { nil })
-	console_read_lock              klock.Lock
-	console_event                  eventstruct.Event
-	console_numlock_active         = bool(false)
-	console_capslock_active        = bool(false)
-	console_shift_active           = bool(false)
-	console_ctrl_active            = bool(false)
-	console_alt_active             = bool(false)
-	console_extra_scancodes        = bool(false)
-	console_buffer                 [console_buffer_size]u8
-	console_buffer_i               = u64(0)
-	console_bigbuf                 [console_bigbuf_size]u8
-	console_bigbuf_i               = u64(0)
-	console_termios                = &termios.Termios(unsafe { nil })
-	console_decckm                 = false
-	// XXX this is a massive hack to allow ctrl-c and friends without process
-	// groups
-	latest_thread                  = &proc.Thread(unsafe { nil })
-)
-
-const convtab_capslock = [
-	`\0`,
-	`\e`,
-	`1`,
-	`2`,
-	`3`,
-	`4`,
-	`5`,
-	`6`,
-	`7`,
-	`8`,
-	`9`,
-	`0`,
-	`-`,
-	`=`,
-	`\b`,
-	`\t`,
-	`Q`,
-	`W`,
-	`E`,
-	`R`,
-	`T`,
-	`Y`,
-	`U`,
-	`I`,
-	`O`,
-	`P`,
-	`[`,
-	`]`,
-	`\n`,
-	`\0`,
-	`A`,
-	`S`,
-	`D`,
-	`F`,
-	`G`,
-	`H`,
-	`J`,
-	`K`,
-	`L`,
-	`;`,
-	`'`,
-	`\``,
-	`\0`,
-	`\\`,
-	`Z`,
-	`X`,
-	`C`,
-	`V`,
-	`B`,
-	`N`,
-	`M`,
-	`,`,
-	`.`,
-	`/`,
-	`\0`,
-	`\0`,
-	`\0`,
-	` `,
-]
-
-const convtab_shift = [
-	`\0`,
-	`\e`,
-	`!`,
-	`@`,
-	`#`,
-	`$`,
-	`%`,
-	`^`,
-	`&`,
-	`*`,
-	`(`,
-	`)`,
-	`_`,
-	`+`,
-	`\b`,
-	`\t`,
-	`Q`,
-	`W`,
-	`E`,
-	`R`,
-	`T`,
-	`Y`,
-	`U`,
-	`I`,
-	`O`,
-	`P`,
-	`{`,
-	`}`,
-	`\n`,
-	`\0`,
-	`A`,
-	`S`,
-	`D`,
-	`F`,
-	`G`,
-	`H`,
-	`J`,
-	`K`,
-	`L`,
-	`:`,
-	`"`,
-	`~`,
-	`\0`,
-	`|`,
-	`Z`,
-	`X`,
-	`C`,
-	`V`,
-	`B`,
-	`N`,
-	`M`,
-	`<`,
-	`>`,
-	`?`,
-	`\0`,
-	`\0`,
-	`\0`,
-	` `,
-]
-
-const convtab_shift_capslock = [
-	`\0`,
-	`\e`,
-	`!`,
-	`@`,
-	`#`,
-	`$`,
-	`%`,
-	`^`,
-	`&`,
-	`*`,
-	`(`,
-	`)`,
-	`_`,
-	`+`,
-	`\b`,
-	`\t`,
-	`q`,
-	`w`,
-	`e`,
-	`r`,
-	`t`,
-	`y`,
-	`u`,
-	`i`,
-	`o`,
-	`p`,
-	`{`,
-	`}`,
-	`\n`,
-	`\0`,
-	`a`,
-	`s`,
-	`d`,
-	`f`,
-	`g`,
-	`h`,
-	`j`,
-	`k`,
-	`l`,
-	`:`,
-	`"`,
-	`~`,
-	`\0`,
-	`|`,
-	`z`,
-	`x`,
-	`c`,
-	`v`,
-	`b`,
-	`n`,
-	`m`,
-	`<`,
-	`>`,
-	`?`,
-	`\0`,
-	`\0`,
-	`\0`,
-	` `,
-]
-
-const convtab_nomod = [
-	`\0`,
-	`\e`,
-	`1`,
-	`2`,
-	`3`,
-	`4`,
-	`5`,
-	`6`,
-	`7`,
-	`8`,
-	`9`,
-	`0`,
-	`-`,
-	`=`,
-	`\b`,
-	`\t`,
-	`q`,
-	`w`,
-	`e`,
-	`r`,
-	`t`,
-	`y`,
-	`u`,
-	`i`,
-	`o`,
-	`p`,
-	`[`,
-	`]`,
-	`\n`,
-	`\0`,
-	`a`,
-	`s`,
-	`d`,
-	`f`,
-	`g`,
-	`h`,
-	`j`,
-	`k`,
-	`l`,
-	`;`,
-	`'`,
-	`\``,
-	`\0`,
-	`\\`,
-	`z`,
-	`x`,
-	`c`,
-	`v`,
-	`b`,
-	`n`,
-	`m`,
-	`,`,
-	`.`,
-	`/`,
-	`\0`,
-	`\0`,
-	`\0`,
-	` `,
-]
-
-fn is_printable(c u8) bool {
-	return c >= 0x20 && c <= 0x7e
-}
-
-fn add_to_buf_char(_c u8, echo bool) {
-	mut c := _c
-
-	if c == `\r` && console_termios.c_iflag & termios.igncr != 0 {
-		return
-	}
-
-	if c == `\n` && console_termios.c_iflag & termios.icrnl == 0 {
-		c = `\r`
-	} else if c == `\r` && console_termios.c_iflag & termios.icrnl != 0 {
-		c = `\n`
-	} else if c == `\r` && console_termios.c_iflag & termios.inlcr == 0 {
-		c = `\n`
-	} else if c == `\n` && console_termios.c_iflag & termios.inlcr != 0 {
-		c = `\r`
-	}
-
-	if console_termios.c_lflag & termios.icanon != 0 {
-		match c {
-			`\n` {
-				if console_buffer_i == console_buffer_size {
-					return
-				}
-				console_buffer[console_buffer_i] = c
-				console_buffer_i++
-				if echo && console_termios.c_lflag & termios.echo != 0 {
-					print('${c:c}')
-				}
-				for i := u64(0); i < console_buffer_i; i++ {
-					if console_res.status & file.pollin == 0 {
-						console_res.status |= file.pollin
-						event.trigger(mut console_res.event, false)
-					}
-					if console_bigbuf_i == console_bigbuf_size {
-						return
-					}
-					console_bigbuf[console_bigbuf_i] = console_buffer[i]
-					console_bigbuf_i++
-				}
-				console_buffer_i = 0
-				return
-			}
-			`\b` {
-				if console_buffer_i == 0 {
-					return
-				}
-				console_buffer_i--
-				to_backspace := if console_buffer[console_buffer_i] >= 0x01
-					&& console_buffer[console_buffer_i] <= 0x1f {
-					2
-				} else {
-					1
-				}
-				console_buffer[console_buffer_i] = 0
-				if echo && console_termios.c_lflag & termios.echo != 0 {
-					for i := 0; i < to_backspace; i++ {
-						print('\b \b')
-					}
-				}
-				return
-			}
-			else {}
-		}
-
-		if console_buffer_i == console_buffer_size {
-			return
-		}
-		console_buffer[console_buffer_i] = c
-		console_buffer_i++
-	} else {
-		if console_res.status & file.pollin == 0 {
-			console_res.status |= file.pollin
-			event.trigger(mut console_res.event, false)
-		}
-		if console_bigbuf_i == console_bigbuf_size {
-			return
-		}
-		console_bigbuf[console_bigbuf_i] = c
-		console_bigbuf_i++
-	}
-
-	if echo && console_termios.c_lflag & termios.echo != 0 {
-		if is_printable(c) {
-			print('${c:c}')
-		} else if c >= 0x01 && c <= 0x1f {
-			print('^${c + 0x40:c}')
-		}
-	}
-}
-
-fn add_to_buf(ptr &u8, count u64, echo bool) {
-	console_read_lock.acquire()
-	defer {
-		console_read_lock.release()
-	}
-
-	for i := u64(0); i < count; i++ {
-		c := unsafe { ptr[i] }
-		if console_termios.c_lflag & termios.isig != 0 {
-			if c == console_termios.c_cc[termios.vintr] {
-				userland.sendsig(latest_thread, userland.sigint)
-			}
-		}
-		add_to_buf_char(c, echo)
-	}
-
-	event.trigger(mut console_event, false)
-}
-
-fn keyboard_handler() {
-	vect := idt.allocate_vector()
-
-	print('console: PS/2 keyboard vector is 0x${vect:x}\n')
-
-	apic.io_apic_set_irq_redirect(cpu_locals[0].lapic_id, vect, 1, true)
-
-	// Disable primary and secondary PS/2 ports
-	write_ps2(0x64, 0xad)
-	write_ps2(0x64, 0xa7)
-
-	// Read from port 0x60 to flush the PS/2 controller buffer
-	for kio.port_in[u8](0x64) & 1 != 0 {
-		kio.port_in[u8](0x60)
-	}
-
-	mut ps2_config := read_ps2_config()
-
-	// Enable keyboard interrupt and keyboard scancode translation
-	ps2_config |= (1 << 0) | (1 << 6)
-
-	// Enable mouse interrupt if any
-	if ps2_config & (1 << 5) != 0 {
-		ps2_config |= (1 << 1)
-	}
-
-	write_ps2_config(ps2_config)
-
-	// Enable keyboard port
-	write_ps2(0x64, 0xae)
-
-	// Enable mouse port if any
-	if ps2_config & (1 << 5) != 0 {
-		write_ps2(0x64, 0xa8)
-	}
-
-	console_convtab_numpad_numlock = {
-		u8(0x37): u8(`*`)
-		u8(0x4a): u8(`-`)
-		u8(0x4e): u8(`+`)
-		u8(0x47): u8(`7`)
-		u8(0x48): u8(`8`)
-		u8(0x49): u8(`9`)
-		u8(0x4b): u8(`4`)
-		u8(0x4c): u8(`5`)
-		u8(0x4d): u8(`6`)
-		u8(0x4f): u8(`1`)
-		u8(0x50): u8(`2`)
-		u8(0x51): u8(`3`)
-		u8(0x52): u8(`0`)
-		u8(0x53): u8(`.`)
-	}
-
-	for {
-		mut events := [&int_events[vect]]
-		event.await(mut events, true) or {}
-		unsafe { events.free() }
-		input_byte := read_ps2()
-
-		if input_byte == 0xe0 {
-			console_extra_scancodes = true
-			continue
-		}
-
-		if console_extra_scancodes == true {
-			console_extra_scancodes = false
-
-			match input_byte {
-				ctrl {
-					console_ctrl_active = true
-					continue
-				}
-				ctrl_rel {
-					console_ctrl_active = false
-					continue
-				}
-				0x1c {
-					add_to_buf(c'\n', 1, true)
-					continue
-				}
-				0x35 {
-					add_to_buf(c'/', 1, true)
-					continue
-				}
-				0x48 {
-					// Up arrow
-					if console_decckm == false {
-						add_to_buf(c'\e[A', 3, true)
-					} else {
-						add_to_buf(c'\eOA', 3, true)
-					}
-					continue
-				}
-				0x4b {
-					// Left arrow
-					if console_decckm == false {
-						add_to_buf(c'\e[D', 3, true)
-					} else {
-						add_to_buf(c'\eOD', 3, true)
-					}
-					continue
-				}
-				0x50 {
-					// Down arrow
-					if console_decckm == false {
-						add_to_buf(c'\e[B', 3, true)
-					} else {
-						add_to_buf(c'\eOB', 3, true)
-					}
-					continue
-				}
-				0x4d {
-					// Right arrow
-					if console_decckm == false {
-						add_to_buf(c'\e[C', 3, true)
-					} else {
-						add_to_buf(c'\eOC', 3, true)
-					}
-					continue
-				}
-				0x47 {
-					// Home
-					add_to_buf(c'\e[1~', 4, true)
-					continue
-				}
-				0x4f {
-					// End
-					add_to_buf(c'\e[4~', 4, true)
-					continue
-				}
-				0x49 {
-					// PG UP
-					add_to_buf(c'\e[5~', 4, true)
-					continue
-				}
-				0x51 {
-					// PG DOWN
-					add_to_buf(c'\e[6~', 4, true)
-					continue
-				}
-				0x53 {
-					// Delete
-					add_to_buf(c'\e[3~', 4, true)
-					continue
-				}
-				else {}
-			}
-		}
-
-		match input_byte {
-			numlock {
-				console_numlock_active = true
-				continue
-			}
-			left_alt {
-				console_alt_active = true
-				continue
-			}
-			left_alt_rel {
-				console_alt_active = false
-				continue
-			}
-			left_shift, right_shift {
-				console_shift_active = true
-				continue
-			}
-			left_shift_rel, right_shift_rel {
-				console_shift_active = false
-				continue
-			}
-			ctrl {
-				console_ctrl_active = true
-				continue
-			}
-			ctrl_rel {
-				console_ctrl_active = false
-				continue
-			}
-			capslock {
-				console_capslock_active = !console_capslock_active
-				continue
-			}
-			else {}
-		}
-
-		mut c := u8(0)
-
-		if input_byte in console_convtab_numpad_numlock {
-			c = console_convtab_numpad_numlock[input_byte]
-		} else {
-			if input_byte < max_scancode {
-				if console_capslock_active == false && console_shift_active == false {
-					c = convtab_nomod[input_byte]
-				}
-				if console_capslock_active == false && console_shift_active == true {
-					c = convtab_shift[input_byte]
-				}
-				if console_capslock_active == true && console_shift_active == false {
-					c = convtab_capslock[input_byte]
-				}
-				if console_capslock_active == true && console_shift_active == true {
-					c = convtab_shift_capslock[input_byte]
-				}
-			} else {
-				continue
-			}
-		}
-
-		if console_ctrl_active {
-			c = u8(C.toupper(c) - 0x40)
-		}
-
-		add_to_buf(&c, 1, true)
-	}
-}
-
-fn read_ps2() u8 {
-	for kio.port_in[u8](0x64) & 1 == 0 {}
-	return kio.port_in[u8](0x60)
-}
-
-fn write_ps2(port u16, value u8) {
-	for kio.port_in[u8](0x64) & 2 != 0 {}
-	kio.port_out[u8](port, value)
-}
-
-fn read_ps2_config() u8 {
-	write_ps2(0x64, 0x20)
-	return read_ps2()
-}
-
-fn write_ps2_config(value u8) {
-	write_ps2(0x64, 0x60)
-	write_ps2(0x60, value)
-}
-
-fn dec_private(esc_val_count u64, esc_values &u32, final u64) {
-	C.printf(c'dec private: ? %llu %c\n', unsafe { esc_values[0] }, final)
-	match unsafe { esc_values[0] } {
-		1 {
-			match final {
-				u64(`h`) {
-					console_decckm = true
-				}
-				u64(`l`) {
-					console_decckm = false
-				}
-				else {}
-			}
-		}
-		else {}
-	}
-}
-
-pub fn flanterm_callback(p voidptr, t u64, a u64, b u64, c u64) {
-	C.printf(c'Flanterm callback called\n')
-
-	match t {
-		10 {
-			dec_private(a, unsafe { &u32(b) }, c)
-		}
-		else {}
-	}
-}
-
-pub fn initialise() {
-	C.flanterm_set_callback(flanterm_ctx, voidptr(flanterm_callback))
-
-	console_res = &Console{}
-	console_res.stat.size = 0
-	console_res.stat.blocks = 0
-	console_res.stat.blksize = 512
-	console_res.stat.rdev = resource.create_dev_id()
-	console_res.stat.mode = 0o644 | stat.ifchr
-
-	// Initialise termios
-	console_res.termios.c_iflag = termios.brkint | termios.icrnl | termios.ixon | termios.imaxbel
-	console_res.termios.c_oflag = termios.opost | termios.onlcr
-	console_res.termios.c_cflag = termios.cs8 | termios.cread | termios.b38400
-	console_res.termios.c_lflag = termios.isig | termios.icanon | termios.iexten | termios.echo | termios.echoe | termios.echok | termios.echoctl | termios.echoke
-	console_res.termios.c_cc[termios.vintr] = termios.ctrl(`C`)
-	console_res.termios.c_cc[termios.vquit] = termios.ctrl(`\\`)
-	console_res.termios.c_cc[termios.verase] = 0x7f // termios.ctrl(`?`)
-	console_res.termios.c_cc[termios.vkill] = termios.ctrl(`U`)
-	console_res.termios.c_cc[termios.veof] = termios.ctrl(`D`)
-	console_res.termios.c_cc[termios.vstart] = termios.ctrl(`Q`)
-	console_res.termios.c_cc[termios.vstop] = termios.ctrl(`S`)
-	console_res.termios.c_cc[termios.vsusp] = termios.ctrl(`Z`)
-	console_res.termios.c_cc[termios.vreprint] = termios.ctrl(`R`)
-	console_res.termios.c_cc[termios.vwerase] = termios.ctrl(`W`)
-	console_res.termios.c_cc[termios.vlnext] = termios.ctrl(`V`)
-	console_res.termios.c_cc[termios.vdiscard] = termios.ctrl(`O`)
-	console_res.termios.c_cc[termios.vmin] = 1
-
-	console_termios = &console_res.termios
-
-	console_res.status |= file.pollout
-
-	fs.devtmpfs_add_device(console_res, 'console')
-
-	spawn keyboard_handler()
-}
-
-struct Console {
-pub mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	event    eventstruct.Event
-	status   int
-	can_mmap bool
-
-	termios termios.Termios
-}
-
-fn (mut this Console) mmap(page u64, flags int) voidptr {
-	return 0
-}
-
-fn (mut this Console) read(handle voidptr, void_buf voidptr, loc u64, count u64) ?i64 {
-	latest_thread = proc.current_thread()
-
-	mut buf := &u8(void_buf)
-
-	for console_read_lock.test_and_acquire() == false {
-		mut events := [&console_event]
-		event.await(mut events, true) or {
-			unsafe { events.free() }
-			errno.set(errno.eintr)
-			return none
-		}
-		unsafe { events.free() }
-	}
-
-	mut wait := true
-
-	for i := u64(0); i < count; {
-		if console_bigbuf_i != 0 {
-			unsafe {
-				buf[i] = console_bigbuf[0]
-			}
-			i++
-			console_bigbuf_i--
-			for j := u64(0); j < console_bigbuf_i; j++ {
-				console_bigbuf[j] = console_bigbuf[j + 1]
-			}
-			if console_bigbuf_i == 0 && console_res.status & file.pollin != 0 {
-				console_res.status &= ~file.pollin
-				event.trigger(mut console_res.event, false)
-			}
-			wait = false
-		} else {
-			if wait == true {
-				console_read_lock.release()
-				for {
-					mut events := [&console_event]
-					event.await(mut events, true) or {
-						unsafe { events.free() }
-						errno.set(errno.eintr)
-						return none
-					}
-					unsafe { events.free() }
-					if console_read_lock.test_and_acquire() == true {
-						break
-					}
-				}
-			} else {
-				console_read_lock.release()
-				return i64(i)
-			}
-		}
-	}
-
-	console_read_lock.release()
-	return i64(count)
-}
-
-fn (mut this Console) write(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	latest_thread = proc.current_thread()
-
-	copy := unsafe { malloc(count) }
-	defer {
-		unsafe { free(copy) }
-	}
-	unsafe { C.memcpy(copy, buf, count) }
-	term.print(copy, count)
-	return i64(count)
-}
-
-fn (mut this Console) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	latest_thread = proc.current_thread()
-
-	match request {
-		ioctl.tiocgwinsz {
-			mut w := unsafe { &ioctl.WinSize(argp) }
-			w.ws_row = u16(terminal_rows)
-			w.ws_col = u16(terminal_cols)
-			w.ws_xpixel = u16(framebuffer_width)
-			w.ws_ypixel = u16(framebuffer_height)
-			return 0
-		}
-		ioctl.tcgets {
-			mut t := unsafe { &termios.Termios(argp) }
-			unsafe {
-				*t = this.termios
-			}
-			return 0
-		}
-		// TODO: handle these differently
-		ioctl.tcsets, ioctl.tcsetsw, ioctl.tcsetsf {
-			mut t := unsafe { &termios.Termios(argp) }
-			unsafe {
-				this.termios = *t
-			}
-			return 0
-		}
-		else {
-			return resource.default_ioctl(handle, request, argp)
-		}
-	}
-}
-
-fn (mut this Console) unref(handle voidptr) ? {
-	katomic.dec(mut &this.refcount)
-}
-
-fn (mut this Console) link(handle voidptr) ? {
-	katomic.inc(mut &this.stat.nlink)
-}
-
-fn (mut this Console) unlink(handle voidptr) ? {
-	katomic.dec(mut &this.stat.nlink)
-}
-
-fn (mut this Console) grow(handle voidptr, new_size u64) ? {
-	return none
-}
diff --git a/kernel/modules/dev/fbdev/api/driver.v b/kernel/modules/dev/fbdev/api/driver.v
deleted file mode 100644
index 2e01857..0000000
--- a/kernel/modules/dev/fbdev/api/driver.v
+++ /dev/null
@@ -1,18 +0,0 @@
-module api
-
-pub struct FramebufferInfo {
-pub mut:
-	base     voidptr
-	size     u64
-	driver   &FramebufferDriver
-	variable FBVarScreenInfo
-	fixed    FBFixScreenInfo
-}
-
-pub struct FramebufferDriver {
-pub mut:
-	name string
-	init fn () = unsafe { nil }
-	// those below are filled in during registration, must be null.
-	register_device fn (FramebufferInfo) ? = unsafe { nil }
-}
diff --git a/kernel/modules/dev/fbdev/api/linux_uapi.v b/kernel/modules/dev/fbdev/api/linux_uapi.v
deleted file mode 100644
index 6c5f41c..0000000
--- a/kernel/modules/dev/fbdev/api/linux_uapi.v
+++ /dev/null
@@ -1,144 +0,0 @@
-module api
-
-// Field names and layout of those structures match Linux usermode API.
-// See the following file for details:
-// https://github.com/torvalds/linux/blob/master/include/uapi/linux/fb.h
-
-pub struct FBCMap {
-pub mut:
-	start  u32
-	len    u32
-	red    &u16
-	green  &u16
-	blue   &u16
-	transp &u16
-}
-
-pub struct FBBitfield {
-pub mut:
-	offset    u32
-	length    u32
-	msb_right u32
-}
-
-pub struct FBFixScreenInfo {
-pub mut:
-	id           [16]u8
-	smem_start   u64
-	smem_len     u32
-	@type        u32
-	type_aux     u32
-	visual       u32
-	xpanstep     u16
-	ypanstep     u16
-	ywrapstep    u16
-	line_length  u32
-	mmio_start   u64
-	mmio_len     u32
-	accel        u32
-	capabilities u16
-	reserved     [2]u16
-}
-
-pub struct FBVarScreenInfo {
-pub mut:
-	xres           u32
-	yres           u32
-	xres_virtual   u32
-	yres_virtual   u32
-	xoffset        u32
-	yoffset        u32
-	bits_per_pixel u32
-	grayscale      u32
-	red            FBBitfield
-	green          FBBitfield
-	blue           FBBitfield
-	transp         FBBitfield
-	nonstd         u32
-	activate       u32
-	height         u32
-	width          u32
-	accel_flags    u32
-	pixclock       u32
-	left_margin    u32
-	right_margin   u32
-	upper_margin   u32
-	lower_margin   u32
-	hsync_len      u32
-	vsync_len      u32
-	sync           u32
-	vmode          u32
-	rotate         u32
-	colorspace     u32
-	reserved       [4]u32
-}
-
-pub const fb_activate_now = 0
-
-pub const fb_activate_nxtopen = 1
-
-pub const fb_activate_test = 2
-
-pub const fb_activate_mask = 15
-
-pub const fb_activate_vbl = 16
-
-pub const fb_change_cmap_vbl = 32
-
-pub const fb_activate_all = 64
-
-pub const fb_activate_force = 128
-
-pub const fb_activate_inv_mode = 256
-
-pub const fb_activate_kd_test = 512
-
-pub const fb_type_packed_pixels = 0
-
-pub const fb_type_planes = 1
-
-pub const fb_type_interleaved_planes = 2
-
-pub const fb_type_text = 3
-
-pub const fb_type_vga_planes = 4
-
-pub const fb_type_fourcc = 5
-
-pub const fb_visual_mono01 = 0
-
-pub const fb_visual_mono10 = 1
-
-pub const fb_visual_truecolor = 2
-
-pub const fb_visual_pseudocolor = 3
-
-pub const fb_visual_directcolor = 4
-
-pub const fb_visual_static_pseudocolor = 5
-
-pub const fb_visual_fourcc = 6
-
-pub const fb_vmode_noninterlaced = 0
-
-pub const fb_vmode_interlaced = 1
-
-pub const fb_vmode_double = 2
-
-pub const fb_vmode_odd_fld_first = 4
-
-pub const fb_vmode_mask = 255
-
-pub const fb_vmode_ywrap = 256
-
-pub const fb_vmode_smooth_xpan = 512
-
-pub const fb_vmode_conupdate = 1024
-
-pub const fb_rotate_ur = 0
-
-pub const fb_rotate_cw = 1
-
-pub const fb_rotate_ud = 2
-
-pub const fb_rotate_ccw = 3
diff --git a/kernel/modules/dev/fbdev/fbdev.v b/kernel/modules/dev/fbdev/fbdev.v
deleted file mode 100644
index 2dac666..0000000
--- a/kernel/modules/dev/fbdev/fbdev.v
+++ /dev/null
@@ -1,189 +0,0 @@
-@[has_globals]
-module fbdev
-
-import ioctl
-import resource
-import fs
-import stat
-import klock
-import event.eventstruct
-import dev.fbdev.api
-import katomic
-import errno
-
-pub struct FramebufferNode {
-pub mut:
-	stat         stat.Stat
-	refcount     int
-	l            klock.Lock
-	event        eventstruct.Event
-	status       int
-	can_mmap     bool
-	node_lock    klock.Lock
-	initialized  bool
-	node_created bool
-	info         api.FramebufferInfo
-}
-
-const fbdev_max_device_count = 32
-
-__global (
-	fbdev_lock  klock.Lock
-	fbdev_nodes [fbdev_max_device_count]FramebufferNode
-)
-
-fn (mut this FramebufferNode) mmap(page u64, flags int) voidptr {
-	offset := page * page_size
-
-	if offset >= this.info.size {
-		return unsafe { nil }
-	}
-
-	unsafe {
-		return voidptr(u64(this.info.base) + offset - higher_half)
-	}
-}
-
-fn (mut this FramebufferNode) read(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	if count == 0 {
-		return i64(0)
-	}
-
-	vmem := &u8(this.info.base)
-	mut actual_count := count
-
-	if loc + count > this.info.size {
-		actual_count = count - ((loc + count) - this.info.size)
-	}
-
-	unsafe { C.memcpy(buf, &vmem[loc], actual_count) }
-
-	return i64(actual_count)
-}
-
-fn (mut this FramebufferNode) write(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	if count == 0 {
-		return i64(0)
-	}
-
-	vmem := &u8(this.info.base)
-	mut actual_count := count
-
-	if loc + count > this.info.size {
-		actual_count = count - ((loc + count) - this.info.size)
-	}
-
-	unsafe { C.memcpy(&vmem[loc], buf, actual_count) }
-
-	return i64(actual_count)
-}
-
-fn (mut this FramebufferNode) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	match request {
-		ioctl.fbioget_vscreeninfo {
-			unsafe { C.memcpy(argp, &this.info.variable, sizeof(api.FBVarScreenInfo)) }
-			return 0
-		}
-		ioctl.fbioput_vscreeninfo {
-			unsafe { C.memcpy(&this.info.variable, argp, sizeof(api.FBVarScreenInfo)) }
-			return 0
-		}
-		ioctl.fbioget_fscreeninfo {
-			unsafe { C.memcpy(argp, &this.info.fixed, sizeof(api.FBFixScreenInfo)) }
-			return 0
-		}
-		ioctl.fbioblank {
-			return 0
-		}
-		ioctl.fbiopan_display {
-			errno.set(errno.einval)
-			return none
-		}
-		ioctl.fbioputcmap {
-			errno.set(errno.einval)
-			return none
-		}
-		else {
-			panic('${request}')
-			return resource.default_ioctl(handle, request, argp)
-		}
-	}
-}
-
-fn (mut this FramebufferNode) unref(handle voidptr) ? {
-	katomic.dec(mut &this.refcount)
-}
-
-fn (mut this FramebufferNode) link(handle voidptr) ? {
-	katomic.inc(mut &this.stat.nlink)
-}
-
-fn (mut this FramebufferNode) unlink(handle voidptr) ? {
-	katomic.dec(mut &this.stat.nlink)
-}
-
-fn (mut this FramebufferNode) grow(handle voidptr, new_size u64) ? {
-}
-
-fn create_device_node(index u64) ? {
-	if index >= fbdev_max_device_count {
-		println('device index out of range')
-		return none
-	}
-
-	mut node := unsafe { &fbdev_nodes[index] }
-
-	if node.node_created {
-		return
-	}
-
-	node.stat.size = 0
-	node.stat.blocks = 0
-	node.stat.blksize = 4096
-	node.stat.rdev = resource.create_dev_id()
-	node.stat.mode = 0o666 | stat.ifchr
-	node.can_mmap = true
-	node.node_created = true
-
-	fs.devtmpfs_add_device(node, 'fb${index}')
-	println('fbdev: created device node /dev/fb${index}')
-}
-
-pub fn register_device(info api.FramebufferInfo) ? {
-	mut index := u64(0)
-
-	fbdev_lock.acquire()
-	defer {
-		fbdev_lock.release()
-	}
-
-	for index < fbdev_max_device_count {
-		if fbdev_nodes[index].initialized {
-			index += 1
-			continue
-		}
-
-		fbdev_nodes[index].info = info
-		fbdev_nodes[index].initialized = true
-		break
-	}
-
-	if index >= fbdev_max_device_count {
-		println('too many registered devices')
-		return none
-	}
-
-	println('fbdev: registered new framebuffer device (using driver ${info.driver.name} and mode ${info.variable.xres}x${info.variable.yres}x${info.variable.bits_per_pixel})')
-
-	return create_device_node(index)
-}
-
-pub fn register_driver(driver &api.FramebufferDriver) {
-	unsafe {
-		driver.register_device = register_device
-		driver.init()
-	}
-}
-
-pub fn initialise() {
-}
diff --git a/kernel/modules/dev/fbdev/simple/simple.v b/kernel/modules/dev/fbdev/simple/simple.v
deleted file mode 100644
index b542a0f..0000000
--- a/kernel/modules/dev/fbdev/simple/simple.v
+++ /dev/null
@@ -1,115 +0,0 @@
-@[has_globals]
-module simple
-
-import dev.fbdev.api
-
-pub struct SimpleFBConfig {
-pub mut:
-	physical_address u64
-	width            u32
-	height           u32
-	stride           u32
-	bits_per_pixel   u32
-	red              api.FBBitfield
-	green            api.FBBitfield
-	blue             api.FBBitfield
-	transp           api.FBBitfield
-}
-
-__global (
-	simplefb_driver      = api.FramebufferDriver{
-		name:            'simplefb'
-		init:            simple_init
-		register_device: unsafe { nil }
-	}
-	simplefb_initialized = false
-	simplefb_pending_cnt = u32(0)
-	simplefb_pending     [8]SimpleFBConfig
-)
-
-pub fn get_driver() &api.FramebufferDriver {
-	return &simplefb_driver
-}
-
-fn simple_init() {
-	for i := 0; i < simplefb_pending_cnt; i++ {
-		do_register(&simplefb_pending[i])
-	}
-
-	simplefb_initialized = true
-	simplefb_pending_cnt = 0
-
-	println('simplefb: initialized')
-}
-
-fn do_register(config &SimpleFBConfig) {
-	info := api.FramebufferInfo{
-		base:     voidptr(config.physical_address)
-		size:     config.stride * config.height
-		driver:   &simplefb_driver
-		fixed:    api.FBFixScreenInfo{
-			id:          [16]u8{}
-			smem_start:  0
-			smem_len:    config.stride * config.height
-			@type:       api.fb_type_packed_pixels
-			type_aux:    0
-			visual:      api.fb_visual_truecolor
-			xpanstep:    0
-			ypanstep:    0
-			ywrapstep:   0
-			line_length: config.stride
-			mmio_start:  0
-			mmio_len:    0
-			accel:       0
-		}
-		variable: api.FBVarScreenInfo{
-			xres:           config.width
-			yres:           config.height
-			xres_virtual:   config.width
-			yres_virtual:   config.height
-			xoffset:        0
-			yoffset:        0
-			bits_per_pixel: config.bits_per_pixel
-			grayscale:      0
-			red:            config.red
-			green:          config.green
-			blue:           config.blue
-			transp:         config.transp
-			nonstd:         0
-			activate:       api.fb_activate_now
-			height:         0
-			width:          0
-			accel_flags:    0
-			pixclock:       0
-			left_margin:    0
-			right_margin:   0
-			upper_margin:   0
-			lower_margin:   0
-			hsync_len:      0
-			vsync_len:      0
-			sync:           0
-			vmode:          api.fb_vmode_noninterlaced
-			rotate:         0
-			reserved:       [4]u32{}
-		}
-	}
-
-	simplefb_driver.register_device(info) or {
-		print('simplefb: failed to register framebuffer device: ${err.msg()}')
-	}
-}
-
-pub fn register_simple_framebuffer(config SimpleFBConfig) {
-	if !simplefb_initialized {
-		if simplefb_pending_cnt >= 8 {
-			print('simplefb: too many pending framebuffers')
-			return
-		}
-
-		simplefb_pending[simplefb_pending_cnt] = config
-		simplefb_pending_cnt++
-		return
-	}
-
-	do_register(&config)
-}
diff --git a/kernel/modules/dev/hda/hda.v b/kernel/modules/dev/hda/hda.v
deleted file mode 100644
index 9775c88..0000000
--- a/kernel/modules/dev/hda/hda.v
+++ /dev/null
@@ -1,1180 +0,0 @@
-@[has_globals]
-module hda
-
-import pci
-import memory
-import time.sys
-import dev.hda.oss
-import x86.idt
-import event
-
-const hda_class = 0x4
-const hda_subclass = 0x3
-
-const tgl_sst_vendor = 0x8086
-const tgl_sst_device = 0xa0c8
-
-const gcap_ok64 = 1 << 0
-const gcap_iss_mask = u8(0b1111)
-const gcap_iss_shift = 8
-const gcap_oss_mask = u8(0b1111)
-const gcap_oss_shift = 12
-
-const gctl_crst = 1 << 0
-
-const intctl_cie = u32(1 << 30)
-const intctl_gie = u32(1 << 31)
-
-const intsts_sie_mask = u32((1 << 30) - 1)
-
-const corbsize_szcap_mask = u8(0b1111)
-const corbsize_szcap_shift = 4
-const corbsize_size_mask = u8(0b1111)
-const corbsize_size_shift = 0
-
-const corbwp_wp_mask = u16(0xFF)
-const corbwp_wp_shift = 0
-
-const corbctl_run = 1 << 1
-
-const dplbase_dpbe = 1 << 0
-
-const sdctl0_srst = u8(1 << 0)
-const sdctl0_run = u8(1 << 1)
-const sdctl0_ioce = u8(1 << 2)
-
-const sdctl2_strm_mask = u8(0b1111)
-const sdctl2_strm_shift = 4
-
-const sdlvi_lvi_mask = u16(0xFF)
-const sdlvi_lvi_shift = 0
-
-const cmd_set_converter_format = 0x2
-const cmd_set_amp_gain_mute = 0x3
-const cmd_set_con_select = 0x701
-const cmd_set_power_state = 0x705
-const cmd_set_converter_control = 0x706
-const cmd_set_pin_control = 0x707
-const cmd_set_eapd_enable = 0x70C
-const cmd_get_param = 0xF00
-const cmd_get_con_list = 0xF02
-const cmd_get_config_default = 0xF1C
-
-const pcm_sample_rate_base_48khz = 0
-const pcm_sample_rate_base_441khz = 1
-const pcm_sample_rate_mult_2 = 0b1
-const pcm_sample_rate_mult_3 = 0b10
-const pcm_sample_rate_mult_4 = 0b11
-const pcm_sample_rate_div_2 = 0b1
-const pcm_sample_rate_div_3 = 0b10
-const pcm_sample_rate_div_4 = 0b11
-const pcm_sample_rate_div_5 = 0b100
-const pcm_sample_rate_div_6 = 0b101
-const pcm_sample_rate_div_7 = 0b110
-const pcm_sample_rate_div_8 = 0b111
-
-const pcm_bits_16 = 0b1
-const pcm_bits_20 = 0b10
-const pcm_bits_24 = 0b11
-const pcm_bits_32 = 0b100
-
-const param_node_count = 0x4
-const param_func_group_type = 0x5
-const param_audio_caps = 0x9
-const param_pin_caps = 0xC
-const param_in_amp_caps = 0xD
-const param_con_list_len = 0xE
-const param_out_amp_caps = 0x12
-
-const func_group_type_audio = 0x1
-
-const power_state_d0 = 0
-
-const widget_type_audio_out = 0x0
-const widget_type_audio_in = 0x1
-const widget_type_audio_mixer = 0x2
-const widget_type_audio_selector = 0x3
-const widget_type_pin_complex = 0x4
-const widget_type_power_widget = 0x5
-const widget_type_volume_knob = 0x6
-const widget_type_beep_generator = 0x7
-
-@[packed]
-struct HDARegisters {
-pub mut:
-	gcap       u16   // 0x0
-	vmin       u8    // 0x2
-	vmaj       u8    // 0x3
-	outpay     u16   // 0x4
-	inpay      u16   // 0x6
-	gctl       u32   // 0x8
-	wakeen     u16   // 0xC
-	statests   u16   // 0xE
-	gsts       u16   // 0x10
-	reserved0  [6]u8 // 0x12
-	outstrmpay u16   // 0x18
-	instrmpay  u16   // 0x1A
-	reserved1  u32   // 0x1C
-	intctl     u32   // 0x20
-	intsts     u32   // 0x24
-	reserved2  u64   // 0x28
-	walclk     u32   // 0x30
-	reserved3  u32   // 0x34
-	ssync      u32   // 0x38
-	reserved4  u32   // 0x3C
-	corblbase  u32   // 0x40
-	corbubase  u32   // 0x44
-	corbwp     u16   // 0x48
-	corbrp     u16   // 0x4A
-	corbctl    u8    // 0x4C
-	corbsts    u8    // 0x4D
-	corbsize   u8    // 0x4E
-	reserved5  u8    // 0x4F
-	rirblbase  u32   // 0x50
-	rirbubase  u32   // 0x54
-	rirbwp     u16   // 0x58
-	rintcnt    u16   // 0x5A
-	rirbctl    u8    // 0x5C
-	rirbsts    u8    // 0x5D
-	rirbsize   u8    // 0x5E
-	reserved6  u8    // 0x5F
-	icoi       u32   // 0x60
-	icii       u32   // 0x64
-	icis       u16   // 0x68
-	reserved7  [6]u8
-	dplbase    u32
-	dpubase    u32
-}
-
-@[packed]
-struct HDAStreamRegisters {
-pub mut:
-	ctl0      u8    // 0x0
-	ctl1      u8    // 0x1
-	ctl2      u8    // 0x2
-	sts       u8    // 0x3
-	lpib      u32   // 0x4
-	cbl       u32   // 0x8
-	lvi       u16   // 0xC
-	reserved0 [2]u8 // 0xE
-	fifos     u16   // 0x10
-	fmt       u16   // 0x12 0x13
-	reserved1 u32   // 0x14
-	bdpl      u32   // 0x18
-	bdpu      u32   // 0x1C
-}
-
-struct HDAVerbDescriptor {
-pub mut:
-	value u32
-}
-
-pub fn (mut verb HDAVerbDescriptor) set_payload(payload u32) {
-	verb.value |= payload & 0xFFFFF
-}
-
-pub fn (mut verb HDAVerbDescriptor) set_nid(nid u8) {
-	verb.value |= u32(nid) << 20
-}
-
-pub fn (mut verb HDAVerbDescriptor) set_cid(cid u8) {
-	verb.value |= u32(cid) << 28
-}
-
-struct HDAResponseDescriptor {
-pub mut:
-	resp    u32
-	resp_ex u32
-}
-
-pub fn (verb HDAResponseDescriptor) get_codec() u8 {
-	return u8(verb.resp_ex & 0b1111)
-}
-
-pub fn (verb HDAResponseDescriptor) is_unsol() bool {
-	return (verb.resp_ex >> 4) & 1 != 0
-}
-
-struct PCMFormat {
-pub mut:
-	value u16
-}
-
-fn (mut f PCMFormat) set_sample_rate(rate u32) {
-	mut base := u8(0)
-	mut mult := u8(0)
-	mut div := u8(0)
-
-	if rate <= 5513 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_8
-	} else if rate <= 6000 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_8
-	} else if rate <= 6300 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_7
-	} else if rate <= 6857 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_7
-	} else if rate <= 7350 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_6
-	} else if rate <= 8000 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_6
-	} else if rate <= 8820 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_5
-	} else if rate <= 9600 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_5
-	} else if rate <= 11025 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_4
-	} else if rate <= 12000 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_4
-	} else if rate <= 12600 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_7
-		mult = pcm_sample_rate_mult_2
-	} else if rate <= 13714 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_7
-		mult = pcm_sample_rate_mult_2
-	} else if rate <= 14700 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_3
-	} else if rate <= 16000 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_3
-	} else if rate <= 16538 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_8
-		mult = pcm_sample_rate_mult_3
-	} else if rate <= 17640 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_5
-		mult = pcm_sample_rate_mult_2
-	} else if rate <= 18000 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_8
-		mult = pcm_sample_rate_mult_3
-	} else if rate <= 18900 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_7
-		mult = pcm_sample_rate_mult_3
-	} else if rate <= 19200 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_5
-		mult = pcm_sample_rate_mult_2
-	} else if rate <= 20571 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_7
-		mult = pcm_sample_rate_mult_3
-	} else if rate <= 22050 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_2
-	} else if rate <= 24000 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_2
-	} else if rate <= 25200 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_7
-		mult = pcm_sample_rate_mult_4
-	} else if rate <= 26460 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_5
-		mult = pcm_sample_rate_mult_3
-	} else if rate <= 27429 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_7
-		mult = pcm_sample_rate_mult_4
-	} else if rate <= 28800 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_5
-		mult = pcm_sample_rate_mult_3
-	} else if rate <= 29400 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_3
-		mult = pcm_sample_rate_mult_2
-	} else if rate <= 32000 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_3
-		mult = pcm_sample_rate_mult_2
-	} else if rate <= 33075 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_4
-		mult = pcm_sample_rate_mult_3
-	} else if rate <= 35280 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_5
-		mult = pcm_sample_rate_mult_4
-	} else if rate <= 36000 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_4
-		mult = pcm_sample_rate_mult_3
-	} else if rate <= 38400 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_5
-		mult = pcm_sample_rate_mult_4
-	} else if rate <= 44100 {
-		base = pcm_sample_rate_base_441khz
-	} else if rate <= 48000 {
-		base = pcm_sample_rate_base_48khz
-	} else if rate <= 58800 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_3
-		mult = pcm_sample_rate_mult_4
-	} else if rate <= 64000 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_3
-		mult = pcm_sample_rate_mult_4
-	} else if rate <= 66150 {
-		base = pcm_sample_rate_base_441khz
-		div = pcm_sample_rate_div_2
-		mult = pcm_sample_rate_mult_3
-	} else if rate <= 72000 {
-		base = pcm_sample_rate_base_48khz
-		div = pcm_sample_rate_div_2
-		mult = pcm_sample_rate_mult_3
-	} else if rate <= 88200 {
-		base = pcm_sample_rate_base_441khz
-		mult = pcm_sample_rate_mult_2
-	} else if rate <= 96000 {
-		base = pcm_sample_rate_base_48khz
-		mult = pcm_sample_rate_mult_2
-	} else if rate <= 132300 {
-		base = pcm_sample_rate_base_441khz
-		mult = pcm_sample_rate_mult_3
-	} else if rate <= 144000 {
-		base = pcm_sample_rate_base_48khz
-		mult = pcm_sample_rate_mult_3
-	} else if rate <= 176400 {
-		base = pcm_sample_rate_base_441khz
-		mult = pcm_sample_rate_mult_4
-	} else {
-		base = pcm_sample_rate_base_48khz
-		mult = pcm_sample_rate_mult_4
-	}
-
-	f.value &= ~(1 << 14)
-	f.value |= u16(base) << 14
-	f.value &= ~(0b111 << 11)
-	f.value |= u16(mult) << 11
-	f.value &= ~(0b111 << 8)
-	f.value |= u16(div) << 8
-}
-
-fn (mut f PCMFormat) set_bits_per_sample(bits u8) bool {
-	mut value := u8(0)
-	if bits == 8 {
-		value = 0
-	} else if bits == 16 {
-		value = 0b1
-	} else if bits == 20 {
-		value = 0b10
-	} else if bits == 24 {
-		value = 0b11
-	} else if bits == 32 {
-		value = 0b100
-	} else {
-		return false
-	}
-
-	f.value &= ~(0b111 << 4)
-	f.value |= value << 4
-	return true
-}
-
-fn (mut f PCMFormat) set_num_channels(channels u8) bool {
-	if channels == 0 || channels > 16 {
-		return false
-	}
-
-	f.value &= ~0b1111
-	f.value |= channels - 1
-	return true
-}
-
-struct HDAWidget {
-pub mut:
-	codec          &HDACodec
-	connections    []u8
-	in_amp_caps    u32
-	out_amp_caps   u32
-	pin_caps       u32
-	default_config u32
-	nid            u8
-	widget_type    u8
-}
-
-struct HDASignalPath {
-pub mut:
-	widgets []&HDAWidget
-}
-
-pub struct HDACodec {
-pub mut:
-	controller                   &HDAController
-	widgets                      []HDAWidget
-	output_paths                 []HDASignalPath
-	non_overlapping_output_paths []&HDASignalPath
-	audio_outputs                []u8
-	audio_inputs                 []u8
-	audio_mixers                 []u8
-	audio_selectors              []u8
-	pin_complexes                []u8
-	power_widgets                []u8
-	volume_knobs                 []u8
-	beep_generators              []u8
-	cid                          u8
-	index                        int
-}
-
-fn (c HDACodec) get_output_stream() &oss.OssAudioStream {
-	return &c.controller.out_streams[0]
-}
-
-fn (c HDACodec) refine_fmt(fmt u8) u8 {
-	match fmt {
-		oss.afmt_u8 {
-			return oss.afmt_u8
-		}
-		oss.afmt_s16_le {
-			return oss.afmt_u16_le
-		}
-		oss.afmt_s8 {
-			return oss.afmt_u8
-		}
-		oss.afmt_u16_le {
-			return oss.afmt_u16_le
-		}
-		oss.afmt_s32_le {
-			return oss.afmt_u16_le
-		}
-		else {
-			return oss.afmt_u16_le
-		}
-	}
-}
-
-fn (c HDACodec) refine_channels(channels u8) u8 {
-	if channels <= 16 {
-		return channels
-	} else {
-		return 16
-	}
-}
-
-fn (mut c HDACodec) set_converter_format(nid u8, format PCMFormat) {
-	index := c.controller.submit_verb_long(c.cid, nid, cmd_set_converter_format, format.value)
-	c.controller.wait_for_verb(index)
-}
-
-fn (mut c HDACodec) set_amp_gain_mute(nid u8, data u16) {
-	index := c.controller.submit_verb_long(c.cid, nid, cmd_set_amp_gain_mute, data)
-	c.controller.wait_for_verb(index)
-}
-
-fn (mut c HDACodec) set_selected_con(nid u8, con_index u8) {
-	index := c.controller.submit_verb(c.cid, nid, cmd_set_con_select, con_index)
-	c.controller.wait_for_verb(index)
-}
-
-fn (mut c HDACodec) set_power_state(nid u8, state u8) {
-	index := c.controller.submit_verb(c.cid, nid, cmd_set_power_state, state)
-	c.controller.wait_for_verb(index)
-}
-
-fn (mut c HDACodec) set_converter_control(nid u8, channel u8, stream u8) {
-	index := c.controller.submit_verb(c.cid, nid, cmd_set_converter_control, channel | (stream << 4))
-	c.controller.wait_for_verb(index)
-}
-
-fn (mut c HDACodec) set_pin_control(nid u8, data u8) {
-	index := c.controller.submit_verb(c.cid, nid, cmd_set_pin_control, data)
-	c.controller.wait_for_verb(index)
-}
-
-fn (mut c HDACodec) set_eapd_enable(nid u8, data u8) {
-	index := c.controller.submit_verb(c.cid, nid, cmd_set_eapd_enable, data)
-	c.controller.wait_for_verb(index)
-}
-
-fn (mut c HDACodec) get_parameter(nid u8, param u8) u32 {
-	index := c.controller.submit_verb(c.cid, nid, cmd_get_param, param)
-	return c.controller.wait_for_verb(index).resp
-}
-
-fn (mut c HDACodec) get_con_list(nid u8, offset u8) u32 {
-	index := c.controller.submit_verb(c.cid, nid, cmd_get_con_list, offset)
-	return c.controller.wait_for_verb(index).resp
-}
-
-fn (mut c HDACodec) get_config_default(nid u8) u32 {
-	index := c.controller.submit_verb(c.cid, nid, cmd_get_config_default, 0)
-	return c.controller.wait_for_verb(index).resp
-}
-
-struct DiscoverStackEntry {
-pub mut:
-	widget          &HDAWidget
-	con_index       u8
-	con_range_index u8
-	con_range_end   u8
-}
-
-fn (mut c HDACodec) discover_non_overlapping_paths() {
-	for path_i in 0 .. c.output_paths.len {
-		path := &c.output_paths[path_i]
-
-		mut overlapping := false
-
-		for widget in path.widgets {
-			for path2_i in 0 .. c.output_paths.len {
-				if path2_i == path_i {
-					continue
-				}
-
-				path2 := &c.output_paths[path2_i]
-				for widget2 in path2.widgets {
-					if voidptr(widget2) == voidptr(widget) {
-						overlapping = true
-						break
-					}
-				}
-
-				if overlapping {
-					break
-				}
-			}
-
-			if overlapping {
-				break
-			}
-		}
-
-		if !overlapping {
-			c.non_overlapping_output_paths << path
-		}
-	}
-}
-
-fn (mut c HDACodec) discover_output_paths() {
-	mut stack := []DiscoverStackEntry{}
-
-	for pin_nid in c.pin_complexes {
-		pin := &c.widgets[pin_nid]
-		// check if output capable
-		if (pin.pin_caps & (1 << 4)) == 0 {
-			continue
-		}
-
-		connectivity := pin.default_config >> 30
-		// no physical connection
-		if connectivity == 1 {
-			continue
-		}
-
-		stack << DiscoverStackEntry{
-			widget:          unsafe { pin }
-			con_index:       0
-			con_range_index: 0xFF
-			con_range_end:   0
-		}
-
-		for {
-			if stack.len == 0 {
-				break
-			}
-
-			mut cur_entry := unsafe {
-				&stack[stack.len - 1]
-			}
-			cur_widget := cur_entry.widget
-			if cur_entry.con_index == cur_widget.connections.len {
-				stack.pop()
-				continue
-			}
-
-			if cur_entry.con_range_index > cur_entry.con_range_end {
-				cur_entry.con_range_index = cur_widget.connections[cur_entry.con_index]
-				cur_entry.con_index++
-				assert cur_entry.con_range_index >> 7 == 0, 'invalid connection entry'
-
-				if cur_entry.con_index < cur_widget.connections.len
-					&& (cur_widget.connections[cur_entry.con_index] & (1 << 7)) != 0 {
-					cur_entry.con_range_end = cur_widget.connections[cur_entry.con_index] & 0x7F
-					cur_entry.con_index++
-				} else {
-					cur_entry.con_range_end = cur_entry.con_range_index
-				}
-			}
-
-			nid := cur_entry.con_range_index
-			cur_entry.con_range_index++
-
-			next_widget := &c.widgets[nid]
-			if next_widget.widget_type == widget_type_audio_out {
-				mut path := HDASignalPath{}
-
-				for widget in stack {
-					path.widgets << widget.widget
-				}
-				path.widgets << next_widget
-
-				c.output_paths << path
-			} else {
-				mut is_circular := false
-				for widget in stack {
-					if widget.widget == next_widget {
-						is_circular = true
-						break
-					}
-				}
-
-				if is_circular || stack.len >= 20 {
-					continue
-				}
-
-				stack << DiscoverStackEntry{
-					widget:          unsafe { next_widget }
-					con_index:       0
-					con_range_index: 0xFF
-					con_range_end:   0
-				}
-			}
-		}
-	}
-}
-
-fn (mut c HDACodec) setup_all_output_paths(sample_rate u32, bits u8, channels u8) {
-	stream := &c.controller.out_streams[0]
-
-	for path in c.non_overlapping_output_paths {
-		for i in 0 .. path.widgets.len {
-			widget := path.widgets[i]
-
-			if i != path.widgets.len - 1 {
-				next_widget := path.widgets[i + 1]
-
-				mut index := u8(0)
-				for j in 0 .. widget.connections.len {
-					connection := widget.connections[j]
-
-					if connection & (1 << 7) != 0 {
-						start := widget.connections[j - 1]
-						end := connection & 0x7F
-
-						if next_widget.nid >= start && next_widget.nid <= end {
-							index += next_widget.nid - start
-							break
-						}
-						index += end - start
-					} else {
-						if next_widget.nid == connection {
-							break
-						}
-						index++
-					}
-				}
-
-				c.set_selected_con(widget.nid, index)
-			}
-
-			if widget.widget_type == widget_type_pin_complex {
-				if widget.pin_caps & (1 << 16) != 0 {
-					c.set_eapd_enable(widget.nid, 1 << 1)
-				}
-
-				step := widget.out_amp_caps & 0x7F
-
-				// set output amp, set left amp, set right amp and gain
-				amp_data := u16(1 << 15 | 1 << 13 | 1 << 12 | step)
-				c.set_amp_gain_mute(widget.nid, amp_data)
-				c.set_power_state(widget.nid, power_state_d0)
-				// headphone amp, out enable
-				pin_control := u8(1 << 7 | 1 << 6)
-				c.set_pin_control(widget.nid, pin_control)
-			} else if widget.widget_type == widget_type_audio_mixer {
-				step := widget.out_amp_caps & 0x7F
-
-				// set output amp, set left amp, set right amp and gain
-				amp_data := u16(1 << 15 | 1 << 13 | 1 << 12 | step)
-				c.set_amp_gain_mute(widget.nid, amp_data)
-				c.set_power_state(widget.nid, power_state_d0)
-			} else if widget.widget_type == widget_type_audio_out {
-				max_val := widget.out_amp_caps & 0x7F
-
-				mut one_percentage := max_val / 100
-				if one_percentage == 0 {
-					one_percentage = 1
-				}
-				mut value := one_percentage * stream.cur_volume
-				if value > max_val {
-					value = max_val
-				}
-
-				// set output amp, set left amp, set right amp and gain
-				amp_data := u16(1 << 15 | 1 << 13 | 1 << 12 | value)
-				c.set_amp_gain_mute(widget.nid, amp_data)
-				c.set_power_state(widget.nid, power_state_d0)
-
-				// channel 0, stream 1
-				c.set_converter_control(widget.nid, 0, 1)
-
-				mut fmt := PCMFormat{}
-				fmt.set_sample_rate(sample_rate)
-				fmt.set_bits_per_sample(bits)
-				fmt.set_num_channels(channels)
-
-				c.set_converter_format(widget.nid, fmt)
-			}
-		}
-	}
-}
-
-pub fn (mut c HDACodec) initialize() {
-	num_func_groups_resp := c.get_parameter(0, param_node_count)
-	num_func_groups := u8(num_func_groups_resp & 0xFF)
-	func_groups_start_nid := u8((num_func_groups_resp >> 16) & 0xFF)
-
-	for func_group_nid := func_groups_start_nid; func_group_nid < func_groups_start_nid +
-		num_func_groups; func_group_nid++ {
-		func_group_type_resp := c.get_parameter(func_group_nid, param_func_group_type)
-		func_group_type := u8(func_group_type_resp & 0xFF)
-		if func_group_type != func_group_type_audio {
-			continue
-		}
-
-		c.set_power_state(func_group_nid, power_state_d0)
-
-		print('hda: audio function group at ${c.cid:x}:${func_group_nid:x}\n')
-
-		num_widgets_resp := c.get_parameter(func_group_nid, param_node_count)
-		num_widgets := u8(num_widgets_resp & 0xFF)
-		widgets_start_nid := u8((num_widgets_resp >> 16) & 0xFF)
-
-		print('hda: found ${num_widgets} widgets\n')
-
-		for widget_nid := widgets_start_nid; widget_nid < widgets_start_nid + num_widgets; widget_nid++ {
-			audio_caps := c.get_parameter(widget_nid, param_audio_caps)
-			in_amp_caps := c.get_parameter(widget_nid, param_in_amp_caps)
-			out_amp_caps := c.get_parameter(widget_nid, param_out_amp_caps)
-			pin_caps := c.get_parameter(widget_nid, param_pin_caps)
-			con_list_len := u8(c.get_parameter(widget_nid, param_con_list_len))
-			default_config := c.get_config_default(widget_nid)
-
-			widget_type := u8((audio_caps >> 20) & 0b1111)
-
-			assert (con_list_len & 1 << 7) == 0, "long form connection lists aren't supported"
-
-			mut widget := unsafe {
-				HDAWidget{
-					codec:          c
-					in_amp_caps:    in_amp_caps
-					out_amp_caps:   out_amp_caps
-					pin_caps:       pin_caps
-					default_config: default_config
-					nid:            widget_nid
-					widget_type:    widget_type
-				}
-			}
-
-			for i := u8(0); i < con_list_len; i += 4 {
-				resp := c.get_con_list(widget_nid, i)
-				count := if con_list_len - i < 4 {
-					con_list_len - i
-				} else {
-					4
-				}
-				for j := 0; j < count; j++ {
-					nid := u8((resp >> (j * 8)) & 0xFF)
-					widget.connections << nid
-				}
-			}
-
-			if widget_nid >= c.widgets.len {
-				unsafe {
-					if c.widgets.len != -1 {
-						c.widgets.grow_len(widget_nid - c.widgets.len + 1)
-					} else {
-						c.widgets.grow_len(widget_nid + 1)
-					}
-				}
-			}
-			c.widgets[widget_nid] = widget
-
-			match widget_type {
-				widget_type_audio_out {
-					c.audio_outputs << widget_nid
-				}
-				widget_type_audio_in {
-					c.audio_inputs << widget_nid
-				}
-				widget_type_audio_mixer {
-					c.audio_mixers << widget_nid
-				}
-				widget_type_audio_selector {
-					c.audio_selectors << widget_nid
-				}
-				widget_type_pin_complex {
-					c.pin_complexes << widget_nid
-				}
-				widget_type_power_widget {
-					c.power_widgets << widget_nid
-				}
-				widget_type_volume_knob {
-					c.volume_knobs << widget_nid
-				}
-				widget_type_beep_generator {
-					c.beep_generators << widget_nid
-				}
-				else {}
-			}
-		}
-	}
-
-	c.discover_output_paths()
-	c.discover_non_overlapping_paths()
-
-	mut stream := c.get_output_stream()
-	stream.change_volume(50)
-
-	print('hda: found ${c.audio_outputs.len} audio outputs and ${c.pin_complexes.len} pin complexes\n')
-	print('hda: found ${c.output_paths.len} output paths (${c.non_overlapping_output_paths.len} non-overlapping)\n')
-
-	oss.create_device(c)
-}
-
-struct HDAController {
-pub mut:
-	volatile regs             &HDARegisters
-	in_streams       [16]HDAStream
-	out_streams      [16]HDAStream
-	pci_bar          pci.PCIBar
-	corb             &HDAVerbDescriptor
-	rirb             &HDAResponseDescriptor
-	dma_pos          &u32
-	codecs           []&HDACodec
-	index            i32
-	corb_size        u16
-	rirb_size        u16
-	in_stream_count  u8
-	out_stream_count u8
-	irq_vect         u8
-}
-
-__global (
-	hda_controller_list []&HDAController
-)
-
-fn (mut c HDAController) submit_verb(cid u8, nid u8, cmd u16, data u8) u8 {
-	mut corbwp := c.regs.corbwp
-	index := u8((corbwp >> corbwp_wp_shift) & corbwp_wp_mask) + 1
-
-	mut verb := HDAVerbDescriptor{}
-	verb.set_cid(cid)
-	verb.set_nid(nid)
-	verb.set_payload(u32(cmd) << 8 | data)
-
-	unsafe {
-		c.corb[index] = verb
-	}
-	corbwp &= ~(corbwp_wp_mask << corbwp_wp_shift)
-	corbwp |= index << corbwp_wp_shift
-	c.regs.corbwp = corbwp
-
-	return index
-}
-
-fn (mut c HDAController) submit_verb_long(cid u8, nid u8, cmd u8, data u16) u8 {
-	mut corbwp := c.regs.corbwp
-	index := u8((corbwp >> corbwp_wp_shift) & corbwp_wp_mask) + 1
-
-	mut verb := HDAVerbDescriptor{}
-	verb.set_cid(cid)
-	verb.set_nid(nid)
-	verb.set_payload(u32(cmd) << 16 | data)
-
-	unsafe {
-		c.corb[index] = verb
-	}
-	corbwp &= ~(corbwp_wp_mask << corbwp_wp_shift)
-	corbwp |= index << corbwp_wp_shift
-	c.regs.corbwp = corbwp
-
-	return index
-}
-
-fn (mut c HDAController) wait_for_verb(index u8) HDAResponseDescriptor {
-	for {
-		cur_index := (c.regs.corbwp >> corbwp_wp_shift) & corbwp_wp_mask
-		if cur_index == index {
-			break
-		}
-	}
-
-	unsafe {
-		return c.rirb[index]
-	}
-}
-
-fn irq_handler(mut c HDAController) {
-	print('hda: using irq ${c.irq_vect:x}\n')
-
-	for {
-		mut events := [&int_events[c.irq_vect]]
-		event.await(mut events, true) or {}
-
-		intsts := c.regs.intsts
-		if intsts & intsts_sie_mask == 0 {
-			continue
-		}
-
-		streams := intsts & intsts_sie_mask
-		for i in 0 .. c.in_stream_count + c.out_stream_count {
-			if streams & (1 << i) != 0 {
-				if i < c.in_stream_count {
-					c.in_streams[i].handle_irq()
-				} else {
-					c.out_streams[i - c.in_stream_count].handle_irq()
-				}
-			}
-		}
-	}
-}
-
-pub fn (mut c HDAController) initialise(pci_device &pci.PCIDevice) int {
-	pci_device.enable_bus_mastering()
-
-	if pci_device.is_bar_present(0x0) == false {
-		print('hda: unable to locate BAR0\n')
-		return -1
-	}
-
-	c.pci_bar = pci_device.get_bar(0x0)
-	if !c.pci_bar.is_mmio {
-		print('hda: BAR0 is not MMIO\n')
-		return -1
-	}
-
-	c.regs = unsafe { &HDARegisters(c.pci_bar.base + higher_half) }
-
-	mut gctl := c.regs.gctl
-
-	// if the controller is already running stop it
-	if gctl & gctl_crst != 0 {
-		gcap := c.regs.gcap
-		in_stream_count := (gcap >> gcap_iss_shift) & gcap_iss_mask
-		out_stream_count := (gcap >> gcap_oss_shift) & gcap_oss_mask
-		for i := u64(0); i < in_stream_count; i++ {
-			mut volatile stream_regs := unsafe {
-				&HDAStreamRegisters(c.pci_bar.base + 0x80 + i * 0x20 + higher_half)
-			}
-			mut ctl0 := stream_regs.ctl0
-			ctl0 &= ~sdctl0_run
-			stream_regs.ctl0 = ctl0
-		}
-		for i := u64(0); i < out_stream_count; i++ {
-			mut volatile stream_regs := unsafe {
-				&HDAStreamRegisters(c.pci_bar.base + 0x80 + c.in_stream_count * 0x20 + i * 0x20 +
-					higher_half)
-			}
-			mut ctl0 := stream_regs.ctl0
-			ctl0 &= ~sdctl0_run
-			stream_regs.ctl0 = ctl0
-		}
-
-		mut corbctl := c.regs.corbctl
-		corbctl &= ~corbctl_run
-		c.regs.corbctl = corbctl
-		mut rirbctl := c.regs.rirbctl
-		rirbctl &= ~corbctl_run
-		c.regs.rirbctl = rirbctl
-	}
-
-	gctl &= ~gctl_crst
-	c.regs.gctl = gctl
-	for {
-		if c.regs.gctl & gctl_crst == 0 {
-			break
-		}
-	}
-
-	sys.nsleep(1000 * 200)
-
-	gctl = c.regs.gctl
-	gctl |= gctl_crst
-	c.regs.gctl = gctl
-	for {
-		if c.regs.gctl & gctl_crst != 0 {
-			break
-		}
-	}
-
-	gcap := c.regs.gcap
-	if gcap & gcap_ok64 == 0 {
-		print("hda: controller doesn't support 64-bit\n")
-		return -1
-	}
-
-	mut corb_size := c.regs.corbsize
-	corb_cap := (corb_size >> corbsize_szcap_shift) & corbsize_szcap_mask
-	mut chosen_corb_size := u8(0)
-	if corb_cap & 0b100 != 0 {
-		chosen_corb_size = 0b10
-		c.corb_size = 256
-	} else if corb_cap & 0b10 != 0 {
-		chosen_corb_size = 0b1
-		c.corb_size = 16
-	} else {
-		c.corb_size = 2
-	}
-	if corb_cap != chosen_corb_size << 1 {
-		corb_size &= ~(corbsize_size_mask << corbsize_size_shift)
-		corb_size |= chosen_corb_size << corbsize_size_shift
-		c.regs.corbsize = corb_size
-	}
-
-	mut rirb_size := c.regs.rirbsize
-	rirb_cap := (rirb_size >> corbsize_szcap_shift) & corbsize_szcap_mask
-	mut chosen_rirb_size := u8(0)
-	if rirb_cap & 0b100 != 0 {
-		chosen_rirb_size = 0b10
-		c.rirb_size = 256
-	} else if rirb_cap & 0b10 != 0 {
-		chosen_rirb_size = 0b1
-		c.rirb_size = 16
-	} else {
-		c.rirb_size = 2
-	}
-	if rirb_cap != chosen_rirb_size << 1 {
-		rirb_size &= ~(corbsize_size_mask << corbsize_size_shift)
-		rirb_size |= chosen_rirb_size << corbsize_size_shift
-		c.regs.rirbsize = rirb_size
-	}
-
-	corb_phys := u64(memory.pmm_alloc(1))
-	rirb_phys := u64(memory.pmm_alloc(1))
-	dma_pos_phys := u64(memory.pmm_alloc(1))
-
-	c.corb = unsafe { &HDAVerbDescriptor(corb_phys + higher_half) }
-	c.rirb = unsafe { &HDAResponseDescriptor(rirb_phys + higher_half) }
-	c.dma_pos = unsafe { &u32(dma_pos_phys + higher_half) }
-
-	c.regs.corblbase = u32(corb_phys)
-	c.regs.corbubase = u32(corb_phys >> 32)
-	c.regs.rirblbase = u32(rirb_phys)
-	c.regs.rirbubase = u32(rirb_phys >> 32)
-	c.regs.dplbase = u32(dma_pos_phys)
-	c.regs.dpubase = u32(dma_pos_phys >> 32)
-	c.regs.dplbase |= dplbase_dpbe
-
-	mut corbctl := c.regs.corbctl
-	corbctl |= corbctl_run
-	c.regs.corbctl = corbctl
-	mut rirbctl := c.regs.rirbctl
-	rirbctl |= corbctl_run
-	c.regs.rirbctl = rirbctl
-
-	mut rintcnt := c.regs.rintcnt
-	rintcnt |= 0xFF
-	c.regs.rintcnt = rintcnt
-
-	c.in_stream_count = u8((gcap >> gcap_iss_shift) & gcap_iss_mask)
-	c.out_stream_count = u8((gcap >> gcap_oss_shift) & gcap_oss_mask)
-
-	for i := u8(0); i < c.in_stream_count; i++ {
-		c.in_streams[i] = unsafe {
-			HDAStream{
-				regs:       &HDAStreamRegisters(c.pci_bar.base + 0x80 + u64(i) * 0x20 + higher_half)
-				controller: c
-				bdl:        0
-				dma_pos:    0
-			}
-		}
-		c.in_streams[i].initialize(i, false)
-	}
-	for i := u8(0); i < c.out_stream_count; i++ {
-		c.out_streams[i] = unsafe {
-			HDAStream{
-				regs:       &HDAStreamRegisters(c.pci_bar.base + 0x80 + c.in_stream_count * 0x20 +
-					u64(i) * 0x20 + higher_half)
-				controller: c
-				bdl:        0
-				dma_pos:    0
-			}
-		}
-		c.out_streams[i].initialize(i, true)
-	}
-
-	print('hda: ${c.in_stream_count} in streams and ${c.out_stream_count} out streams\n')
-
-	if pci_device.msi_support == true {
-		print('hda: device is msi capable\n')
-		c.irq_vect = idt.allocate_vector()
-		pci_device.set_msi(c.irq_vect)
-	} else if pci_device.msix_support == true {
-		print('hda: device is msix capable\n')
-		c.irq_vect = idt.allocate_vector()
-		pci_device.set_msix(c.irq_vect)
-	} else {
-		print('hda: device is not msi or msix capable\n')
-		return -1
-	}
-
-	spawn irq_handler(mut c)
-
-	mut intctl := c.regs.intctl
-	intctl_sie := (u32(1) << (c.in_stream_count + c.out_stream_count)) - 1
-	intctl |= intctl_gie | intctl_cie | intctl_sie
-	c.regs.intctl = intctl
-
-	// wait for codec initialization
-	sys.nsleep(1000 * 1000)
-
-	statests := c.regs.statests
-	for i := 0; i < 15; i++ {
-		if statests & (1 << i) != 0 {
-			print('hda: codec found at address ${i}\n')
-
-			mut codec := unsafe {
-				&HDACodec{
-					controller: c
-					cid:        u8(i)
-					index:      c.codecs.len
-				}
-			}
-			codec.initialize()
-			c.codecs << codec
-		}
-	}
-
-	print('hda: initialized successfully\n')
-
-	return 0
-}
-
-pub fn initialize() {
-	for device in scanned_devices {
-		if (device.class == hda_class && device.subclass == hda_subclass)
-			|| (device.vendor_id == tgl_sst_vendor && device.device_id == tgl_sst_device) {
-			mut hda_device := unsafe {
-				&HDAController{
-					regs:    0
-					index:   i32(hda_controller_list.len)
-					corb:    0
-					rirb:    0
-					dma_pos: 0
-				}
-			}
-
-			if hda_device.initialise(device) != -1 {
-				hda_controller_list << hda_device
-			}
-		}
-	}
-}
diff --git a/kernel/modules/dev/hda/oss/dsp.v b/kernel/modules/dev/hda/oss/dsp.v
deleted file mode 100644
index 03c7173..0000000
--- a/kernel/modules/dev/hda/oss/dsp.v
+++ /dev/null
@@ -1,172 +0,0 @@
-@[has_globals]
-module oss
-
-import event.eventstruct
-import klock
-import stat
-import katomic
-import resource
-import fs
-
-const ctl_dsp_halt = u64(0x5000)
-const ctl_dsp_profile = u64(0x40045017)
-const ctl_setsong = u64(0x40405902)
-const ctl_getsong = u64(0x80405902)
-const ctl_dsp_speed = u64(0xc0045002)
-const ctl_dsp_setfmt = u64(0xc0045005)
-const ctl_dsp_channels = u64(0xc0045006)
-
-pub const afmt_u8 = 0x8
-pub const afmt_s16_le = 0x10
-pub const afmt_s8 = 0x40
-pub const afmt_u16_le = 0x80
-pub const afmt_s32_le = 0x1000
-
-pub interface OssAudioStream {
-mut:
-	setup_params(fmt u8, rate u32, channels u8)
-	change_volume(percentage int)
-	play(play bool)
-	reset()
-	sync_write(buf voidptr, loc u64, count u64) ?i64
-	wait_until_empty()
-	is_playing() bool
-}
-
-pub interface OssAudioDevice {
-mut:
-	get_output_stream() &OssAudioStream
-
-	refine_fmt(fmt u8) u8
-	refine_channels(channels u8) u8
-}
-
-pub struct OssDevice {
-pub mut:
-	stat        stat.Stat
-	refcount    int
-	l           klock.Lock
-	event       eventstruct.Event
-	status      int
-	can_mmap    bool
-	device      &OssAudioDevice
-	song_name   string
-	sample_rate u32
-	fmt         u8
-	channels    u8
-}
-
-__global (
-	oss_devices []&OssDevice
-)
-
-pub fn create_device(device &OssAudioDevice) {
-	oss_device := &OssDevice{
-		device: unsafe { device }
-	}
-
-	name := 'dsp${oss_devices.len}'
-	fs.devtmpfs_add_device(oss_device, name)
-	root := fs.devtmpfs_get_root()
-	fs.symlink(root, name, 'dsp')
-
-	create_mixer(oss_device, oss_devices.len)
-
-	oss_devices << oss_device
-}
-
-fn (mut dev OssDevice) grow(handle voidptr, new_size u64) ? {
-	return none
-}
-
-fn (mut dev OssDevice) read(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	return none
-}
-
-fn (mut dev OssDevice) write(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	mut stream := dev.device.get_output_stream()
-	if !stream.is_playing() {
-		stream.setup_params(dev.fmt, dev.sample_rate, dev.channels)
-	}
-	return stream.sync_write(buf, loc, count)
-}
-
-fn (mut dev OssDevice) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	match request {
-		ctl_dsp_halt {
-			mut stream := dev.device.get_output_stream()
-			stream.play(false)
-			stream.reset()
-			return 0
-		}
-		ctl_dsp_profile {
-			return 0
-		}
-		ctl_setsong {
-			ptr := &char(argp)
-			dev.song_name = unsafe { cstring_to_vstring(ptr) }
-			return 0
-		}
-		ctl_getsong {
-			ptr := &char(argp)
-			unsafe {
-				C.memcpy(ptr, dev.song_name.str, dev.song_name.len)
-				ptr[dev.song_name.len] = 0
-			}
-			return 0
-		}
-		ctl_dsp_speed {
-			dev.sample_rate = u32(unsafe { *&int(argp) })
-			return 0
-		}
-		ctl_dsp_setfmt {
-			ptr := &int(argp)
-			fmt := u8(unsafe { *ptr })
-			refined := dev.device.refine_fmt(fmt)
-			if fmt != refined {
-				unsafe {
-					*ptr = refined
-				}
-			}
-			dev.fmt = refined
-			return 0
-		}
-		ctl_dsp_channels {
-			ptr := &int(argp)
-			channels := u8(unsafe { *ptr })
-			refined := dev.device.refine_channels(channels)
-			if channels != refined {
-				unsafe {
-					*ptr = refined
-				}
-			}
-			dev.channels = refined
-			return 0
-		}
-		else {
-			print('oss: unhandled ioctl ${request:x}\n')
-			return resource.default_ioctl(handle, request, argp)
-		}
-	}
-}
-
-fn (mut dev OssDevice) unref(handle voidptr) ? {
-	katomic.dec(mut dev.refcount)
-
-	mut stream := dev.device.get_output_stream()
-	stream.wait_until_empty()
-	stream.play(false)
-	stream.reset()
-}
-
-fn (mut dev OssDevice) link(handle voidptr) ? {
-	katomic.inc(mut dev.stat.nlink)
-}
-
-fn (mut dev OssDevice) unlink(handle voidptr) ? {
-	katomic.dec(mut dev.stat.nlink)
-}
-
-fn (mut dev OssDevice) mmap(page u64, flags int) voidptr {
-	return 0
-}
diff --git a/kernel/modules/dev/hda/oss/mixer.v b/kernel/modules/dev/hda/oss/mixer.v
deleted file mode 100644
index 396df67..0000000
--- a/kernel/modules/dev/hda/oss/mixer.v
+++ /dev/null
@@ -1,280 +0,0 @@
-@[has_globals]
-module oss
-
-import event.eventstruct
-import klock
-import stat
-import fs
-import katomic
-import resource
-import errno
-
-const ctl_mix_read = u64(0xc0345805)
-const ctl_mix_write = u64(0xc0345806)
-const ctl_mix_extinfo = u64(0xc0dc5804)
-const ctl_mixerinfo = u64(0xc470580a)
-
-struct OssMixerInfo {
-pub mut:
-	dev            int
-	id             [16]char
-	name           [32]char
-	modify_counter int
-	card_number    int
-	port_number    int
-	handle         [32]char
-	magic          int
-	enabled        int
-	caps           int
-	flags          int
-	nrext          int
-	priority       int
-	devnode        [32]char
-	legacy_device  int
-	filler         [245]int
-}
-
-struct OssMixExt {
-pub mut:
-	dev            int
-	ctrl           int
-	entry_type     int
-	max_value      int
-	min_value      int
-	flags          int
-	id             [16]char
-	parent         int
-	dummy          int
-	timestamp      int
-	data           [64]char
-	enum_present   [32]u8
-	control_no     int
-	desc           u32
-	ext_name       [32]char
-	update_counter int
-	rgb_color      int
-	filler         [6]int
-}
-
-const mixt_devroot = 0
-const mixt_group = 1
-const mixt_onoff = 2
-const mixt_enum = 3
-const mixt_monoslider = 4
-const mixt_stereoslider = 5
-const mixt_message = 6
-const mixt_monovu = 7
-const mixt_stereovu = 8
-const mixt_monopeak = 9
-const mixt_stereopeak = 10
-const mixt_radiogroup = 11
-const mixt_marker = 12
-const mixt_value = 13
-const mixt_hexvalue = 14
-const mixt_slider = 17
-const mixt_3d = 18
-const mixt_monoslider16 = 19
-const mixt_stereoslider16 = 20
-const mixt_mute = 21
-const mixt_enum_multi = 22
-
-const mixf_readable = 0x1
-const mixf_writable = 0x2
-const mixf_poll = 0x4
-const mixf_hz = 0x8
-const mixf_string = 0x10
-const mixf_dynamic = 0x10
-const mixf_okfail = 0x20
-const mixf_flat = 0x40
-const mixf_legacy = 0x80
-const mixf_centibel = 0x100
-const mixf_decibel = 0x200
-const mixf_mainvol = 0x400
-const mixf_pcmvol = 0x800
-const mixf_recvol = 0x1000
-const mixf_monvol = 0x2000
-const mixf_wide = 0x4000
-const mixf_descr = 0x8000
-const mixf_disabled = 0x10000
-
-const mixext_scope_input = 0x1
-const mixext_scope_output = 0x2
-
-struct OssMixExtRoot {
-pub mut:
-	id   [16]char
-	name [48]char
-}
-
-struct OssMixerValue {
-pub mut:
-	dev       int
-	ctrl      int
-	value     int
-	flags     int
-	timestamp int
-	filler    [8]int
-}
-
-pub struct OssMixerDevice {
-pub mut:
-	stat           stat.Stat
-	refcount       int
-	l              klock.Lock
-	event          eventstruct.Event
-	status         int
-	can_mmap       bool
-	main_device    &OssDevice
-	index          int
-	modify_counter int
-	current_volume int
-}
-
-__global (
-	oss_mixers []&OssMixerDevice
-)
-
-fn create_mixer(main_device &OssDevice, index int) {
-	mut oss_mixer := unsafe {
-		&OssMixerDevice{
-			main_device:    main_device
-			index:          index
-			current_volume: 50
-		}
-	}
-
-	name := 'mixer${index}'
-	fs.devtmpfs_add_device(oss_mixer, name)
-	root := fs.devtmpfs_get_root()
-	fs.symlink(root, name, 'mixer')
-
-	oss_mixers << oss_mixer
-}
-
-fn (mut dev OssMixerDevice) grow(handle voidptr, new_size u64) ? {
-	return none
-}
-
-fn (mut dev OssMixerDevice) read(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	return none
-}
-
-fn (mut dev OssMixerDevice) write(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	return none
-}
-
-fn (mut dev OssMixerDevice) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	match request {
-		ctl_mix_read {
-			mut value := unsafe { &OssMixerValue(argp) }
-			match value.ctrl {
-				2 {
-					value.value = dev.current_volume
-					return 0
-				}
-				else {
-					errno.set(errno.einval)
-					return -1
-				}
-			}
-		}
-		ctl_mix_write {
-			mut value := unsafe { &OssMixerValue(argp) }
-			match value.ctrl {
-				2 {
-					dev.current_volume = value.value
-					dev.modify_counter += 1
-					mut stream := dev.main_device.device.get_output_stream()
-					stream.change_volume(value.value)
-					return 0
-				}
-				else {
-					errno.set(errno.einval)
-					return -1
-				}
-			}
-		}
-		ctl_mix_extinfo {
-			mut info := unsafe { &OssMixExt(argp) }
-
-			match info.ctrl {
-				0 {
-					info.entry_type = mixt_devroot
-					root := unsafe { &OssMixExtRoot(&info.data) }
-
-					name := 'hda_main'
-
-					unsafe {
-						C.memcpy(&root.id, name.str, name.len + 1)
-						C.memcpy(&root.name, name.str, name.len + 1)
-					}
-					return 0
-				}
-				1 {
-					info.entry_type = mixt_marker
-					return 0
-				}
-				2 {
-					info.entry_type = mixt_monoslider
-					info.min_value = 0
-					info.max_value = 100
-					info.flags = mixf_readable | mixf_writable | mixf_mainvol
-
-					name := 'hda_mainvolume'
-
-					unsafe {
-						C.memcpy(&info.ext_name, name.str, name.len + 1)
-					}
-					return 0
-				}
-				else {
-					errno.set(errno.einval)
-					return -1
-				}
-			}
-		}
-		ctl_mixerinfo {
-			mut info := unsafe { &OssMixerInfo(argp) }
-
-			name := 'HDA Mixer'
-			dev_name := '/dev/mixer${dev.index}'
-
-			unsafe {
-				C.memcpy(&info.id, name.str, name.len + 1)
-				C.memcpy(&info.name, name.str, name.len + 1)
-				C.memcpy(&info.devnode, dev_name.str, dev_name.len + 1)
-			}
-			info.modify_counter = dev.modify_counter
-			info.card_number = -1
-			info.port_number = 0
-			info.enabled = 1
-			info.caps = 0
-			info.nrext = 3
-			info.priority = 1
-			info.legacy_device = dev.index
-			return 0
-		}
-		else {
-			print('oss: unhandled mixer ioctl ${request:x}\n')
-			return resource.default_ioctl(handle, request, argp)
-		}
-	}
-
-	return -1
-}
-
-fn (mut dev OssMixerDevice) unref(handle voidptr) ? {
-	katomic.dec(mut dev.refcount)
-}
-
-fn (mut dev OssMixerDevice) link(handle voidptr) ? {
-	katomic.inc(mut dev.stat.nlink)
-}
-
-fn (mut dev OssMixerDevice) unlink(handle voidptr) ? {
-	katomic.dec(mut dev.stat.nlink)
-}
-
-fn (mut dev OssMixerDevice) mmap(page u64, flags int) voidptr {
-	return 0
-}
diff --git a/kernel/modules/dev/hda/stream.v b/kernel/modules/dev/hda/stream.v
deleted file mode 100644
index e5a8fc2..0000000
--- a/kernel/modules/dev/hda/stream.v
+++ /dev/null
@@ -1,329 +0,0 @@
-module hda
-
-import memory
-import dev.hda.oss
-import event.eventstruct
-import event
-import katomic
-
-struct HDABufferDescriptor {
-pub mut:
-	address u64
-	length  u32
-	ioc     u32
-}
-
-const max_buffer_descriptors = page_size / sizeof(HDABufferDescriptor)
-const total_buffer_size = max_buffer_descriptors * page_size
-const chunk_size = page_size
-
-struct HDAStream {
-pub mut:
-	volatile regs           &HDAStreamRegisters
-	volatile dma_pos        &u32
-	controller     &HDAController
-	bdl            &HDABufferDescriptor
-	event          eventstruct.Event
-	bdl_phys       u64
-	cur_user_pos   u32
-	remaining_data u32
-	cur_volume     u32
-	channels       u8
-	is_output      bool
-}
-
-fn (mut s HDAStream) initialize_output() {
-	s.regs.bdpl = u32(s.bdl_phys)
-	s.regs.bdpu = u32(s.bdl_phys >> 32)
-
-	if s.is_output {
-		mut ctl2 := s.regs.ctl2
-		ctl2 &= ~(sdctl2_strm_mask << sdctl2_strm_shift)
-		ctl2 |= 1 << sdctl2_strm_shift
-		s.regs.ctl2 = ctl2
-
-		mut ctl0 := s.regs.ctl0
-		ctl0 |= sdctl0_ioce
-		s.regs.ctl0 = ctl0
-
-		// cyclic buffer length
-		s.regs.cbl = u32(max_buffer_descriptors * 0x1000)
-
-		// 256 entries
-		mut lvi := s.regs.lvi
-		lvi &= ~(sdlvi_lvi_mask << sdlvi_lvi_shift)
-		lvi |= 0xFF << sdlvi_lvi_shift
-		s.regs.lvi = lvi
-	}
-}
-
-pub fn (mut s HDAStream) initialize(index u8, is_output bool) {
-	bdl_phys := u64(memory.pmm_alloc(1))
-	s.bdl = unsafe { &HDABufferDescriptor(bdl_phys + higher_half) }
-	s.bdl_phys = bdl_phys
-	s.is_output = is_output
-
-	s.dma_pos = unsafe {
-		if is_output {
-			&s.controller.dma_pos[(s.controller.in_stream_count * 2 + index * 2)]
-		} else {
-			&s.controller.dma_pos[2 * index]
-		}
-	}
-
-	for i in 0 .. max_buffer_descriptors {
-		unsafe {
-			s.bdl[i].address = u64(memory.pmm_alloc(1))
-			s.bdl[i].length = u32(page_size)
-			if i != 0 && (i * page_size) % chunk_size == 0 {
-				s.bdl[i].ioc = 1
-			}
-		}
-	}
-
-	s.initialize_output()
-}
-
-fn (s HDAStream) hda_get_format() PCMFormat {
-	return PCMFormat{
-		value: s.regs.fmt
-	}
-}
-
-fn (mut s HDAStream) hda_set_format(fmt PCMFormat) {
-	s.regs.fmt = fmt.value
-}
-
-fn (mut s HDAStream) setup_params(fmt u8, rate u32, channels u8) {
-	mut bits := u8(0)
-
-	match fmt {
-		oss.afmt_u8 {
-			bits = 8
-		}
-		oss.afmt_s16_le {
-			bits = 16
-		}
-		oss.afmt_s8 {
-			bits = 8
-		}
-		oss.afmt_u16_le {
-			bits = 16
-		}
-		oss.afmt_s32_le {
-			bits = 32
-		}
-		else {
-			return
-		}
-	}
-
-	mut hda_fmt := s.hda_get_format()
-	hda_fmt.set_sample_rate(rate)
-	hda_fmt.set_bits_per_sample(bits)
-	hda_fmt.set_num_channels(channels)
-	s.hda_set_format(hda_fmt)
-
-	for mut codec in s.controller.codecs {
-		codec.setup_all_output_paths(rate, bits, channels)
-	}
-}
-
-fn (mut s HDAStream) change_volume(percentage int) {
-	s.cur_volume = u32(percentage)
-
-	for mut codec in s.controller.codecs {
-		for path in codec.non_overlapping_output_paths {
-			for widget in path.widgets {
-				if widget.widget_type == widget_type_audio_out {
-					max_val := widget.out_amp_caps & 0x7F
-
-					mut one_percentage := max_val / 100
-					if one_percentage == 0 {
-						one_percentage = 1
-					}
-					mut value := one_percentage * u32(percentage)
-					if value > max_val {
-						value = max_val
-					}
-
-					// set output amp, set left amp, set right amp and gain
-					amp_data := u16(1 << 15 | 1 << 13 | 1 << 12 | value)
-					codec.set_amp_gain_mute(widget.nid, amp_data)
-				}
-			}
-		}
-	}
-}
-
-fn (mut s HDAStream) play(play bool) {
-	mut ctl0 := s.regs.ctl0
-	if (ctl0 & sdctl0_run) == 0 && play {
-		ctl0 |= sdctl0_run
-		s.regs.ctl0 = ctl0
-	} else if (ctl0 & sdctl0_run) != 0 && !play {
-		ctl0 &= ~sdctl0_run
-		s.regs.ctl0 = ctl0
-	}
-}
-
-fn (mut s HDAStream) reset() {
-	assert (s.regs.ctl0 & sdctl0_run) == 0, 'stream must be stopped prior to resetting'
-
-	s.regs.ctl0 |= sdctl0_srst
-	for {
-		if s.regs.ctl0 & sdctl0_srst != 0 {
-			break
-		}
-	}
-
-	s.regs.ctl0 &= ~sdctl0_srst
-	for {
-		if s.regs.ctl0 & sdctl0_srst == 0 {
-			break
-		}
-	}
-
-	s.initialize_output()
-	s.cur_user_pos = 0
-}
-
-fn (s HDAStream) is_playing() bool {
-	return s.regs.ctl0 & sdctl0_run != 0
-}
-
-fn (mut s HDAStream) sync_write(buf voidptr, loc u64, count u64) ?i64 {
-	mut first_write := false
-
-	mut i := u64(0)
-	for {
-		if i == count {
-			break
-		}
-
-		s_remaining := katomic.load(&s.remaining_data)
-
-		if s.regs.ctl0 & sdctl0_run != 0 && s_remaining == total_buffer_size {
-			mut events := [&s.event]
-			event.await(mut events, true) or {}
-		}
-
-		to_copy := if i + (total_buffer_size - s_remaining) > count {
-			count - i
-		} else {
-			total_buffer_size - s_remaining
-		}
-
-		mut progress := u64(0)
-		for {
-			if progress == to_copy {
-				break
-			}
-
-			desc_index := s.cur_user_pos / page_size
-			desc_offset := s.cur_user_pos % page_size
-
-			remaining := to_copy - progress
-			small_chunk_size := if remaining < (page_size - desc_offset) {
-				remaining
-			} else {
-				page_size - desc_offset
-			}
-
-			unsafe {
-				desc := &s.bdl[desc_index]
-				ptr := voidptr(desc.address + desc_offset + higher_half)
-				C.memcpy(ptr, voidptr(usize(buf) + i + progress), small_chunk_size)
-			}
-			s.cur_user_pos += u32(small_chunk_size)
-			if s.cur_user_pos == u32(total_buffer_size) {
-				s.cur_user_pos = 0
-			}
-
-			progress += small_chunk_size
-		}
-
-		for {
-			old := katomic.load(&s.remaining_data)
-			if katomic.cas(mut s.remaining_data, old, old + u32(to_copy)) {
-				break
-			}
-		}
-
-		if s.regs.ctl0 & sdctl0_run == 0 && s.remaining_data >= chunk_size * 2 {
-			s.play(true)
-			first_write = true
-		}
-
-		i += to_copy
-	}
-
-	if first_write {
-		for {
-			s_remaining := katomic.load(&s.remaining_data)
-			if s_remaining <= chunk_size * 2 {
-				break
-			}
-			mut events := [&s.event]
-			event.await(mut events, true) or {}
-		}
-	}
-
-	return count
-}
-
-fn (mut s HDAStream) wait_until_empty() {
-	for {
-		s_remaining := katomic.load(&s.remaining_data)
-		if s_remaining == 0 {
-			break
-		} else if s_remaining <= u32(total_buffer_size - chunk_size) {
-			mut progress := u64(0)
-			for {
-				if progress == chunk_size {
-					break
-				}
-
-				desc_index := s.cur_user_pos / page_size
-				desc_offset := s.cur_user_pos % page_size
-
-				remaining := chunk_size - progress
-				small_chunk_size := if remaining < (page_size - desc_offset) {
-					remaining
-				} else {
-					page_size - desc_offset
-				}
-
-				unsafe {
-					desc := &s.bdl[desc_index]
-					ptr := voidptr(desc.address + desc_offset + higher_half)
-					C.memset(ptr, 0, small_chunk_size)
-				}
-				s.cur_user_pos += u32(small_chunk_size)
-				if s.cur_user_pos == u32(total_buffer_size) {
-					s.cur_user_pos = 0
-				}
-
-				progress += small_chunk_size
-			}
-		}
-
-		mut events := [&s.event]
-		event.await(mut events, true) or {}
-	}
-}
-
-fn (mut s HDAStream) handle_irq() {
-	for {
-		old := katomic.load(&s.remaining_data)
-		new_value := if old <= u32(chunk_size) {
-			u32(0)
-		} else {
-			old - u32(chunk_size)
-		}
-		if katomic.cas(mut s.remaining_data, old, new_value) {
-			break
-		}
-	}
-	event.trigger(mut s.event, true)
-}
diff --git a/kernel/modules/dev/mouse/mouse.v b/kernel/modules/dev/mouse/mouse.v
deleted file mode 100644
index 314edb0..0000000
--- a/kernel/modules/dev/mouse/mouse.v
+++ /dev/null
@@ -1,222 +0,0 @@
-@[has_globals]
-module mouse
-
-import resource
-import stat
-import fs
-import file
-import event
-import event.eventstruct
-import klock
-import katomic
-import errno
-import x86.kio
-import x86.apic
-import x86.idt
-
-@[inline]
-fn wait(t int) {
-	mut timeout := 100000
-	if t == 0 {
-		for ; timeout != 0; timeout-- {
-			if kio.port_in[u8](0x64) & (1 << 0) != 0 {
-				return
-			}
-		}
-	} else {
-		for ; timeout != 0; timeout-- {
-			if kio.port_in[u8](0x64) & (1 << 1) == 0 {
-				return
-			}
-		}
-	}
-}
-
-@[inline]
-fn write(val u8) {
-	wait(1)
-	kio.port_out[u8](0x64, 0xd4)
-	wait(1)
-	kio.port_out[u8](0x60, val)
-}
-
-@[inline]
-fn read() u8 {
-	wait(0)
-	return kio.port_in[u8](0x60)
-}
-
-struct MousePacket {
-pub mut:
-	flags u8
-	x_mov u32
-	y_mov u32
-}
-
-struct Mouse {
-pub mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	event    eventstruct.Event
-	status   int
-	can_mmap bool
-
-	packet_avl bool
-	packet     MousePacket
-}
-
-fn (mut this Mouse) mmap(page u64, flags int) voidptr {
-	panic('')
-}
-
-fn (mut this Mouse) read(_handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	if count != sizeof(MousePacket) {
-		errno.set(errno.einval)
-		return none
-	}
-
-	handle := unsafe { &file.Handle(_handle) }
-
-	mouse_res.l.acquire()
-
-	for mouse_res.packet_avl == false {
-		mouse_res.l.release()
-
-		if handle.flags & resource.o_nonblock != 0 {
-			errno.set(errno.ewouldblock)
-			return none
-		}
-
-		mut events := [&mouse_res.event]
-		event.await(mut events, true) or {}
-		unsafe { events.free() }
-
-		mouse_res.l.acquire()
-	}
-
-	unsafe {
-		C.memcpy(buf, &mouse_res.packet, sizeof(MousePacket))
-	}
-	mouse_res.packet_avl = false
-
-	mouse_res.status &= ~int(file.pollin)
-
-	mouse_res.l.release()
-
-	return sizeof(MousePacket)
-}
-
-fn (mut this Mouse) write(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	return i64(count)
-}
-
-fn (mut this Mouse) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	return resource.default_ioctl(handle, request, argp)
-}
-
-fn (mut this Mouse) unref(handle voidptr) ? {
-	katomic.dec(mut &this.refcount)
-}
-
-fn (mut this Mouse) link(handle voidptr) ? {
-	katomic.inc(mut &this.stat.nlink)
-}
-
-fn (mut this Mouse) unlink(handle voidptr) ? {
-	katomic.dec(mut &this.stat.nlink)
-}
-
-fn (mut this Mouse) grow(handle voidptr, new_size u64) ? {
-}
-
-__global (
-	mouse_res        Mouse
-	ps2_mouse_vector u8
-)
-
-fn handler() {
-	mut handler_cycle := 0
-	mut current_packet := MousePacket{}
-	mut discard_packet := false
-
-	for {
-		mut events := [&int_events[ps2_mouse_vector]]
-		event.await(mut events, true) or {}
-		unsafe { events.free() }
-
-		// we will get some spurious packets at the beginning and they will screw
-		// up the alignment of the handler cycle so just ignore everything in
-		// the first 250 milliseconds after boot
-		if monotonic_clock.tv_sec == 0 && monotonic_clock.tv_nsec < 250000000 {
-			kio.port_in[u8](0x60)
-		}
-
-		match handler_cycle {
-			0 {
-				current_packet.flags = read()
-				handler_cycle++
-				if current_packet.flags & (1 << 6) != 0 || current_packet.flags & (1 << 7) != 0 {
-					discard_packet = true
-				}
-				if current_packet.flags & (1 << 3) == 0 {
-					discard_packet = true
-				}
-				continue
-			}
-			1 {
-				current_packet.x_mov = read()
-				handler_cycle++
-				continue
-			}
-			2 {
-				current_packet.y_mov = read()
-				handler_cycle = 0
-
-				if discard_packet {
-					discard_packet = false
-					continue
-				}
-			}
-			else {}
-		}
-
-		if current_packet.flags & (1 << 4) != 0 {
-			current_packet.x_mov = u32(i8(u8(current_packet.x_mov)))
-		}
-		if current_packet.flags & (1 << 5) != 0 {
-			current_packet.y_mov = u32(i8(u8(current_packet.y_mov)))
-		}
-
-		mouse_res.l.acquire()
-		mouse_res.packet = current_packet
-		mouse_res.packet_avl = true
-		mouse_res.l.release()
-
-		mouse_res.status |= file.pollin
-		event.trigger(mut mouse_res.event, false)
-	}
-}
-
-pub fn initialise() {
-	write(0xf6)
-	read()
-
-	write(0xf4)
-	read()
-
-	mouse_res.stat.size = 0
-	mouse_res.stat.blocks = 0
-	mouse_res.stat.blksize = 512
-	mouse_res.stat.rdev = resource.create_dev_id()
-	mouse_res.stat.mode = 0o644 | stat.ifchr
-
-	mouse_res.status |= file.pollout
-
-	fs.devtmpfs_add_device(&mouse_res, 'mouse')
-
-	ps2_mouse_vector = idt.allocate_vector()
-	apic.io_apic_set_irq_redirect(cpu_locals[0].lapic_id, ps2_mouse_vector, 12, true)
-
-	spawn handler()
-}
diff --git a/kernel/modules/dev/nvme/nvme.v b/kernel/modules/dev/nvme/nvme.v
deleted file mode 100644
index 9e7b130..0000000
--- a/kernel/modules/dev/nvme/nvme.v
+++ /dev/null
@@ -1,872 +0,0 @@
-@[has_globals]
-module nvme
-
-import pci
-import memory
-import lib
-import x86.idt
-import bitmap
-import stat
-import klock
-import event
-import event.eventstruct
-import resource
-import errno
-import block.partition
-import fs
-import katomic
-
-const nvme_class = 0x1
-const nvme_subclass = 0x8
-const nvme_progif = 0x2
-
-const opcode_delete_sq = 0x0
-const opcode_create_sq = 0x1
-const opcode_delete_cq = 0x4
-const opcode_create_cq = 0x5
-const opcode_identify = 0x6
-const opcode_abort = 0x8
-const opcode_set_features = 0x9
-const opcode_get_features = 0xa
-const opcode_ns_management = 0xd
-const opcode_format_cmd = 0x80
-
-const nvme_io_queue_cnt = 0x4
-
-@[packed]
-struct NVMERegisters {
-pub mut:
-	cap   u64
-	vs    u32
-	intms u32
-	intmc u32
-	cc    u32
-	rsvd1 u32
-	csts  u32
-	rsvd2 u32
-	aqa   u32
-	asq   u64
-	acq   u64
-}
-
-@[packed]
-struct NVMECommandCreateCQ {
-pub mut:
-	rsvd1      [5]u32
-	prp1       u64
-	rsvd2      u64
-	cqid       u16
-	qsize      u16
-	cq_flags   u16
-	irq_vector u16
-	rsvd3      [4]u32
-}
-
-@[packed]
-struct NVMECommandCreateSQ {
-pub mut:
-	rsvd1    [5]u32
-	prp1     u64
-	rsvd2    u64
-	sqid     u16
-	qsize    u16
-	sq_flags u16
-	cqid     u16
-	rsvd3    [4]u32
-}
-
-@[packed]
-struct NVMECommandDeleteQ {
-pub mut:
-	rsvd1 [9]u32
-	qid   u16
-	rsvd2 u16
-	rsvd3 [5]u32
-}
-
-@[packed]
-struct NVMECommandAbort {
-pub mut:
-	rsvd1 [9]u32
-	sqid  u16
-	cid   u16
-	rsvd2 [5]u32
-}
-
-@[packed]
-struct NVMECommandFeatures {
-pub mut:
-	nsid    u32
-	rsvd1   [2]u64
-	prp1    u64
-	prp2    u64
-	fid     u32
-	dword11 u32
-	rsvd2   [4]u32
-}
-
-@[packed]
-struct NVMECommandIdentify {
-pub mut:
-	nsid  u32
-	rsvd1 [2]u64
-	prp1  u64
-	prp2  u64
-	cns   u32
-	rsvd2 [5]u32
-}
-
-@[packed]
-struct NVMECommandRW {
-pub mut:
-	nsid     u32
-	rsvd1    u64
-	metadata u64
-	prp1     u64
-	prp2     u64
-	slba     u64
-	length   u16
-	control  u16
-	dsmgmt   u32
-	reftag   u32
-	apptag   u16
-	appmask  u16
-}
-
-union NVMECommandPrivate {
-pub mut:
-	create_cq    NVMECommandCreateCQ
-	create_sq    NVMECommandCreateSQ
-	delete_queue NVMECommandDeleteQ
-	abort        NVMECommandAbort
-	features     NVMECommandFeatures
-	identify     NVMECommandIdentify
-	rw           NVMECommandRW
-}
-
-@[packed]
-struct NVMECommand {
-pub mut:
-	opcode  u8
-	flags   u8
-	cid     u16
-	private NVMECommandPrivate
-}
-
-@[packed]
-struct NVMECompletion {
-pub mut:
-	result  u32
-	rsvd    u32
-	sq_head u16
-	sq_id   u16
-	cid     u16
-	status  u16
-}
-
-@[packed]
-struct NVMEPowerStateID {
-pub mut:
-	max_power         u16
-	rsvd1             u8
-	flags             u8
-	entry_lat         u32
-	exit_lat          u32
-	read_tput         u8
-	read_lat          u8
-	write_tput        u8
-	write_lat         u8
-	idle_power        u16
-	idle_scale        u8
-	rsvd2             u8
-	active_power      u16
-	active_work_scale u8
-	rsvd3             [9]u8
-}
-
-@[packed]
-struct NVMEControllerID {
-pub mut:
-	vid    u16
-	ssvid  u16
-	sn     [20]char
-	mn     [40]char
-	fr     [8]char
-	rab    u8
-	ieee   [3]u8
-	mic    u8
-	mdts   u8
-	cntlid u16
-	ver    u32
-	rsvd1  [172]u8
-	oacs   u16
-	acl    u8
-	aerl   u8
-	frmw   u8
-	lpa    u8
-	elpe   u8
-	npss   u8
-	avscc  u8
-	apsta  u8
-	wctemp u16
-	cctemp u16
-	rsvd2  [242]u8
-	sqes   u8
-	cqes   u8
-	rsvd3  [2]u8
-	nn     u32
-	oncs   u16
-	fuses  u16
-	fna    u8
-	vwc    u8
-	awun   u16
-	awupf  u16
-	nvscc  u8
-	rsvd4  u8
-	acwu   u16
-	rsvd5  [2]u8
-	sgls   u32
-	rsvd6  [1508]u8
-	psd    [32]NVMEPowerStateID
-	vs     [1024]u8
-}
-
-@[packed]
-struct NVMELbaf {
-pub mut:
-	ms u16
-	ds u8
-	rp u8
-}
-
-@[packed]
-struct NVMENamespaceID {
-pub mut:
-	nsze      u64
-	ncap      u64
-	nuse      u64
-	nsfeat    u8
-	nlbaf     u8
-	flbas     u8
-	mc        u8
-	dpc       u8
-	dps       u8
-	nmic      u8
-	rescap    u8
-	fpi       u8
-	rsvd1     u8
-	nawun     u16
-	nawupf    u16
-	nacwu     u16
-	nabsn     u16
-	nabo      u16
-	nabspf    u16
-	rsvd2     u16
-	nvmcap    [2]u64
-	rsvd3     [40]u8
-	nguid     [16]u8
-	eui64     [8]u8
-	lbaf_list [16]NVMELbaf
-	rsvd4     [192]u8
-	vs        [3712]u8
-}
-
-struct NVMEController {
-pub mut:
-	pci_bar       pci.PCIBar
-	volatile regs          &NVMERegisters
-	volatile controller_id &NVMEControllerID
-
-	queue_entries      u64
-	max_page_size      u64
-	min_page_size      u64
-	page_size          u64
-	max_transfer_shift u64
-	max_prps           u64
-	strides            u64
-	qid_bitmap         bitmap.GenericBitmap
-
-	admin_queue    &NVMEQueuePair
-	namespace_list []&NVMENamespace
-
-	io_queue_bitmap bitmap.GenericBitmap
-	queue_list      []&NVMEQueuePair
-}
-
-struct NVMEQueuePair {
-pub mut:
-	qid       u64
-	entry_cnt u64
-	sq_head   u64
-	sq_tail   u64
-	cq_head   u64
-	cq_tail   u64
-	phase     bool
-	vector    u64
-	irq       u64
-	admin     bool
-	l         klock.Lock
-
-	parent_controller   &NVMEController
-	volatile submission_queue    &NVMECommand
-	volatile completion_queue    &NVMECompletion
-	volatile submission_doorbell &u32
-	volatile completion_doorbell &u32
-
-	cid_bitmap bitmap.GenericBitmap
-}
-
-struct NVMENamespace {
-pub mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	event    eventstruct.Event
-	status   int
-	can_mmap bool
-
-	max_prps u64
-	nsid     u64
-
-	parent_controller &NVMEController
-	volatile identity          &NVMENamespaceID
-}
-
-__global (
-	controller_list []&NVMEController
-)
-
-fn (mut dev NVMENamespace) read(handle voidptr, buffer voidptr, loc u64, count u64) ?i64 {
-	if loc % dev.stat.blksize != 0 || count % dev.stat.blksize != 0 {
-		errno.set(errno.eio)
-		return none
-	}
-
-	start_blk := loc / dev.stat.blksize
-	page_cnt := count / dev.stat.blksize
-
-	aligned_buffer := voidptr(u64(memory.pmm_alloc(u64(page_cnt))) + higher_half)
-
-	if dev.rw_lba(aligned_buffer, u64(start_blk), u64(page_cnt), false) == -1 {
-		errno.set(errno.eio)
-		memory.pmm_free(aligned_buffer, u64(page_cnt))
-		return none
-	}
-
-	unsafe { C.memcpy(buffer, aligned_buffer, count) }
-
-	memory.pmm_free(voidptr(u64(aligned_buffer) - higher_half), u64(page_cnt))
-
-	return i64(count)
-}
-
-fn (mut dev NVMENamespace) write(handle voidptr, buffer voidptr, loc u64, count u64) ?i64 {
-	if loc % dev.stat.blksize != 0 || count % dev.stat.blksize != 0 {
-		errno.set(errno.eio)
-		return none
-	}
-
-	start_blk := loc / dev.stat.blksize
-	page_cnt := count / dev.stat.blksize
-
-	aligned_buffer := voidptr(u64(memory.pmm_alloc(u64(page_cnt))) + higher_half)
-	unsafe { C.memcpy(aligned_buffer, buffer, count) }
-
-	if dev.rw_lba(aligned_buffer, u64(start_blk), u64(page_cnt), true) == -1 {
-		errno.set(errno.eio)
-		memory.pmm_free(aligned_buffer, u64(page_cnt))
-		return none
-	}
-
-	memory.pmm_free(voidptr(u64(aligned_buffer) - higher_half), u64(page_cnt))
-
-	return i64(count)
-}
-
-fn (mut dev NVMENamespace) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	return resource.default_ioctl(handle, request, argp)
-}
-
-fn (mut dev NVMENamespace) unref(handle voidptr) ? {
-	katomic.dec(mut &dev.refcount)
-}
-
-fn (mut dev NVMENamespace) link(handle voidptr) ? {
-	katomic.inc(mut &dev.stat.nlink)
-}
-
-fn (mut dev NVMENamespace) unlink(handle voidptr) ? {
-	katomic.dec(mut &dev.stat.nlink)
-}
-
-fn (mut dev NVMENamespace) grow(handle voidptr, new_size u64) ? {
-	return none
-}
-
-fn (mut dev NVMENamespace) mmap(page u64, flags int) voidptr {
-	return 0
-}
-
-pub fn (mut namespace NVMENamespace) initialise(mut parent_controller NVMEController, nsid u64) int {
-	unsafe {
-		namespace.parent_controller = parent_controller
-	}
-	namespace.nsid = nsid
-	namespace.identity = unsafe {
-		&NVMENamespaceID(
-			u64(memory.pmm_alloc(lib.div_roundup[u64](sizeof(NVMENamespaceID), page_size))) +
-			higher_half)
-	}
-
-	mut new_command := &NVMECommand{}
-
-	unsafe {
-		new_command.opcode = opcode_identify
-		new_command.private.identify.cns = 0
-		new_command.private.identify.nsid = u32(nsid)
-		new_command.private.identify.prp1 = u64(namespace.identity) - higher_half
-	}
-	if parent_controller.admin_queue.send_cmd_and_wait(mut new_command, -1) == 0xffff {
-		print('nvme: nsid ${nsid:x} : unable to read namespace identity\n')
-		return -1
-	}
-
-	namespace.max_prps = calculate_max_prps(mut parent_controller, namespace.identity)
-	namespace.stat.blocks = namespace.identity.nsze
-	namespace.stat.blksize = 1 << u64(namespace.identity.lbaf_list[namespace.identity.flbas & 0b11111].ds)
-	namespace.stat.size = namespace.stat.blocks * namespace.stat.blksize
-	namespace.stat.rdev = resource.create_dev_id()
-	namespace.stat.mode = 0o644 | stat.ifblk
-
-	return 0
-}
-
-fn calculate_max_prps(mut c NVMEController, identity &NVMENamespaceID) u64 {
-	lba_shift := identity.lbaf_list[identity.flbas & 0xf].ds
-
-	shift := 12 + ((c.regs.cap >> 48) & 0xf)
-	mut max_transfer_shift := u64(20)
-
-	if c.controller_id.mdts != 0 {
-		max_transfer_shift = u64(shift + c.controller_id.mdts)
-	}
-
-	max_lbas := 1 << (max_transfer_shift - lba_shift)
-	return (u64(max_lbas) * (1 << u64(lba_shift))) / 0x1000
-}
-
-pub fn (mut pair NVMEQueuePair) initialise(mut parent_controller NVMEController, vector u64, irq u64, admin bool) int {
-	qid := parent_controller.qid_bitmap.alloc() or {
-		print('nvme: no available qid\n')
-		return -1
-	}
-
-	if qid != 0 && admin == true {
-		print('nvme: cannot create admin queue with non-zero qid\n')
-		return -1
-	}
-
-	pair.parent_controller = unsafe { parent_controller }
-	pair.vector = vector
-	pair.irq = irq
-	pair.admin = admin
-	pair.entry_cnt = parent_controller.queue_entries
-
-	pair.submission_queue = unsafe {
-		&NVMECommand(
-			u64(memory.pmm_alloc(lib.div_roundup[u64](pair.entry_cnt * sizeof(NVMECommand), page_size))) +
-			higher_half)
-	}
-	pair.completion_queue = unsafe {
-		&NVMECompletion(
-			u64(memory.pmm_alloc(lib.div_roundup[u64](pair.entry_cnt * sizeof(NVMECompletion), page_size))) +
-			higher_half)
-	}
-
-	submission_offset := page_size + 2 * qid * (4 << parent_controller.strides)
-	pair.submission_doorbell = unsafe { &u32(u64(parent_controller.regs) + submission_offset) }
-
-	completion_offset := page_size + ((2 * qid + 1) * (4 << parent_controller.strides))
-	pair.completion_doorbell = unsafe { &u32(u64(parent_controller.regs) + completion_offset) }
-
-	pair.cid_bitmap.initialise(pair.entry_cnt)
-
-	if admin == true {
-		return 0
-	}
-
-	mut create_cq_command := &NVMECommand{}
-
-	unsafe {
-		create_cq_command.opcode = opcode_create_cq
-		create_cq_command.private.create_cq.prp1 = u64(pair.completion_queue) - higher_half
-		create_cq_command.private.create_cq.cqid = u16(qid)
-		create_cq_command.private.create_cq.qsize = u16(pair.entry_cnt - 1)
-		create_cq_command.private.create_cq.irq_vector = u16(irq)
-		create_cq_command.private.create_cq.cq_flags = (1 << 0) | (1 << 1)
-	}
-	if parent_controller.admin_queue.send_cmd_and_wait(mut create_cq_command, -1) == 0xffff {
-		print('nvme: unable to create completion queue\n')
-		return -1
-	}
-
-	mut create_sq_command := &NVMECommand{}
-
-	unsafe {
-		create_sq_command.opcode = opcode_create_sq
-		create_sq_command.private.create_sq.prp1 = u64(pair.submission_queue) - higher_half
-		create_sq_command.private.create_sq.cqid = u16(qid)
-		create_sq_command.private.create_sq.sqid = u16(qid)
-		create_sq_command.private.create_sq.qsize = u16(pair.entry_cnt - 1)
-		create_sq_command.private.create_sq.sq_flags = (1 << 0) | (1 << 1)
-	}
-	if parent_controller.admin_queue.send_cmd_and_wait(mut create_sq_command, -1) == 0xffff {
-		print('nvme: unable to create submission queue\n')
-		return -1
-	}
-
-	print('nvme: created io queue pair with qid ${qid:x}\n')
-
-	return 0
-}
-
-pub fn (mut pair NVMEQueuePair) send_cmd(mut submission NVMECommand, cid int) int {
-	mut command_cid := cid
-
-	if cid == -1 {
-		command_cid = int(pair.cid_bitmap.alloc() or {
-			print('nvme: no available cids on qid ${pair.qid:x}\n')
-			return -1
-		})
-	}
-
-	submission.cid = u16(command_cid)
-
-	unsafe {
-		pair.submission_queue[pair.sq_tail] = submission
-	}
-	pair.sq_tail++
-
-	if pair.sq_tail == pair.entry_cnt {
-		pair.sq_tail = 0
-	}
-
-	unsafe {
-		*pair.submission_doorbell = u32(pair.sq_tail)
-	}
-	return 0
-}
-
-pub fn (mut pair NVMEQueuePair) send_cmd_and_wait(mut submission NVMECommand, cid int) u16 {
-	pair.l.acquire()
-
-	if pair.send_cmd(mut submission, cid) == -1 {
-		print('nvme: unable to send a command to qid ${pair.qid:x}\n')
-		pair.l.release()
-		return 0xffff
-	}
-
-	mut events := [&int_events[pair.vector]]
-	event.await(mut events, true) or {}
-
-	mut completion_entry := unsafe { pair.completion_queue[pair.cq_head] }
-
-	if (completion_entry.status >> 1) != 0 {
-		print('nvme: command error: status ${completion_entry.status:x}\n')
-		pair.l.release()
-		return completion_entry.status
-	}
-
-	pair.cq_head++
-
-	if pair.cq_head == pair.entry_cnt {
-		pair.cq_head = 0
-		pair.phase = !pair.phase
-	}
-
-	pair.cid_bitmap.free_entry(u64(cid))
-
-	unsafe {
-		*pair.submission_doorbell = u32(pair.cq_head)
-	}
-	pair.l.release()
-
-	return completion_entry.status
-}
-
-pub fn (mut ns NVMENamespace) rw_lba(buffer voidptr, start u64, cnt u64, rw bool) int {
-	mut new_command := NVMECommand{}
-
-	mut queue_pair_index := ns.parent_controller.io_queue_bitmap.alloc() or { 0 }
-	mut queue_pair := ns.parent_controller.queue_list[queue_pair_index]
-
-	queue_pair.l.acquire()
-
-	cid := queue_pair.cid_bitmap.alloc() or {
-		print('nvme: no available cids\n')
-		queue_pair.l.release()
-		ns.parent_controller.io_queue_bitmap.free_entry(queue_pair_index)
-		return -1
-	}
-
-	mut prp_list := unsafe {
-		&u64(
-			u64(memory.pmm_alloc(lib.div_roundup[u64](ns.max_prps * queue_pair.entry_cnt * sizeof(u64), page_size))) +
-			higher_half)
-	}
-
-	if (cnt * ns.stat.blksize) > page_size {
-		if (cnt * ns.stat.blksize) > (page_size * 2) {
-			prp_cnt := (cnt - 1) * ns.stat.blksize / page_size
-
-			if prp_cnt > ns.max_prps {
-				print('nvme: max prps exceeded\n')
-				queue_pair.l.release()
-				ns.parent_controller.io_queue_bitmap.free_entry(queue_pair_index)
-				return -1
-			}
-
-			for i := u64(0); i < prp_cnt; i++ {
-				unsafe {
-					prp_list[i + cid * ns.max_prps] = (u64(buffer) - higher_half) + page_size +
-						i * page_size
-				}
-			}
-
-			unsafe {
-				new_command.private.rw.prp2 = u64(&prp_list[cid * ns.max_prps]) - higher_half
-			}
-		} else {
-			unsafe {
-				new_command.private.rw.prp2 = u64(buffer) + page_size - higher_half
-			}
-		}
-	}
-
-	if rw == true {
-		new_command.opcode = 1
-	} else {
-		new_command.opcode = 2
-	}
-
-	new_command.cid = u16(cid)
-
-	unsafe {
-		new_command.private.rw.nsid = u32(ns.nsid)
-		new_command.private.rw.slba = start
-		new_command.private.rw.length = u16(cnt - 1)
-		new_command.private.rw.prp1 = u64(buffer) - higher_half
-	}
-	queue_pair.l.release()
-	ns.parent_controller.io_queue_bitmap.free_entry(queue_pair_index)
-
-	if queue_pair.send_cmd_and_wait(mut new_command, int(cid)) == 0xffff {
-		print('nvme: rw fail\n')
-		return -1
-	}
-
-	return 0
-}
-
-fn (mut c NVMEController) get_controller_id() int {
-	c.controller_id = unsafe {
-		&NVMEControllerID(
-			u64(memory.pmm_alloc(lib.div_roundup[u64](sizeof(NVMEControllerID), page_size))) +
-			higher_half)
-	}
-
-	mut new_command := &NVMECommand{}
-
-	unsafe {
-		new_command.opcode = opcode_identify
-		new_command.private.identify.cns = 1
-		new_command.private.identify.prp1 = u64(c.controller_id) - higher_half
-	}
-	if c.admin_queue.send_cmd_and_wait(mut new_command, -1) == 0xffff {
-		print('nvme: unable to read controller id\n')
-		return -1
-	}
-
-	return 0
-}
-
-pub fn (mut c NVMEController) initialise(pci_device &pci.PCIDevice) int {
-	pci_device.enable_bus_mastering()
-
-	if pci_device.is_bar_present(0x0) == false {
-		print('nvme: unable to locate BAR0\n')
-		return -1
-	}
-
-	c.pci_bar = pci_device.get_bar(0x0)
-
-	c.regs = unsafe { &NVMERegisters(c.pci_bar.base + higher_half) }
-
-	major_version := (c.regs.vs >> 16) & 0xffff
-	minor_version := (c.regs.vs >> 8) & 0xff
-	tertiary_version := c.regs.vs & 0xff
-
-	print('nvme: Version Detected [${major_version}:${minor_version}:${tertiary_version}]\n')
-
-	if (u64(c.regs.cap) & (u64(1) << 37)) == 0 {
-		print('nvme: NVME command set not supported\n')
-		return -1
-	}
-
-	c.max_page_size = lib.power(2, 12 + ((c.regs.cap >> 52) & 0xf))
-	c.min_page_size = lib.power(2, 12 + ((c.regs.cap >> 48) & 0xf))
-
-	if (c.regs.cc & (1 << 0)) != 0 {
-		c.regs.cc = c.regs.cc & ~(1 << 0) // disable controller
-	}
-
-	for c.regs.csts & (1 << 0) != 0 {}
-
-	mut vect := u8(0)
-
-	if pci_device.msi_support == true {
-		print('nvme: device is msi capable\n')
-
-		vect = idt.allocate_vector()
-		pci_device.set_msi(vect)
-	} else if pci_device.msix_support == true {
-		print('nvme: device is msix capable\n')
-
-		vect = idt.allocate_vector()
-		pci_device.set_msix(vect)
-	} else {
-		print('nvme: device is not msi or msix capable\n')
-		return -1
-	}
-
-	c.queue_entries = c.regs.cap & 0xffff
-	c.strides = (c.regs.cap >> 32) & 0xf
-
-	c.qid_bitmap.initialise(0xffff)
-
-	c.admin_queue = &NVMEQueuePair{
-		parent_controller:   unsafe { nil }
-		submission_queue:    unsafe { nil }
-		completion_queue:    unsafe { nil }
-		completion_doorbell: unsafe { nil }
-		submission_doorbell: unsafe { nil }
-	}
-
-	if c.admin_queue.initialise(mut c, vect, 0, true) != 0 {
-		print('nvme: failed to create an admin queue\n')
-		return -1
-	}
-
-	c.regs.aqa = u32((c.queue_entries - 1) << 16 | (c.queue_entries - 1))
-	c.regs.asq = u64(c.admin_queue.submission_queue) - higher_half
-	c.regs.acq = u64(c.admin_queue.completion_queue) - higher_half
-
-	c.regs.cc = (0 << 4) | // nvme command set
-	 (0 << 11) | // ams = round robin
-	 (0 << 14) | // no shutdown notifications
-	 (6 << 16) | // io submission queue size 16 bytes
-	 (4 << 20) | // io completion queue size 64 bytes
-	 (1 << 0) // enable
-	for {
-		if c.regs.csts & (1 << 0) != 0 {
-			break
-		} else if c.regs.csts & (1 << 1) != 0 {
-			print('nvme: controller fatal status\n')
-			return -1
-		}
-	}
-
-	print('nvme: controller restart\n')
-
-	if c.get_controller_id() == -1 {
-		print('nvme: fatal error\n')
-		return -1
-	}
-
-	print('nvme: vendor ID: ${c.controller_id.vid:x}\n')
-	print('nvme: subsystem vendor ID: ${c.controller_id.ssvid}\n')
-
-	nsid_list := unsafe {
-		&u32(u64(memory.pmm_alloc(lib.div_roundup[u64](c.controller_id.nn * 4, page_size))) +
-			higher_half)
-	}
-
-	mut new_command := &NVMECommand{}
-
-	unsafe {
-		new_command.opcode = opcode_identify
-		new_command.private.identify.cns = 2
-		new_command.private.identify.prp1 = u64(nsid_list) - higher_half
-	}
-	if c.admin_queue.send_cmd_and_wait(mut new_command, -1) == 0xffff {
-		print('nvme: unable to read nsid list\n')
-		return -1
-	}
-
-	mut irq_count := u64(0)
-
-	c.io_queue_bitmap.initialise(nvme_io_queue_cnt)
-
-	for i := 0; i < nvme_io_queue_cnt; i++ {
-		mut new_io_queue := &NVMEQueuePair{
-			parent_controller:   unsafe { nil }
-			submission_queue:    unsafe { nil }
-			completion_queue:    unsafe { nil }
-			submission_doorbell: unsafe { nil }
-			completion_doorbell: unsafe { nil }
-		}
-
-		if pci_device.msix_support == true {
-			vect = idt.allocate_vector()
-			pci_device.set_msix(vect)
-			irq_count++
-		}
-
-		new_io_queue.initialise(mut c, vect, irq_count, false)
-
-		c.queue_list << new_io_queue
-	}
-
-	for i := u64(0); i < c.controller_id.nn; i++ {
-		if unsafe { nsid_list[i] != 0 } {
-			mut new_namespace := &NVMENamespace{
-				parent_controller: unsafe { nil }
-				identity:          unsafe { nil }
-			}
-
-			if new_namespace.initialise(mut c, unsafe { nsid_list[i] }) != 0 {
-				print('nvme: fatel error\n')
-				return -1
-			}
-
-			print('nvme: namespace id: ${new_namespace.nsid:x}\n')
-			print('nvme: lba cnt: ${new_namespace.stat.blocks:x}\n')
-			print('nvme: lba size: ${new_namespace.stat.blksize:x}\n')
-			print('nvme: max prps: ${new_namespace.max_prps:x}\n')
-
-			fs.devtmpfs_add_device(new_namespace, 'nvme${controller_list.len}n${i}')
-			partition.scan_partitions(mut new_namespace, 'nvme${controller_list.len}n${i}p')
-
-			c.namespace_list << new_namespace
-		}
-	}
-
-	return 0
-}
-
-pub fn initialise() {
-	for device in scanned_devices {
-		if device.class == nvme_class && device.subclass == nvme_subclass
-			&& device.prog_if == nvme_progif {
-			mut nvme_device := &NVMEController{
-				regs:          unsafe { nil }
-				controller_id: unsafe { nil }
-				admin_queue:   unsafe { nil }
-			}
-
-			if nvme_device.initialise(device) != -1 {
-				controller_list << nvme_device
-			}
-		}
-	}
-}
diff --git a/kernel/modules/dev/random/random.v b/kernel/modules/dev/random/random.v
deleted file mode 100644
index c46565c..0000000
--- a/kernel/modules/dev/random/random.v
+++ /dev/null
@@ -1,186 +0,0 @@
-@[has_globals]
-module random
-
-import resource
-import fs
-import stat
-import klock
-import event.eventstruct
-import memory
-import x86.cpu
-import katomic
-
-__global (
-	ur_initialized = false
-	ur_rdrand      = false
-	ur_rdseed      = false
-)
-
-struct URandom {
-mut:
-	stat       stat.Stat
-	refcount   int
-	l          klock.Lock
-	event      eventstruct.Event
-	status     int
-	can_mmap   bool
-	rng_lock   klock.Lock
-	buffer     [16]u32
-	key        [16]u32
-	reseed_ctr u64
-}
-
-@[inline]
-fn rotl32(a u32, shift u32) u32 {
-	return (a << shift) | (a >> (32 - shift))
-}
-
-@[inline]
-fn qr(a &u32, b &u32, c &u32, d &u32) {
-	unsafe {
-		*b = *b ^ rotl32(*a + *d, 7)
-		*c = *c ^ rotl32(*b + *a, 9)
-		*d = *d ^ rotl32(*c + *b, 13)
-		*a = *a ^ rotl32(*d + *c, 18)
-	}
-}
-
-// not threadsafe!
-fn (mut this URandom) do_salsa20_block(mut out [16]u32) {
-	mut x := [16]u32{}
-	for i := 0; i < 16; i++ {
-		x[i] = this.buffer[i]
-	}
-
-	for i := 0; i < 10; i++ {
-		qr(&x[0], &x[4], &x[8], &x[12])
-		qr(&x[5], &x[9], &x[13], &x[1])
-		qr(&x[10], &x[14], &x[2], &x[6])
-		qr(&x[15], &x[3], &x[7], &x[11])
-
-		qr(&x[0], &x[1], &x[2], &x[3])
-		qr(&x[5], &x[6], &x[7], &x[4])
-		qr(&x[10], &x[11], &x[8], &x[9])
-		qr(&x[15], &x[12], &x[13], &x[14])
-	}
-
-	for i := 0; i < 16; i++ {
-		out[i] = x[i] + this.key[i]
-	}
-
-	for i := 0; i < 16; i++ {
-		this.buffer[i] = x[i]
-	}
-}
-
-fn (mut this URandom) mmap(page u64, flags int) voidptr {
-	return memory.pmm_alloc(1)
-}
-
-fn (mut this URandom) read(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	if count == 0 {
-		return i64(0)
-	}
-
-	this.rng_lock.acquire()
-
-	mut cnt := count
-	mut out := [16]u32{}
-	mut cbuf := buf
-
-	this.reseed_ctr += cnt
-	if this.reseed_ctr >= 2048 {
-		this.reseed_ctr = 0
-		this.reseed()
-	}
-
-	for {
-		unsafe {
-			if cnt > 64 {
-				this.do_salsa20_block(mut out)
-				C.memcpy(cbuf, voidptr(&out[0]), 64)
-				cbuf = voidptr(u64(cbuf) + u64(64))
-				cnt -= 64
-			} else {
-				this.do_salsa20_block(mut out)
-				C.memcpy(cbuf, voidptr(&out[0]), cnt)
-				break
-			}
-		}
-	}
-
-	this.rng_lock.release()
-
-	return i64(count)
-}
-
-fn (mut this URandom) write(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	return i64(count)
-}
-
-fn (mut this URandom) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	return resource.default_ioctl(handle, request, argp)
-}
-
-fn (mut this URandom) unref(handle voidptr) ? {
-	katomic.dec(mut &this.refcount)
-}
-
-fn (mut this URandom) link(handle voidptr) ? {
-	katomic.inc(mut &this.stat.nlink)
-}
-
-fn (mut this URandom) unlink(handle voidptr) ? {
-	katomic.dec(mut &this.stat.nlink)
-}
-
-fn (mut this URandom) grow(handle voidptr, new_size u64) ? {
-}
-
-fn (mut this URandom) reseed() {
-	if ur_rdseed {
-		for i in 0 .. this.key.len {
-			this.key[i] ^= cpu.rdseed32()
-		}
-	} else if ur_rdrand {
-		for i in 0 .. this.key.len {
-			this.key[i] ^= cpu.rdrand32()
-		}
-	}
-}
-
-pub fn initialise() {
-	mut success, _, mut b, mut c, _ := cpu.cpuid(1, 0)
-	if success && (c & (1 << 30)) != 0 {
-		println('urandom: rdrand available')
-		ur_rdrand = true
-	}
-
-	success, _, b, _, _ = cpu.cpuid(7, 0)
-	if success && (b & (1 << 18)) != 0 {
-		println('urandom: rdseed available')
-		ur_rdseed = true
-	}
-
-	// todo improve entropy via interrupts and other random events
-	mut rng := &URandom{}
-
-	rng.stat.size = 0
-	rng.stat.blocks = 0
-	rng.stat.blksize = 4096
-	rng.stat.rdev = resource.create_dev_id()
-	rng.stat.mode = 0o666 | stat.ifchr
-
-	rng.can_mmap = true
-
-	mut seed := cpu.rdtsc()
-	rng.key[0] = u32(seed)
-	rng.key[2] = u32(seed >> 32)
-	seed = cpu.rdtsc()
-	rng.buffer[0] = u32(seed)
-	rng.buffer[2] = u32(seed >> 32)
-
-	rng.reseed()
-
-	fs.devtmpfs_add_device(rng, 'urandom')
-}
diff --git a/kernel/modules/dev/serial/serial.v b/kernel/modules/dev/serial/serial.v
deleted file mode 100644
index 63401c6..0000000
--- a/kernel/modules/dev/serial/serial.v
+++ /dev/null
@@ -1,206 +0,0 @@
-@[has_globals]
-module serial
-
-import x86.kio
-import klock
-import fs
-import stat
-import event
-import event.eventstruct
-import katomic
-import resource
-import file
-import x86.idt
-import x86.apic
-
-// This are the IO ports where the serial COMs usually appear, this is not
-// guaranteed tho, especially beyond the first 2, so we gotta check them all.
-const com1_port = 0x3f8
-
-const com_ports = [com1_port, 0x2f8, 0x3e8, 0x2e8]
-
-// Serial devices share IRQs in pairs, COM1/3 use IRQ 4, COM2/4 use IRQ3
-const com1_3_irq = 4
-
-const com2_4_irq = 3
-
-__global (
-	com1_lock klock.Lock // Lock for COM1 kernel debug reporting.
-)
-
-// Fast initialization of COM1 for early kernel reporting.
-pub fn early_initialise() {
-	initialise_port(com1_port)
-}
-
-// Initialize the rest of ports apart of COM1.
-pub fn initialise() {
-	// Route the COM IRQs to vectors.
-	com1_3_vector := idt.allocate_vector()
-	com2_4_vector := idt.allocate_vector()
-	apic.io_apic_set_irq_redirect(cpu_locals[0].lapic_id, com1_3_vector, com1_3_irq, true)
-	apic.io_apic_set_irq_redirect(cpu_locals[0].lapic_id, com2_4_vector, com2_4_irq, true)
-
-	// Add the hardcoded port 1.
-	mut com1_res := &COMPort{}
-	com1_res.stat.size = 0
-	com1_res.stat.blocks = 0
-	com1_res.stat.blksize = 512
-	com1_res.stat.rdev = resource.create_dev_id()
-	com1_res.stat.mode = 0o644 | stat.ifchr
-	com1_res.status |= file.pollout
-	com1_res.port = com1_port
-	com1_res.port_vector = com1_3_vector
-	fs.devtmpfs_add_device(com1_res, 'com1')
-
-	// Add the rest of ports.
-	for i in 1 .. com_ports.len {
-		port := u16(com_ports[i])
-		success := initialise_port(port)
-		if success {
-			// Construct and add device.
-			mut com_res := &COMPort{}
-			com_res.stat.size = 0
-			com_res.stat.blocks = 0
-			com_res.stat.blksize = 512
-			com_res.stat.rdev = resource.create_dev_id()
-			com_res.stat.mode = 0o644 | stat.ifchr
-			com_res.status |= file.pollout
-			com_res.port = port
-			com_res.port_vector = if i % 2 == 0 { com1_3_vector } else { com2_4_vector }
-			fs.devtmpfs_add_device(com_res, 'com${i + 1}')
-		}
-	}
-}
-
-// Initialize a port.
-fn initialise_port(port u16) bool {
-	// Check if the port exists by writing a value and checking it back.
-	kio.port_out[u8](port + 7, 0x55)
-	if kio.port_in[u8](port + 7) != 0x55 {
-		return false
-	}
-
-	// Enable data available interrupts and enable DLAB.
-	kio.port_out[u8](port + 1, 0x01)
-	kio.port_out[u8](port + 3, 0x80)
-
-	// Set divisor to low 1 hi 0 (115200 baud)
-	kio.port_out[u8](port + 0, 0x01)
-	kio.port_out[u8](port + 1, 0x00)
-
-	// Enable FIFO and interrupts
-	kio.port_out[u8](port + 3, 0x03)
-	kio.port_out[u8](port + 2, 0xc7)
-	kio.port_out[u8](port + 4, 0x0b)
-	return true
-}
-
-// Kernel reporting to COM1.
-pub fn out(value u8) {
-	com1_lock.acquire()
-	if value == `\n` {
-		for !is_transmiter_empty(com1_port) {}
-		kio.port_out[u8](com1_port, `\r`)
-	}
-	for !is_transmiter_empty(com1_port) {}
-	kio.port_out[u8](com1_port, value)
-	com1_lock.release()
-}
-
-// Unlocked COM1 reporting.
-@[markused]
-pub fn panic_out(value u8) {
-	if value == `\n` {
-		for !is_transmiter_empty(com1_port) {}
-		kio.port_out[u8](com1_port, `\r`)
-	}
-	for !is_transmiter_empty(com1_port) {}
-	kio.port_out[u8](com1_port, value)
-}
-
-fn is_transmiter_empty(port u16) bool {
-	return kio.port_in[u8](port + 5) & 0b01000000 != 0
-}
-
-fn is_data_received(port u16) bool {
-	return kio.port_in[u8](port + 5) & 0b00000001 != 0
-}
-
-// Resource functions for serial COMPort s
-struct COMPort {
-pub mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	event    eventstruct.Event
-	status   int
-	can_mmap bool
-
-	port        u16
-	port_vector int
-}
-
-fn (mut this COMPort) mmap(page u64, flags int) voidptr {
-	return 0
-}
-
-fn (mut this COMPort) read(handle voidptr, void_buf voidptr, loc u64, count u64) ?i64 {
-	this.l.acquire()
-	defer {
-		this.l.release()
-	}
-
-	// Wait on the event of the port's IRQ.
-	mut data := &u8(void_buf)
-	mut events := [&int_events[this.port_vector]]
-	defer {
-		unsafe { events.free() }
-	}
-	for i := u64(0); i < count; {
-		if is_data_received(this.port) {
-			val := kio.port_in[u8](this.port)
-			unsafe {
-				data[i] = val
-			}
-			i++
-		} else {
-			event.await(mut events, true) or {}
-		}
-	}
-
-	return i64(count)
-}
-
-fn (mut this COMPort) write(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	this.l.acquire()
-	defer {
-		this.l.release()
-	}
-	mut data := &u8(buf)
-	for i in 0 .. count {
-		for !is_transmiter_empty(this.port) {}
-		kio.port_out[u8](this.port, unsafe { data[i] })
-	}
-	return i64(count)
-}
-
-fn (mut this COMPort) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	return resource.default_ioctl(handle, request, argp)
-}
-
-fn (mut this COMPort) unref(handle voidptr) ? {
-	katomic.dec(mut &this.refcount)
-}
-
-fn (mut this COMPort) link(handle voidptr) ? {
-	katomic.inc(mut &this.stat.nlink)
-}
-
-fn (mut this COMPort) unlink(handle voidptr) ? {
-	katomic.dec(mut &this.stat.nlink)
-}
-
-fn (mut this COMPort) grow(handle voidptr, new_size u64) ? {
-	return none
-}
diff --git a/kernel/modules/dev/streams/streams.v b/kernel/modules/dev/streams/streams.v
deleted file mode 100644
index 4f53a0a..0000000
--- a/kernel/modules/dev/streams/streams.v
+++ /dev/null
@@ -1,191 +0,0 @@
-module streams
-
-import resource
-import fs
-import stat
-import klock
-import event.eventstruct
-import memory
-import errno
-import katomic
-
-// ***************
-// ** /dev/null **
-// ***************
-struct DevNull {
-mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	event    eventstruct.Event
-	status   int
-	can_mmap bool
-}
-
-fn (mut this DevNull) mmap(page u64, flags int) voidptr {
-	panic('')
-}
-
-fn (mut this DevNull) read(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	return 0
-}
-
-fn (mut this DevNull) write(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	return i64(count)
-}
-
-fn (mut this DevNull) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	return resource.default_ioctl(handle, request, argp)
-}
-
-fn (mut this DevNull) unref(handle voidptr) ? {
-	katomic.dec(mut &this.refcount)
-}
-
-fn (mut this DevNull) link(handle voidptr) ? {
-	katomic.inc(mut &this.stat.nlink)
-}
-
-fn (mut this DevNull) unlink(handle voidptr) ? {
-	katomic.dec(mut &this.stat.nlink)
-}
-
-fn (mut this DevNull) grow(handle voidptr, new_size u64) ? {
-}
-
-fn init_null() {
-	mut devnull := &DevNull{}
-
-	devnull.stat.size = 0
-	devnull.stat.blocks = 0
-	devnull.stat.blksize = 4096
-	devnull.stat.rdev = resource.create_dev_id()
-	devnull.stat.mode = 0o666 | stat.ifchr
-
-	fs.devtmpfs_add_device(devnull, 'null')
-}
-
-// ***************
-// ** /dev/zero **
-// ***************
-struct DevZero {
-mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	event    eventstruct.Event
-	status   int
-	can_mmap bool
-}
-
-fn (mut this DevZero) mmap(page u64, flags int) voidptr {
-	return memory.pmm_alloc(1)
-}
-
-fn (mut this DevZero) read(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	unsafe { C.memset(buf, 0, count) }
-	return i64(count)
-}
-
-fn (mut this DevZero) write(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	return i64(count)
-}
-
-fn (mut this DevZero) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	return resource.default_ioctl(handle, request, argp)
-}
-
-fn (mut this DevZero) unref(handle voidptr) ? {
-	katomic.dec(mut &this.refcount)
-}
-
-fn (mut this DevZero) link(handle voidptr) ? {
-	katomic.inc(mut &this.stat.nlink)
-}
-
-fn (mut this DevZero) unlink(handle voidptr) ? {
-	katomic.dec(mut &this.stat.nlink)
-}
-
-fn (mut this DevZero) grow(handle voidptr, new_size u64) ? {
-}
-
-fn init_zero() {
-	mut devzero := &DevZero{}
-
-	devzero.stat.size = 0
-	devzero.stat.blocks = 0
-	devzero.stat.blksize = 4096
-	devzero.stat.rdev = resource.create_dev_id()
-	devzero.stat.mode = 0o666 | stat.ifchr
-
-	devzero.can_mmap = true
-
-	fs.devtmpfs_add_device(devzero, 'zero')
-}
-
-// ***************
-// ** /dev/full **
-// ***************
-struct DevFull {
-mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	event    eventstruct.Event
-	status   int
-	can_mmap bool
-}
-
-fn (mut this DevFull) mmap(page u64, flags int) voidptr {
-	return memory.pmm_alloc(1)
-}
-
-fn (mut this DevFull) read(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	unsafe { C.memset(buf, 0, count) }
-	return i64(count)
-}
-
-fn (mut this DevFull) write(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	errno.set(errno.enospc)
-	return none
-}
-
-fn (mut this DevFull) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	return resource.default_ioctl(handle, request, argp)
-}
-
-fn (mut this DevFull) unref(handle voidptr) ? {
-	katomic.dec(mut &this.refcount)
-}
-
-fn (mut this DevFull) link(handle voidptr) ? {
-	katomic.inc(mut &this.stat.nlink)
-}
-
-fn (mut this DevFull) unlink(handle voidptr) ? {
-	katomic.dec(mut &this.stat.nlink)
-}
-
-fn (mut this DevFull) grow(handle voidptr, new_size u64) ? {
-}
-
-fn init_full() {
-	mut devfull := &DevFull{}
-
-	devfull.stat.size = 0
-	devfull.stat.blocks = 0
-	devfull.stat.blksize = 4096
-	devfull.stat.rdev = resource.create_dev_id()
-	devfull.stat.mode = 0o666 | stat.ifchr
-
-	devfull.can_mmap = true
-
-	fs.devtmpfs_add_device(devfull, 'full')
-}
-
-pub fn initialise() {
-	init_null()
-	init_zero()
-	init_full()
-}
diff --git a/kernel/modules/elf/elf.v b/kernel/modules/elf/elf.v
deleted file mode 100644
index 8dc82f3..0000000
--- a/kernel/modules/elf/elf.v
+++ /dev/null
@@ -1,167 +0,0 @@
-module elf
-
-import lib
-import memory
-import memory.mmap
-import resource
-
-pub struct Auxval {
-pub mut:
-	at_entry u64
-	at_phdr  u64
-	at_phent u64
-	at_phnum u64
-}
-
-pub const et_dyn = 0x03
-
-pub const at_entry = 9
-pub const at_phdr = 3
-pub const at_phent = 4
-pub const at_phnum = 5
-pub const at_secure = 23
-
-pub const pt_load = 0x00000001
-pub const pt_interp = 0x00000003
-pub const pt_phdr = 0x00000006
-
-pub const abi_sysv = 0x00
-pub const arch_x86_64 = 0x3e
-pub const bits_le = 0x01
-
-pub const ei_class = 4
-pub const ei_data = 5
-pub const ei_version = 6
-pub const ei_osabi = 7
-
-pub struct Header {
-pub mut:
-	ident     [16]u8
-	@type     u16
-	machine   u16
-	version   u32
-	entry     u64
-	phoff     u64
-	shoff     u64
-	flags     u32
-	hdr_size  u16
-	phdr_size u16
-	ph_num    u16
-	shdr_size u16
-	sh_num    u16
-	shstrndx  u16
-}
-
-pub const pf_x = 1
-pub const pf_w = 2
-pub const pf_r = 4
-
-pub struct ProgramHdr {
-pub mut:
-	p_type   u32
-	p_flags  u32
-	p_offset u64
-	p_vaddr  u64
-	p_paddr  u64
-	p_filesz u64
-	p_memsz  u64
-	p_align  u64
-}
-
-pub struct SectionHdr {
-pub mut:
-	sh_name       u32
-	sh_type       u32
-	sh_flags      u64
-	sh_addr       u64
-	sh_offset     u64
-	sh_size       u64
-	sh_link       u32
-	sh_info       u32
-	sh_addr_align u64
-	sh_entsize    u64
-}
-
-pub fn load(_pagemap &memory.Pagemap, _res &resource.Resource, base u64) !(Auxval, string) {
-	mut res := unsafe { _res }
-	mut pagemap := unsafe { _pagemap }
-
-	mut header := &Header{}
-
-	res.read(0, header, 0, sizeof(Header)) or { return error('') }
-
-	if unsafe { C.memcmp(&header.ident, c'\177ELF', 4) } != 0 {
-		return error('elf: Invalid magic')
-	}
-
-	if header.ident[ei_class] != 0x02 || header.ident[ei_data] != bits_le
-		|| header.ident[ei_osabi] != abi_sysv || header.machine != arch_x86_64 {
-		return error('elf: Unsupported ELF file')
-	}
-
-	mut slide := u64(0)
-	if header.@type == et_dyn {
-		slide = 0x400000
-	}
-
-	mut auxval := Auxval{
-		at_entry: base + header.entry + slide
-		at_phdr:  0
-		at_phent: sizeof(ProgramHdr)
-		at_phnum: header.ph_num
-	}
-
-	mut ld_path := ''
-
-	for i := u64(0); i < header.ph_num; i++ {
-		mut phdr := &ProgramHdr{}
-
-		res.read(0, phdr, header.phoff + (sizeof(ProgramHdr) * i), sizeof(ProgramHdr)) or {
-			return error('')
-		}
-
-		match phdr.p_type {
-			pt_interp {
-				mut p := unsafe { malloc(phdr.p_filesz + 1) }
-				res.read(0, p, phdr.p_offset, phdr.p_filesz) or { return error('') }
-				ld_path = unsafe { cstring_to_vstring(p) }
-				unsafe { free(p) }
-			}
-			pt_phdr {
-				auxval.at_phdr = base + phdr.p_vaddr + slide
-			}
-			else {}
-		}
-
-		if phdr.p_type != pt_load {
-			continue
-		}
-
-		misalign := phdr.p_vaddr & (page_size - 1)
-		page_count := lib.div_roundup(misalign + phdr.p_memsz, page_size)
-
-		addr := memory.pmm_alloc(page_count)
-		if addr == 0 {
-			return error('elf: Allocation failure')
-		}
-
-		pf := mmap.prot_read | mmap.prot_exec | if phdr.p_flags & pf_w != 0 {
-			mmap.prot_write
-		} else {
-			0
-		}
-
-		virt := lib.align_down(base + phdr.p_vaddr + slide, page_size)
-		phys := u64(addr)
-
-		mmap.map_range(mut pagemap, virt, phys, page_count * page_size, pf, mmap.map_anonymous) or {
-			return error('')
-		}
-
-		buf := unsafe { byteptr(addr) + misalign + higher_half }
-
-		res.read(0, buf, phdr.p_offset, phdr.p_filesz) or { return error('') }
-	}
-
-	return auxval, ld_path
-}
diff --git a/kernel/modules/errno/errno.v b/kernel/modules/errno/errno.v
deleted file mode 100644
index 777938e..0000000
--- a/kernel/modules/errno/errno.v
+++ /dev/null
@@ -1,148 +0,0 @@
-module errno
-
-import proc
-
-pub const err = u64(-1)
-
-pub const eperm = 1
-pub const enoent = 2
-pub const esrch = 3
-pub const eintr = 4
-pub const eio = 5
-pub const enxio = 6
-pub const e2big = 7
-pub const enoexec = 8
-pub const ebadf = 9
-pub const echild = 10
-pub const eagain = 11
-pub const enomem = 12
-pub const eacces = 13
-pub const efault = 14
-pub const enotblk = 15
-pub const ebusy = 16
-pub const eexist = 17
-pub const exdev = 18
-pub const enodev = 19
-pub const enotdir = 20
-pub const eisdir = 21
-pub const einval = 22
-pub const enfile = 23
-pub const emfile = 24
-pub const enotty = 25
-pub const etxtbsy = 26
-pub const efbig = 27
-pub const enospc = 28
-pub const espipe = 29
-pub const erofs = 30
-pub const emlink = 31
-pub const epipe = 32
-pub const edom = 33
-pub const erange = 34
-pub const edeadlk = 35
-pub const enametoolong = 36
-pub const enolck = 37
-pub const enosys = 38
-pub const enotempty = 39
-pub const eloop = 40
-pub const ewouldblock = eagain
-pub const enomsg = 42
-pub const eidrm = 43
-pub const echrng = 44
-pub const el2nsync = 45
-pub const el3hlt = 46
-pub const el3rst = 47
-pub const elnrng = 48
-pub const eunatch = 49
-pub const enocsi = 50
-pub const el2hlt = 51
-pub const ebade = 52
-pub const ebadr = 53
-pub const exfull = 54
-pub const enoano = 55
-pub const ebadrqc = 56
-pub const ebadslt = 57
-pub const edeadlock = edeadlk
-pub const ebfont = 59
-pub const enostr = 60
-pub const enodata = 61
-pub const etime = 62
-pub const enosr = 63
-pub const enonet = 64
-pub const enopkg = 65
-pub const eremote = 66
-pub const enolink = 67
-pub const eadv = 68
-pub const esrmnt = 69
-pub const ecomm = 70
-pub const eproto = 71
-pub const emultihop = 72
-pub const edotdot = 73
-pub const ebadmsg = 74
-pub const eoverflow = 75
-pub const enotuniq = 76
-pub const ebadfd = 77
-pub const eremchg = 78
-pub const elibacc = 79
-pub const elibbad = 80
-pub const elibscn = 81
-pub const elibmax = 82
-pub const elibexec = 83
-pub const eilseq = 84
-pub const erestart = 85
-pub const estrpipe = 86
-pub const eusers = 87
-pub const enotsock = 88
-pub const edestaddrreq = 89
-pub const emsgsize = 90
-pub const eprototype = 91
-pub const enoprotoopt = 92
-pub const eprotonosupport = 93
-pub const esocktnosupport = 94
-pub const eopnotsupp = 95
-pub const enotsup = eopnotsupp
-pub const epfnosupport = 96
-pub const eafnosupport = 97
-pub const eaddrinuse = 98
-pub const eaddrnotavail = 99
-pub const enetdown = 100
-pub const enetunreach = 101
-pub const enetreset = 102
-pub const econnaborted = 103
-pub const econnreset = 104
-pub const enobufs = 105
-pub const eisconn = 106
-pub const enotconn = 107
-pub const eshutdown = 108
-pub const etoomanyrefs = 109
-pub const etimedout = 110
-pub const econnrefused = 111
-pub const ehostdown = 112
-pub const ehostunreach = 113
-pub const ealready = 114
-pub const einprogress = 115
-pub const estale = 116
-pub const euclean = 117
-pub const enotnam = 118
-pub const enavail = 119
-pub const eisnam = 120
-pub const eremoteio = 121
-pub const edquot = 122
-pub const enomedium = 123
-pub const emediumtype = 124
-pub const ecanceled = 125
-pub const enokey = 126
-pub const ekeyexpired = 127
-pub const ekeyrevoked = 128
-pub const ekeyrejected = 129
-pub const eownerdead = 130
-pub const enotrecoverable = 131
-pub const erfkill = 132
-pub const ehwpoison = 133
-
-pub fn get() u64 {
-	return proc.current_thread().errno
-}
-
-pub fn set(err_no u64) {
-	proc.current_thread().errno = err_no
-}
diff --git a/kernel/modules/event/event.v b/kernel/modules/event/event.v
deleted file mode 100644
index 207dfff..0000000
--- a/kernel/modules/event/event.v
+++ /dev/null
@@ -1,209 +0,0 @@
-@[has_globals]
-module event
-
-import proc
-import sched
-import event.eventstruct
-import x86.cpu
-import x86.cpu.local as cpulocal
-import katomic
-
-__global (
-	waiting_event_count = u64(0)
-)
-
-fn check_for_pending(mut events []&eventstruct.Event) ?u64 {
-	for i := u64(0); i < events.len; i++ {
-		if events[i].pending > 0 {
-			events[i].pending--
-			return i
-		}
-	}
-
-	return none
-}
-
-fn attach_listeners(mut events []&eventstruct.Event, mut t proc.Thread) {
-	t.attached_events_i = 0
-
-	for i := u64(0); i < events.len; i++ {
-		mut e := events[i]
-
-		if e.listeners_i == eventstruct.max_listeners {
-			panic('event listeners exhausted')
-		}
-
-		mut listener := &e.listeners[e.listeners_i]
-
-		listener.thrd = voidptr(t)
-		listener.which = i
-
-		e.listeners_i++
-
-		if t.attached_events_i == proc.max_events {
-			panic('listening on too many events')
-		}
-
-		t.attached_events[t.attached_events_i] = e
-		t.attached_events_i++
-	}
-}
-
-fn detach_listeners(mut t proc.Thread) {
-	for i := u64(0); i < t.attached_events_i; i++ {
-		mut e := t.attached_events[i]
-
-		for j := u64(0); j < e.listeners_i; j++ {
-			mut listener := &e.listeners[j]
-
-			if listener.thrd != voidptr(t) {
-				continue
-			}
-
-			e.listeners[j] = e.listeners[e.listeners_i - 1]
-			e.listeners_i--
-
-			break
-		}
-	}
-
-	t.attached_events_i = 0
-}
-
-fn lock_events(mut events []&eventstruct.Event) {
-	for mut e in events {
-		e.@lock.acquire()
-	}
-}
-
-fn unlock_events(mut events []&eventstruct.Event) {
-	for mut e in events {
-		e.@lock.release()
-	}
-}
-
-pub fn await(mut events []&eventstruct.Event, block bool) ?u64 {
-	mut t := proc.current_thread()
-
-	asm volatile amd64 {
-		cli
-	}
-	defer {
-		asm volatile amd64 {
-			sti
-		}
-	}
-
-	lock_events(mut events)
-
-	if i := check_for_pending(mut events) {
-		unlock_events(mut events)
-		return i
-	}
-
-	if block == false {
-		unlock_events(mut events)
-		return none
-	}
-
-	katomic.inc(mut &waiting_event_count)
-
-	attach_listeners(mut events, mut t)
-	defer {
-		asm volatile amd64 {
-			cli
-		}
-		lock_events(mut events)
-		detach_listeners(mut t)
-		unlock_events(mut events)
-		asm volatile amd64 {
-			sti
-		}
-	}
-
-	sched.dequeue_thread(t)
-
-	unlock_events(mut events)
-
-	sched.yield(true)
-
-	katomic.dec(mut &waiting_event_count)
-
-	if t.enqueued_by_signal {
-		return none
-	}
-
-	return t.which_event
-}
-
-pub fn trigger(mut e eventstruct.Event, drop bool) u64 {
-	ints := cpu.interrupt_state()
-
-	asm volatile amd64 {
-		cli
-	}
-	defer {
-		if ints == true {
-			asm volatile amd64 {
-				sti
-			}
-		}
-	}
-
-	e.@lock.acquire()
-	defer {
-		e.@lock.release()
-	}
-
-	if e.listeners_i == 0 {
-		if drop == false {
-			e.pending++
-		}
-		return 0
-	}
-
-	for i := u64(0); i < e.listeners_i; i++ {
-		mut t := unsafe { &proc.Thread(e.listeners[i].thrd) }
-
-		t.which_event = e.listeners[i].which
-
-		sched.enqueue_thread(t, false)
-	}
-
-	ret := e.listeners_i
-
-	e.listeners_i = 0
-
-	return ret
-}
-
-pub fn pthread_exit(ret voidptr) {
-	asm volatile amd64 {
-		cli
-	}
-
-	mut cpu_local := cpulocal.current()
-
-	mut current_thread := proc.current_thread()
-
-	sched.dequeue_thread(current_thread)
-
-	cpu.set_gs_base(u64(&cpu_local.cpu_number))
-	cpu.set_kernel_gs_base(u64(current_thread))
-
-	current_thread.exit_value = ret
-	trigger(mut current_thread.exited, false)
-
-	sched.yield(false)
-}
-
-pub fn pthread_wait(t &proc.Thread) voidptr {
-	mut events := [&t.exited]
-	await(mut events, true) or {}
-	exit_value := t.exit_value
-	unsafe {
-		free(t)
-		events.free()
-	}
-	return exit_value
-}
diff --git a/kernel/modules/event/eventstruct/eventstruct.v b/kernel/modules/event/eventstruct/eventstruct.v
deleted file mode 100644
index 4ddd282..0000000
--- a/kernel/modules/event/eventstruct/eventstruct.v
+++ /dev/null
@@ -1,19 +0,0 @@
-module eventstruct
-
-import klock
-
-pub const max_listeners = 32
-
-pub struct EventListener {
-pub mut:
-	thrd  voidptr
-	which u64
-}
-
-pub struct Event {
-pub mut:
-	@lock       klock.Lock
-	pending     u64
-	listeners_i u64
-	listeners   [max_listeners]EventListener
-}
diff --git a/kernel/modules/file/file.v b/kernel/modules/file/file.v
deleted file mode 100644
index 618a923..0000000
--- a/kernel/modules/file/file.v
+++ /dev/null
@@ -1,476 +0,0 @@
-module file
-
-import resource
-import proc
-import klock
-import katomic
-import errno
-import stat
-import event
-import event.eventstruct
-import memory.mmap
-import time
-
-pub const f_dupfd = 0
-pub const f_dupfd_cloexec = 1030
-pub const f_getfd = 1
-pub const f_setfd = 2
-pub const f_getfl = 3
-pub const f_setfl = 4
-pub const f_getlk = 5
-pub const f_setlk = 6
-pub const f_setlkw = 7
-pub const f_getown = 8
-pub const f_setown = 9
-
-pub const fd_cloexec = 1
-
-pub struct Handle {
-pub mut:
-	l             klock.Lock
-	resource      &resource.Resource = unsafe { nil }
-	node          voidptr
-	refcount      int
-	loc           i64
-	flags         int
-	dirlist_valid bool
-	dirlist       []stat.Dirent
-	dirlist_index u64
-}
-
-struct PollFD {
-mut:
-	fd      int
-	events  i16
-	revents i16
-}
-
-pub const pollin = 0x01
-pub const pollout = 0x04
-pub const pollpri = 0x02
-pub const pollhup = 0x10
-pub const pollerr = 0x08
-pub const pollrdhup = 0x2000
-pub const pollnval = 0x20
-pub const pollwrnorm = 0x100
-
-pub fn syscall_ppoll(_ voidptr, fds &PollFD, nfds u64, tmo_p &time.TimeSpec, sigmask &u64) (u64, u64) {
-	mut t := proc.current_thread()
-	mut process := t.process
-
-	C.printf(c'\n\e[32m%s\e[m: ppoll(0x%llx, %llu, 0x%llx, 0x%llx)\n', process.name.str,
-		voidptr(fds), nfds, voidptr(tmo_p), voidptr(sigmask))
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	if nfds == 0 {
-		return 0, 0
-	}
-
-	oldmask := t.masked_signals
-	if voidptr(sigmask) != unsafe { nil } {
-		t.masked_signals = *sigmask
-	}
-	defer {
-		t.masked_signals = oldmask
-	}
-
-	mut fdlist := []&FD{}
-	mut fdnums := []u64{}
-	mut events := []&eventstruct.Event{}
-
-	defer {
-		for mut f in fdlist {
-			f.unref()
-		}
-		unsafe {
-			events.free()
-			fdnums.free()
-			fdlist.free()
-		}
-	}
-
-	mut ret := u64(0)
-
-	C.printf(c'Polling on %d FDs\n', nfds)
-
-	for i := u64(0); i < nfds; i++ {
-		mut fdd := unsafe { &fds[i] }
-
-		fdd.revents = 0
-
-		C.printf(c'fdnum %d, events %llx\n', fdd.fd, fdd.events)
-
-		if fdd.fd < 0 {
-			continue
-		}
-
-		mut fd := fd_from_fdnum(unsafe { nil }, fdd.fd) or {
-			fdd.revents = pollnval
-			ret++
-			continue
-		}
-
-		mut resource_ := fd.handle.resource
-
-		status := resource_.status
-
-		if i16(status) & fdd.events != 0 {
-			fdd.revents = i16(status) & fdd.events
-			C.printf(c'Poll detected event on fdnum %d, events %llx\n', fdd.fd, fdd.events)
-			ret++
-			fd.unref()
-			continue
-		}
-
-		fdlist << fd
-		fdnums << i
-		events << &resource_.event
-	}
-
-	if ret != 0 {
-		return ret, 0
-	}
-
-	mut timer := &time.Timer(unsafe { nil })
-
-	if voidptr(tmo_p) != unsafe { nil } {
-		mut target_time := *tmo_p
-
-		timer = time.new_timer(target_time)
-
-		events << &timer.event
-	}
-
-	defer {
-		if voidptr(timer) != unsafe { nil } {
-			timer.disarm()
-			unsafe { free(timer) }
-		}
-	}
-
-	for {
-		which := event.await(mut events, true) or { return errno.err, errno.eintr }
-
-		if voidptr(timer) != unsafe { nil } {
-			if which == u64(events.len) - 1 {
-				return 0, 0
-			}
-		}
-
-		status := fdlist[which].handle.resource.status
-
-		mut fdd := unsafe { &fds[fdnums[which]] }
-
-		if i16(status) & fdd.events != 0 {
-			C.printf(c'Poll exiting on fdnum %d, events %llx\n', fdd.fd, fdd.events)
-
-			fdd.revents = 0
-			fdd.revents = i16(status) & fdd.events
-			ret++
-			break
-		}
-	}
-
-	return ret, 0
-}
-
-pub fn (mut this Handle) read(buf voidptr, count u64) ?i64 {
-	this.l.acquire()
-	defer {
-		this.l.release()
-	}
-	ret := this.resource.read(voidptr(this), buf, u64(this.loc), count) or { return none }
-	this.loc += ret
-	return ret
-}
-
-pub fn (mut this Handle) write(buf voidptr, count u64) ?i64 {
-	this.l.acquire()
-	defer {
-		this.l.release()
-	}
-	ret := this.resource.write(voidptr(this), buf, u64(this.loc), count) or { return none }
-	this.loc += ret
-	return ret
-}
-
-pub fn (mut this Handle) ioctl(request u64, argp voidptr) ?int {
-	return this.resource.ioctl(voidptr(this), request, argp)
-}
-
-pub struct FD {
-pub mut:
-	handle &Handle = unsafe { nil }
-	flags  int
-}
-
-pub fn (mut this FD) unref() {
-	this.handle.refcount--
-}
-
-pub fn fdnum_close(_process &proc.Process, fdnum int, do_lock bool) ? {
-	mut process := &proc.Process(unsafe { nil })
-	if voidptr(_process) == unsafe { nil } {
-		process = proc.current_thread().process
-	} else {
-		process = unsafe { _process }
-	}
-
-	if fdnum >= proc.max_fds {
-		errno.set(errno.ebadf)
-		return none
-	}
-
-	if do_lock {
-		process.fds_lock.acquire()
-	}
-	defer {
-		if do_lock {
-			process.fds_lock.release()
-		}
-	}
-
-	mut fd := unsafe { &FD(process.fds[fdnum]) }
-	if fd == unsafe { nil } {
-		errno.set(errno.ebadf)
-		return none
-	}
-
-	mut handle := fd.handle
-	mut res := handle.resource
-
-	res.unref(voidptr(handle))?
-
-	handle.refcount--
-	if handle.refcount == 0 {
-		unsafe { free(voidptr(handle)) }
-	}
-
-	unsafe { free(voidptr(fd)) }
-
-	process.fds[fdnum] = unsafe { nil }
-}
-
-pub fn fdnum_create_from_fd(_process &proc.Process, fd &FD, oldfd int, specific bool) ?int {
-	mut process := &proc.Process(unsafe { nil })
-	if voidptr(_process) == unsafe { nil } {
-		process = proc.current_thread().process
-	} else {
-		process = unsafe { _process }
-	}
-
-	process.fds_lock.acquire()
-	defer {
-		process.fds_lock.release()
-	}
-
-	if specific == false {
-		for i := oldfd; i < proc.max_fds; i++ {
-			if process.fds[i] == unsafe { nil } {
-				process.fds[i] = voidptr(fd)
-				return i
-			}
-		}
-		return none
-	} else {
-		fdnum_close(process, oldfd, false) or {}
-		process.fds[oldfd] = voidptr(fd)
-		return oldfd
-	}
-}
-
-pub fn fd_create_from_resource(mut res resource.Resource, flags int) ?&FD {
-	katomic.inc(mut &res.refcount)
-
-	mut new_handle := &Handle{}
-	new_handle.resource = unsafe { res }
-	new_handle.refcount = 1
-	new_handle.flags = flags & resource.file_status_flags_mask
-
-	mut new_fd := &FD{}
-	new_fd.handle = new_handle
-	new_fd.flags = flags & resource.file_descriptor_flags_mask
-
-	return new_fd
-}
-
-pub fn fdnum_create_from_resource(_process &proc.Process, mut res resource.Resource, flags int, oldfd int, specific bool) ?int {
-	new_fd := fd_create_from_resource(mut res, flags) or { return none }
-	return fdnum_create_from_fd(_process, new_fd, oldfd, specific)
-}
-
-pub fn fd_from_fdnum(_process &proc.Process, fdnum int) ?&FD {
-	mut process := &proc.Process(unsafe { nil })
-	if voidptr(_process) == unsafe { nil } {
-		process = proc.current_thread().process
-	} else {
-		process = unsafe { _process }
-	}
-
-	if fdnum >= proc.max_fds || fdnum < 0 {
-		errno.set(errno.ebadf)
-		return none
-	}
-
-	process.fds_lock.acquire()
-	defer {
-		process.fds_lock.release()
-	}
-
-	mut ret := unsafe { &FD(process.fds[fdnum]) }
-	if voidptr(ret) == unsafe { nil } {
-		errno.set(errno.ebadf)
-		return none
-	}
-
-	ret.handle.refcount++
-
-	return ret
-}
-
-pub fn fdnum_dup(_old_process &proc.Process, oldfdnum int, _new_process &proc.Process, newfdnum int, flags int, specific bool, cloexec bool) ?int {
-	mut old_process := &proc.Process(unsafe { nil })
-	if voidptr(_old_process) == unsafe { nil } {
-		old_process = proc.current_thread().process
-	} else {
-		old_process = unsafe { _old_process }
-	}
-
-	mut new_process := &proc.Process(unsafe { nil })
-	if voidptr(_new_process) == unsafe { nil } {
-		new_process = proc.current_thread().process
-	} else {
-		new_process = unsafe { _new_process }
-	}
-
-	if specific && oldfdnum == newfdnum && voidptr(old_process) == voidptr(new_process) {
-		errno.set(errno.einval)
-		return none
-	}
-
-	mut oldfd := fd_from_fdnum(old_process, oldfdnum) or { return none }
-
-	mut new_fd := unsafe { &FD(malloc(sizeof(FD))) }
-	unsafe { C.memcpy(new_fd, oldfd, sizeof(FD)) }
-
-	new_fdnum := fdnum_create_from_fd(new_process, new_fd, newfdnum, specific) or {
-		oldfd.unref()
-		return none
-	}
-
-	new_fd.flags = flags & resource.file_descriptor_flags_mask
-	if cloexec {
-		new_fd.flags &= resource.o_cloexec
-	}
-
-	oldfd.handle.refcount++
-	oldfd.handle.resource.refcount++
-
-	return new_fdnum
-}
-
-pub fn syscall_dup3(_ voidptr, oldfdnum int, newfdnum int, flags int) (u64, u64) {
-	mut t := proc.current_thread()
-	mut process := t.process
-
-	C.printf(c'\n\e[32m%s\e[m: dup3(%d, %d, %d)\n', process.name.str, oldfdnum, newfdnum,
-		flags)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	new_fdnum := fdnum_dup(unsafe { nil }, oldfdnum, unsafe { nil }, newfdnum, flags,
-		true, false) or { return errno.err, errno.get() }
-
-	return u64(new_fdnum), 0
-}
-
-pub fn syscall_fcntl(_ voidptr, fdnum int, cmd int, arg u64) (u64, u64) {
-	mut t := proc.current_thread()
-	mut process := t.process
-
-	C.printf(c'\n\e[32m%s\e[m: fcntl(%d, %d, %lld)\n', process.name.str, fdnum, cmd, arg)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut fd := fd_from_fdnum(unsafe { nil }, fdnum) or { return errno.err, errno.ebadf }
-
-	mut handle := fd.handle
-
-	mut ret := u64(0)
-
-	match cmd {
-		f_dupfd {
-			ret = u64(fdnum_dup(unsafe { nil }, fdnum, unsafe { nil }, int(arg), 0, false,
-				false) or { return errno.err, errno.get() })
-		}
-		f_dupfd_cloexec {
-			ret = u64(fdnum_dup(unsafe { nil }, fdnum, unsafe { nil }, int(arg), 0, false,
-				true) or { return errno.err, errno.get() })
-		}
-		f_getfd {
-			ret = if fd.flags & resource.o_cloexec != 0 { u64(fd_cloexec) } else { 0 }
-			fd.unref()
-		}
-		f_setfd {
-			fd.flags = if arg & fd_cloexec != 0 { resource.o_cloexec } else { 0 }
-			fd.unref()
-		}
-		f_getfl {
-			ret = u64(handle.flags)
-			fd.unref()
-		}
-		f_setfl {
-			handle.flags = int(arg)
-			fd.unref()
-		}
-		else {
-			print('\nfcntl: Unhandled command: ${cmd}\n')
-			fd.unref()
-			return errno.err, errno.einval
-		}
-	}
-
-	return ret, 0
-}
-
-pub fn syscall_mmap(_ voidptr, addr voidptr, length u64, prot_and_flags u64, fdnum int, offset i64) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: mmap(0x%llx, 0x%llx, 0x%llx, %d, %lld)\n', process.name.str,
-		addr, length, prot_and_flags, fdnum, offset)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut resource_ := &resource.Resource(unsafe { nil })
-	mut fd := &FD(unsafe { nil })
-
-	if fdnum != -1 {
-		fd = fd_from_fdnum(unsafe { nil }, fdnum) or { return errno.err, errno.get() }
-		resource_ = fd.handle.resource
-	}
-
-	defer {
-		if fdnum != -1 {
-			fd.unref()
-		}
-	}
-
-	prot := int((prot_and_flags >> 32) & 0xffffffff)
-	flags := int(prot_and_flags & 0xffffffff)
-
-	if flags & mmap.map_anonymous == 0 && voidptr(resource_) == unsafe { nil } {
-		return errno.err, errno.ebadf
-	}
-
-	ret := mmap.mmap(process.pagemap, addr, length, prot, flags, resource_, offset) or {
-		return errno.err, errno.get()
-	}
-
-	return u64(ret), 0
-}
diff --git a/kernel/modules/flanterm/flanterm.v b/kernel/modules/flanterm/flanterm.v
deleted file mode 100644
index b78c92a..0000000
--- a/kernel/modules/flanterm/flanterm.v
+++ /dev/null
@@ -1,22 +0,0 @@
-module flanterm
-
-@[c_extern]
-fn C.flanterm_fb_init(_malloc voidptr, _free voidptr,
-	framebuffer &u32, width u64, height u64, pitch u64,
-	red_mask_size u8, red_mask_shift u8,
-	green_mask_size u8, green_mask_shift u8,
-	blue_mask_size u8, blue_mask_shift u8,
-	canvas &u32,
-	ansi_colours &u32, ansi_bright_colours &u32,
-	default_bg &u32, default_fg &u32,
-	default_bg_bright &u32, default_fg_bright &u32,
-	font voidptr, font_width u64, font_height u64, font_spacing u64,
-	font_scale_x u64, font_scale_y u64,
-	margin u64) voidptr
-
-@[c_extern]
-fn C.flanterm_write(context voidptr, buf charptr, count u64)
-@[c_extern]
-fn C.flanterm_get_dimensions(context voidptr, cols &u64, rows &u64)
-@[c_extern]
-fn C.flanterm_set_callback(context voidptr, callback voidptr)
diff --git a/kernel/modules/fs/devtmpfs.v b/kernel/modules/fs/devtmpfs.v
deleted file mode 100644
index db7493d..0000000
--- a/kernel/modules/fs/devtmpfs.v
+++ /dev/null
@@ -1,261 +0,0 @@
-@[has_globals]
-module fs
-
-import stat
-import klock
-import memory
-import memory.mmap
-import resource
-import lib
-import event.eventstruct
-import katomic
-
-struct DevTmpFSResource {
-pub mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	event    eventstruct.Event
-	status   int
-	can_mmap bool
-
-	storage  &u8
-	capacity u64
-}
-
-fn (mut this DevTmpFSResource) mmap(page u64, flags int) voidptr {
-	this.l.acquire()
-	defer {
-		this.l.release()
-	}
-
-	if flags & mmap.map_shared != 0 {
-		unsafe {
-			return voidptr(u64(&this.storage[page * page_size]) - higher_half)
-		}
-	}
-
-	copy_page := memory.pmm_alloc(1)
-
-	unsafe {
-		C.memcpy(voidptr(u64(copy_page) + higher_half), &this.storage[page * page_size],
-			page_size)
-	}
-
-	return copy_page
-}
-
-fn (mut this DevTmpFSResource) read(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	this.l.acquire()
-
-	mut actual_count := count
-	if loc + count > this.stat.size {
-		actual_count = u64(count - ((loc + count) - this.stat.size))
-	}
-
-	unsafe { C.memcpy(buf, &this.storage[loc], actual_count) }
-
-	this.l.release()
-
-	return i64(actual_count)
-}
-
-fn (mut this DevTmpFSResource) write(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	this.l.acquire()
-
-	if loc + count > this.capacity {
-		mut new_capacity := this.capacity
-
-		for loc + count > new_capacity {
-			new_capacity *= 2
-		}
-
-		new_storage := memory.realloc(this.storage, new_capacity)
-
-		if new_storage == 0 {
-			return none
-		}
-
-		this.storage = new_storage
-		this.capacity = new_capacity
-	}
-
-	unsafe { C.memcpy(&this.storage[loc], buf, count) }
-
-	if loc + count > this.stat.size {
-		this.stat.size = loc + count
-		this.stat.blocks = lib.div_roundup(this.stat.size, this.stat.blksize)
-	}
-
-	this.l.release()
-
-	return i64(count)
-}
-
-fn (mut this DevTmpFSResource) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	return resource.default_ioctl(handle, request, argp)
-}
-
-fn (mut this DevTmpFSResource) unref(handle voidptr) ? {
-	katomic.dec(mut &this.refcount)
-
-	if this.refcount != 0 {
-		return
-	}
-
-	if stat.isreg(this.stat.mode) {
-		memory.free(this.storage)
-	}
-
-	unsafe { free(this) }
-}
-
-fn (mut this DevTmpFSResource) link(handle voidptr) ? {
-	katomic.inc(mut &this.stat.nlink)
-}
-
-fn (mut this DevTmpFSResource) unlink(handle voidptr) ? {
-	katomic.dec(mut &this.stat.nlink)
-}
-
-fn (mut this DevTmpFSResource) grow(handle voidptr, new_size u64) ? {
-	this.l.acquire()
-	defer {
-		this.l.release()
-	}
-
-	mut new_capacity := this.capacity
-	for new_size > new_capacity {
-		new_capacity *= 2
-	}
-
-	new_storage := memory.realloc(this.storage, new_capacity)
-
-	if new_storage == 0 {
-		return none
-	}
-
-	this.storage = new_storage
-	this.capacity = new_capacity
-
-	this.stat.size = new_size
-	this.stat.blocks = lib.div_roundup(new_size, u64(this.stat.blksize))
-}
-
-struct DevTmpFS {}
-
-__global (
-	devtmpfs_dev_id        u64
-	devtmpfs_inode_counter u64
-	devtmpfs_root          &VFSNode
-)
-
-fn (this DevTmpFS) instantiate() &FileSystem {
-	new := &DevTmpFS{}
-	return new
-}
-
-fn (this DevTmpFS) populate(node &VFSNode) {}
-
-fn (mut this DevTmpFS) mount(parent &VFSNode, name string, source &VFSNode) ?&VFSNode {
-	if devtmpfs_dev_id == 0 {
-		devtmpfs_dev_id = resource.create_dev_id()
-	}
-	if unsafe { devtmpfs_root == 0 } {
-		// XXX this will break if devtmpfs is mounted more than once
-		devtmpfs_root = this.create(parent, name, 0o644 | stat.ifdir)
-	}
-	return devtmpfs_root
-}
-
-// TODO	should it be maybe `mut parent`? doesn't `create_node` mutate `parent` in `unsafe`(passing it to `mut` field)?
-fn (mut this DevTmpFS) create(parent &VFSNode, name string, mode u32) &VFSNode {
-	mut new_node := create_node(this, parent, name, stat.isdir(mode))
-
-	mut new_resource := &DevTmpFSResource{
-		storage:  unsafe { nil }
-		refcount: 1
-	}
-
-	if stat.isreg(mode) {
-		new_resource.capacity = 4096
-		new_resource.storage = memory.malloc(new_resource.capacity)
-		new_resource.can_mmap = true
-	}
-
-	new_resource.stat.size = 0
-	new_resource.stat.blocks = 0
-	new_resource.stat.blksize = 512
-	new_resource.stat.dev = devtmpfs_dev_id
-	new_resource.stat.ino = devtmpfs_inode_counter++
-	new_resource.stat.mode = mode
-	new_resource.stat.nlink = 1
-
-	new_resource.stat.atim = realtime_clock
-	new_resource.stat.ctim = realtime_clock
-	new_resource.stat.mtim = realtime_clock
-
-	new_node.resource = new_resource
-
-	return new_node
-}
-
-fn (mut this DevTmpFS) link(parent &VFSNode, path string, mut old_node VFSNode) ?&VFSNode {
-	mut new_node := create_node(this, parent, path, false)
-
-	katomic.inc(mut &old_node.resource.refcount)
-
-	new_node.resource = old_node.resource
-	new_node.children = old_node.children
-
-	return new_node
-}
-
-fn (mut this DevTmpFS) symlink(parent &VFSNode, dest string, target string) &VFSNode {
-	mut new_node := create_node(this, parent, target, false)
-
-	mut new_resource := &DevTmpFSResource{
-		storage:  unsafe { nil }
-		refcount: 1
-	}
-
-	new_resource.stat.size = u64(target.len)
-	new_resource.stat.blocks = 0
-	new_resource.stat.blksize = 512
-	new_resource.stat.dev = devtmpfs_dev_id
-	new_resource.stat.ino = devtmpfs_inode_counter++
-	new_resource.stat.mode = stat.iflnk | 0o777
-	new_resource.stat.nlink = 1
-
-	new_resource.stat.atim = realtime_clock
-	new_resource.stat.ctim = realtime_clock
-	new_resource.stat.mtim = realtime_clock
-
-	new_node.resource = new_resource
-
-	new_node.symlink_target = dest
-
-	return new_node
-}
-
-pub fn devtmpfs_add_device(device &resource.Resource, name string) {
-	mut new_node := create_node(unsafe { filesystems['devtmpfs'] }, devtmpfs_root, name,
-		false)
-
-	new_node.resource = unsafe { device }
-	new_node.resource.stat.dev = devtmpfs_dev_id
-	new_node.resource.stat.ino = devtmpfs_inode_counter++
-	new_node.resource.stat.nlink = 1
-
-	new_node.resource.stat.atim = realtime_clock
-	new_node.resource.stat.ctim = realtime_clock
-	new_node.resource.stat.mtim = realtime_clock
-
-	unsafe {
-		devtmpfs_root.children[name] = new_node
-	}
-}
-
-pub fn devtmpfs_get_root() &VFSNode {
-	return devtmpfs_root
-}
diff --git a/kernel/modules/fs/ext2/ext2.v b/kernel/modules/fs/ext2/ext2.v
deleted file mode 100644
index 6db10a1..0000000
--- a/kernel/modules/fs/ext2/ext2.v
+++ /dev/null
@@ -1,965 +0,0 @@
-module ext2
-
-import stat
-import klock
-import resource
-import lib
-import event
-import event.eventstruct
-import memory
-import fs
-
-@[packed]
-struct EXT2Superblock {
-pub mut:
-	inode_cnt          u32
-	block_cnt          u32
-	sb_reserved        u32
-	unallocated_blocks u32
-	unallocated_inodes u32
-	sb_block           u32
-	block_size         u32
-	frag_size          u32
-	blocks_per_group   u32
-	frags_per_group    u32
-	inodes_per_group   u32
-	last_mnt_time      u32
-	last_written_time  u32
-	mnt_cnt            u16
-	mnt_allowed        u16
-	signature          u16
-	fs_state           u16
-	error_response     u16
-	version_min        u16
-	last_fsck          u32
-	forced_fsck        u32
-	os_id              u32
-	version_maj        u32
-	user_id            u16
-	group_id           u16
-
-	first_inode            u32
-	inode_size             u16
-	sb_bgd                 u16
-	opt_features           u32
-	req_features           u32
-	non_supported_features u32
-	uuid                   [2]u64
-	volume_name            [2]u64
-	last_mnt_path          [8]u64
-}
-
-@[packed]
-struct EXT2BlockGroupDescriptor {
-pub mut:
-	block_addr_bitmap  u32
-	block_addr_inode   u32
-	inode_table_block  u32
-	unallocated_blocks u16
-	unallocated_inodes u16
-	dir_cnt            u16
-	reserved           [7]u16
-}
-
-@[packed]
-struct EXT2Inode {
-pub mut:
-	permissions   u16
-	user_id       u16
-	size32l       u32
-	access_time   u32
-	creation_time u32
-	mod_time      u32
-	del_time      u32
-	group_id      u16
-	hard_link_cnt u16
-	sector_cnt    u32
-	flags         u32
-	oss1          u32
-	blocks        [15]u32
-	gen_num       u32
-	eab           u32
-	size32h       u32
-	frag_addr     u32
-}
-
-@[packed]
-struct EXT2DirectoryEntry {
-pub mut:
-	inode_index u32
-	entry_size  u16
-	name_length u8
-	dir_type    u8
-}
-
-struct EXT2Resource {
-pub mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	event    eventstruct.Event
-	status   int
-	can_mmap bool
-
-	filesystem &EXT2Filesystem
-}
-
-fn (mut this EXT2Resource) mmap(page u64, flags int) voidptr {
-	return 0
-}
-
-fn (mut this EXT2Resource) read(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	mut current_inode := &EXT2Inode{}
-
-	current_inode.read_entry(mut this.filesystem, u32(this.stat.ino)) or { return none }
-
-	return current_inode.read(mut this.filesystem, buf, loc, count)
-}
-
-fn (mut this EXT2Resource) write(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	mut current_inode := &EXT2Inode{}
-
-	current_inode.read_entry(mut this.filesystem, u32(this.stat.ino)) or { return none }
-
-	return current_inode.write(mut this.filesystem, buf, u32(this.stat.ino), loc, count)
-}
-
-fn (mut this EXT2Resource) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	return resource.default_ioctl(handle, request, argp)
-}
-
-fn (mut this EXT2Resource) unref(handle voidptr) ? {
-	this.refcount--
-}
-
-fn (mut this EXT2Resource) grow(handle voidptr, new_size u64) ? {
-	this.l.acquire()
-
-	mut current_inode := &EXT2Inode{}
-
-	current_inode.read_entry(mut this.filesystem, u32(this.stat.ino)) or { return none }
-
-	current_inode.resize(mut this.filesystem, u32(this.stat.ino), 0, new_size) or { return none }
-
-	this.l.release()
-}
-
-struct EXT2Filesystem {
-pub mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	event    eventstruct.Event
-	status   int
-	can_mmap bool
-
-	dev_id u64
-
-	superblock &EXT2Superblock
-	root_inode &EXT2Inode
-
-	block_size u64
-	frag_size  u64
-	bgd_cnt    u64
-
-	backing_device &fs.VFSNode
-}
-
-fn (mut this EXT2Filesystem) populate(node &fs.VFSNode) {
-	mut parent := &EXT2Inode{}
-	parent.read_entry(mut this, u32(node.resource.stat.ino)) or { return }
-
-	buffer := &voidptr(memory.calloc(parent.size32l, 1))
-	parent.read(mut this, buffer, 0, parent.size32l) or { return }
-
-	for i := u32(0); i < parent.size32l; {
-		dir_entry := &EXT2DirectoryEntry(u64(buffer) + i)
-
-		name_buffer := memory.calloc(dir_entry.name_length + 1, 1)
-		unsafe {
-			C.memcpy(name_buffer, voidptr(u64(dir_entry) + sizeof(EXT2DirectoryEntry)),
-				u64(dir_entry.name_length))
-		}
-		name := unsafe { tos(&char(name_buffer), dir_entry.name_length) }
-
-		if dir_entry.inode_index == 0 {
-			memory.free(buffer)
-			return
-		}
-
-		mut inode := &EXT2Inode{}
-		inode.read_entry(mut this, dir_entry.inode_index) or { return }
-
-		mut mode := u16(0)
-
-		match dir_entry.dir_type {
-			1 { mode |= stat.ifreg }
-			2 { mode |= stat.ifdir }
-			3 { mode |= stat.ifchr }
-			4 { mode |= stat.ifblk }
-			5 { mode |= stat.ififo }
-			6 { mode |= stat.ifsock }
-			7 { mode |= stat.iflnk }
-			else {}
-		}
-
-		mut vfs_node := fs.create_node(this, node, name, stat.isdir(mode))
-		mut resource := &EXT2Resource{
-			filesystem: unsafe { this }
-		}
-
-		resource.stat.mode = 0o644 | mode
-		resource.stat.ino = dir_entry.inode_index
-		resource.stat.size = inode.size32l | (u64(inode.size32h) >> 32)
-		resource.stat.nlink = inode.hard_link_cnt
-		resource.stat.blksize = this.block_size
-		resource.stat.blocks = lib.div_roundup(resource.stat.size, resource.stat.blksize)
-
-		resource.stat.atim = realtime_clock
-		resource.stat.ctim = realtime_clock
-		resource.stat.mtim = realtime_clock
-
-		vfs_node.resource = resource
-
-		unsafe {
-			vfs_node.parent.children[name] = vfs_node
-		}
-		i += dir_entry.entry_size
-	}
-
-	memory.free(buffer)
-}
-
-fn (mut bro EXT2Filesystem) instantiate() &fs.FileSystem {
-	mut this := &EXT2Filesystem{
-		backing_device: bro.backing_device
-		superblock:     bro.superblock
-		root_inode:     bro.root_inode
-	}
-
-	this.block_size = 1024 << this.superblock.block_size
-	this.frag_size = 1024 << this.superblock.frag_size
-	this.bgd_cnt = lib.div_roundup(this.superblock.block_cnt, this.superblock.blocks_per_group)
-
-	print('ext2: filesystem detected on device ${fs.pathname(this.backing_device)}\n')
-	print('ext2: inode count: ${this.superblock.inode_cnt}\n')
-	print('ext2: inodes per group: ${this.superblock.inodes_per_group:x}\n')
-	print('ext2: block count: ${this.superblock.block_cnt:x}\n')
-	print('ext2: blocks per group: ${this.superblock.blocks_per_group:x}\n')
-	print('ext2: block size: ${this.block_size:x}\n')
-	print('ext2: bgd count: ${this.bgd_cnt:x}\n')
-
-	this.root_inode.read_entry(mut this, 2) or {
-		print('ext2: unable to read root inode\n')
-		return this
-	}
-
-	return this
-}
-
-fn (mut this EXT2Filesystem) symlink(parent &fs.VFSNode, dest string, target string) &fs.VFSNode {
-	mut new_node := fs.create_node(this, parent, target, false)
-
-	mut resource := &EXT2Resource{
-		filesystem: unsafe { this }
-	}
-
-	resource.stat.size = u64(target.len)
-	resource.stat.blocks = 0
-	resource.stat.blksize = 512
-	resource.stat.dev = this.dev_id
-	resource.stat.ino = parent.resource.stat.ino
-	resource.stat.nlink = 1
-
-	resource.stat.atim = realtime_clock
-	resource.stat.ctim = realtime_clock
-	resource.stat.mtim = realtime_clock
-
-	new_node.symlink_target = dest
-	new_node.resource = resource
-
-	return new_node
-}
-
-fn (mut this EXT2Filesystem) create(parent &fs.VFSNode, name string, mode u32) &fs.VFSNode {
-	mut new_node := fs.create_node(this, parent, name, stat.isdir(mode))
-
-	mut resource := &EXT2Resource{
-		filesystem: unsafe { this }
-	}
-
-	resource.stat.size = 0
-	resource.stat.blocks = 0
-	resource.stat.blksize = this.block_size
-	resource.stat.dev = this.dev_id
-	resource.stat.mode = mode
-	resource.stat.nlink = 1
-
-	resource.stat.atim = realtime_clock
-	resource.stat.ctim = realtime_clock
-	resource.stat.mtim = realtime_clock
-
-	resource.stat.ino = this.allocate_inode() or { return 0 }
-
-	mut parent_inode := &EXT2Inode{}
-	parent_inode.read_entry(mut this, u32(parent.resource.stat.ino)) or { return 0 }
-
-	mut file_type := 0
-
-	if stat.isreg(mode) {
-		file_type = 1
-	} else if stat.isdir(mode) {
-		file_type = 2
-	} else if stat.ischr(mode) {
-		file_type = 3
-	} else if stat.isblk(mode) {
-		file_type = 4
-	} else if stat.isifo(mode) {
-		file_type = 5
-	} else if stat.issock(mode) {
-		file_type = 6
-	} else if stat.islnk(mode) {
-		file_type = 7
-	}
-
-	this.dir_create_entry(mut parent_inode, u32(parent.resource.stat.ino), u32(resource.stat.ino),
-		file_type, name) or { return 0 }
-
-	new_node.resource = resource
-
-	return new_node
-}
-
-fn (mut this EXT2Filesystem) mount(parent &fs.VFSNode, name string, source &fs.VFSNode) ?&fs.VFSNode {
-	this.dev_id = resource.create_dev_id()
-
-	mut target := fs.create_node(this, parent, name, true)
-
-	mut resource := &EXT2Resource{
-		filesystem: unsafe { this }
-	}
-
-	resource.stat.size = this.root_inode.size32l | (u64(this.root_inode.size32h) >> 32)
-	resource.stat.blksize = this.block_size
-	resource.stat.blocks = lib.div_roundup(resource.stat.size, resource.stat.blksize)
-	resource.stat.dev = this.dev_id
-	resource.stat.mode = 0o644 | stat.ifdir
-	resource.stat.nlink = this.root_inode.hard_link_cnt
-	resource.stat.ino = 2
-
-	resource.stat.atim = realtime_clock
-	resource.stat.ctim = realtime_clock
-	resource.stat.mtim = realtime_clock
-
-	target.filesystem = unsafe { this }
-	target.resource = resource
-
-	this.populate(target)
-
-	return target
-}
-
-fn (mut fs EXT2Filesystem) dir_create_entry(mut parent EXT2Inode, parent_inode_index u32, new_inode u32, dir_type u8, name string) ?int {
-	buffer := &voidptr(memory.calloc(parent.size32l, 1))
-	parent.read(mut fs, buffer, 0, parent.size32l) or { return none }
-
-	mut found := false
-
-	for i := u32(0); i < parent.size32l; {
-		mut dir_entry := &EXT2DirectoryEntry(u64(buffer) + i)
-
-		if found == true {
-			dir_entry.inode_index = new_inode
-			dir_entry.dir_type = dir_type
-			dir_entry.name_length = name.len
-			dir_entry.entry_size = u16(parent.size32l - i)
-
-			unsafe {
-				C.memcpy(voidptr(u64(dir_entry) + sizeof(EXT2DirectoryEntry)), name.str,
-					name.len)
-			}
-
-			parent.write(mut fs, buffer, parent_inode_index, 0, parent.size32l) or { return none }
-
-			return 0
-		}
-
-		expected_size := lib.align_up(sizeof(EXT2DirectoryEntry) + dir_entry.name_length,
-			4)
-		if dir_entry.entry_size != expected_size {
-			dir_entry.entry_size = u16(expected_size)
-			i += u32(expected_size)
-
-			found = true
-
-			continue
-		}
-
-		i += dir_entry.entry_size
-	}
-
-	memory.free(buffer)
-
-	return none
-}
-
-fn (mut inode EXT2Inode) read(mut fs &EXT2Filesystem, buf voidptr, off u64, cnt u64) ?i64 {
-	mut count := cnt
-
-	if off > inode.size32l {
-		return 0
-	}
-
-	if (off + count) > inode.size32l {
-		count = inode.size32l - off
-	}
-
-	for headway := u64(0); headway < count; {
-		iblock := (off + headway) / fs.block_size
-
-		mut size := count - headway
-		offset := (off + headway) % fs.block_size
-
-		if size > (fs.block_size - offset) {
-			size = fs.block_size - offset
-		}
-
-		disk_block := inode.get_block(mut fs, u32(iblock)) or { return none }
-
-		fs.raw_device_read(voidptr(u64(buf) + headway), disk_block * fs.block_size + offset,
-			size) or { return none }
-
-		headway += size
-	}
-
-	return i64(count)
-}
-
-fn (mut inode EXT2Inode) resize(mut fs &EXT2Filesystem, inode_index u32, start u64, cnt u64) ?int {
-	sector_size := fs.backing_device.resource.stat.blksize
-
-	if (start + cnt) < (inode.sector_cnt * sector_size) {
-		return 0
-	}
-
-	iblock_start := lib.div_roundup(inode.sector_cnt * sector_size, fs.block_size)
-	iblock_end := lib.div_roundup(start + cnt, fs.block_size)
-
-	if inode.size32l < (start + cnt) {
-		inode.size32l = u32(start + cnt)
-	}
-
-	for i := iblock_start; i < iblock_end; i++ {
-		disk_block := fs.allocate_block() or { return none }
-
-		inode.sector_cnt = u32(fs.block_size / sector_size)
-
-		inode.set_block(mut fs, inode_index, u32(i), disk_block) or { return none }
-	}
-
-	inode.write_entry(mut fs, inode_index) or { return none }
-
-	return 0
-}
-
-fn (mut inode EXT2Inode) write(mut fs &EXT2Filesystem, buf voidptr, inode_index u32, off u64, cnt u64) ?i64 {
-	inode.resize(mut fs, inode_index, off, cnt) or { return none }
-
-	for headway := u64(0); headway < cnt; {
-		iblock := (off + headway) / fs.block_size
-
-		mut size := cnt - headway
-		offset := (off + headway) % fs.block_size
-
-		if size > (fs.block_size - offset) {
-			size = fs.block_size - offset
-		}
-
-		disk_block := inode.get_block(mut fs, u32(iblock)) or { return none }
-
-		fs.raw_device_write(voidptr(u64(buf) + headway), disk_block * fs.block_size + offset,
-			size) or { return none }
-
-		headway += size
-	}
-
-	return i64(cnt)
-}
-
-fn (mut inode EXT2Inode) free_entry(mut fs &EXT2Filesystem, inode_index u32) ?int {
-	for i := u64(0); i < lib.div_roundup(inode.sector_cnt * fs.backing_device.resource.stat.blksize,
-		fs.block_size); i++ {
-		block_index := inode.get_block(mut fs, u32(i)) or { return none }
-
-		fs.free_block(block_index) or { return none }
-
-		inode.set_block(mut fs, inode_index, u32(i), 0) or { return none }
-	}
-
-	fs.free_inode(inode_index) or { return none }
-
-	return 0
-}
-
-fn (mut inode EXT2Inode) set_block(mut fs &EXT2Filesystem, inode_index u32, iblock u32, disk_block u32) ?u32 {
-	mut block := iblock
-	blocks_per_level := u32(fs.block_size / 4)
-
-	if block < 12 {
-		inode.blocks[block] = disk_block
-		return disk_block
-	}
-
-	block -= 12
-
-	if block >= blocks_per_level {
-		block -= blocks_per_level
-
-		single_index := block / blocks_per_level
-		mut indirect_offset := block % blocks_per_level
-		mut indirect_block := u32(0)
-
-		if single_index >= blocks_per_level {
-			block -= blocks_per_level * blocks_per_level
-
-			double_indirect_index := block / blocks_per_level
-			indirect_offset = block % blocks_per_level
-			mut single_indirect_index := u32(0)
-
-			if inode.blocks[14] == 0 {
-				inode.blocks[14] = fs.allocate_block() or { return none }
-
-				inode.write_entry(mut fs, inode_index) or { return none }
-			}
-
-			fs.raw_device_read(voidptr(&single_indirect_index), inode.blocks[14] * fs.block_size +
-				double_indirect_index * 4, 4) or { return none }
-
-			if single_indirect_index == 0 {
-				new_block := fs.allocate_block() or { return none }
-
-				fs.raw_device_write(voidptr(&new_block), inode.blocks[14] * fs.block_size +
-					double_indirect_index * 4, 4) or { return none }
-
-				single_indirect_index = new_block
-			}
-
-			fs.raw_device_read(voidptr(&indirect_block), double_indirect_index * fs.block_size +
-				single_indirect_index * 4, 4) or { return none }
-
-			if indirect_block == 0 {
-				new_block := fs.allocate_block() or { return none }
-
-				fs.raw_device_write(voidptr(&indirect_block),
-					double_indirect_index * fs.block_size + single_indirect_index * 4,
-					4) or { return none }
-
-				indirect_block = new_block
-			}
-
-			fs.raw_device_write(voidptr(&disk_block), indirect_block * fs.block_size +
-				indirect_offset * 4, 4) or { return none }
-
-			return disk_block
-		}
-
-		if inode.blocks[13] == 0 {
-			inode.blocks[13] = fs.allocate_block() or { return none }
-
-			inode.write_entry(mut fs, inode_index) or { return none }
-		}
-
-		fs.raw_device_read(voidptr(&indirect_block), inode.blocks[13] * fs.block_size +
-			single_index * 4, 4) or { return none }
-
-		if indirect_block == 0 {
-			new_block := fs.allocate_block() or { return none }
-
-			fs.raw_device_write(voidptr(&new_block), inode.blocks[13] * fs.block_size +
-				single_index * 4, 4) or { return none }
-
-			indirect_block = new_block
-		}
-
-		fs.raw_device_write(voidptr(&disk_block), indirect_block * fs.block_size +
-			indirect_offset * 4, 4) or { return none }
-
-		return disk_block
-	} else {
-		if inode.blocks[12] == 0 {
-			inode.blocks[12] = fs.allocate_block() or { return none }
-
-			inode.write_entry(mut fs, inode_index) or { return none }
-		}
-
-		fs.raw_device_write(voidptr(&disk_block), inode.blocks[12] * fs.block_size + block * 4,
-			4) or { return none }
-	}
-
-	return disk_block
-}
-
-fn (mut inode EXT2Inode) get_block(mut fs &EXT2Filesystem, iblock u32) ?u32 {
-	mut disk_block_index := u32(0)
-	mut block := iblock
-	blocks_per_level := u32(fs.block_size / 4)
-
-	if block < 12 {
-		disk_block_index = inode.blocks[iblock]
-		return disk_block_index
-	}
-
-	block -= 12
-
-	if block >= blocks_per_level {
-		block -= blocks_per_level
-
-		single_index := block / blocks_per_level
-		mut indirect_offset := block % blocks_per_level
-		indirect_block := u32(0)
-
-		if single_index >= blocks_per_level {
-			block -= blocks_per_level * blocks_per_level
-
-			double_indirect_index := block / blocks_per_level
-			indirect_offset = block % blocks_per_level
-			single_indirect_index := u32(0)
-
-			fs.raw_device_read(voidptr(&single_indirect_index), inode.blocks[14] * fs.block_size +
-				double_indirect_index * 4, 4) or { return none }
-
-			fs.raw_device_read(voidptr(&indirect_block), double_indirect_index * fs.block_size +
-				single_indirect_index * 4, 4) or { return none }
-
-			fs.raw_device_read(voidptr(&disk_block_index), indirect_block * fs.block_size +
-				indirect_offset * 4, 4) or { return none }
-
-			return disk_block_index
-		}
-
-		fs.raw_device_read(voidptr(&indirect_block), inode.blocks[13] * fs.block_size +
-			single_index * 4, 4) or { return none }
-
-		fs.raw_device_read(voidptr(&disk_block_index), indirect_block * fs.block_size +
-			indirect_offset * 4, 4) or { return none }
-
-		return disk_block_index
-	}
-
-	fs.raw_device_read(voidptr(&disk_block_index), inode.blocks[12] * fs.block_size + block * 4,
-		4) or { return none }
-
-	return disk_block_index
-}
-
-fn (mut fs EXT2Filesystem) allocate_block() ?u32 {
-	mut bgd := &EXT2BlockGroupDescriptor{}
-
-	for i := u32(0); i < fs.bgd_cnt; i++ {
-		bgd.read_entry(mut fs, i)
-
-		block_index := bgd.allocate_block(mut fs, i) or { continue }
-
-		return u32(block_index + i * fs.superblock.blocks_per_group)
-	}
-
-	return none
-}
-
-fn (mut fs EXT2Filesystem) allocate_inode() ?u64 {
-	mut bgd := &EXT2BlockGroupDescriptor{}
-
-	for i := u32(0); i < fs.bgd_cnt; i++ {
-		bgd.read_entry(mut fs, i)
-
-		inode_index := bgd.allocate_inode(mut fs, i) or { continue }
-
-		return inode_index + i * fs.superblock.blocks_per_group
-	}
-
-	return none
-}
-
-fn (mut fs EXT2Filesystem) free_block(block u32) ?int {
-	bgd_index := block / fs.superblock.blocks_per_group
-	bitmap_index := block - bgd_index * fs.superblock.blocks_per_group
-	bitmap := memory.calloc(lib.div_roundup(fs.block_size, u64(8)), 1)
-
-	mut bgd := &EXT2BlockGroupDescriptor{}
-	bgd.read_entry(mut fs, bgd_index)
-
-	fs.raw_device_read(bitmap, bgd.block_addr_bitmap * fs.block_size, fs.block_size) or {
-		print('ext2: unable to read bgd bitmap\n')
-		return none
-	}
-
-	if lib.bittest(bitmap, bitmap_index) == false {
-		memory.free(bitmap)
-		return 0
-	}
-
-	lib.bitreset(bitmap, bitmap_index)
-
-	fs.raw_device_write(bitmap, bgd.block_addr_bitmap * fs.block_size, fs.block_size) or {
-		print('ext2: unable to write bgd bitmap\n')
-		return none
-	}
-
-	bgd.unallocated_blocks++
-	bgd.write_entry(mut fs, bgd_index)
-
-	memory.free(bitmap)
-
-	return 0
-}
-
-fn (mut fs EXT2Filesystem) free_inode(inode u32) ?int {
-	bgd_index := inode / fs.superblock.inodes_per_group
-	bitmap_index := inode - bgd_index * fs.superblock.inodes_per_group
-	bitmap := memory.calloc(lib.div_roundup(fs.block_size, u64(8)), 1)
-
-	mut bgd := &EXT2BlockGroupDescriptor{}
-	bgd.read_entry(mut fs, bgd_index)
-
-	fs.raw_device_read(bitmap, bgd.block_addr_inode * fs.block_size, fs.block_size) or {
-		print('ext2: unable to read inode bitmap\n')
-		return none
-	}
-
-	if lib.bittest(bitmap, bitmap_index) == false {
-		memory.free(bitmap)
-		return 0
-	}
-
-	lib.bitreset(bitmap, bitmap_index)
-
-	fs.raw_device_write(bitmap, bgd.block_addr_inode * fs.block_size, fs.block_size) or {
-		print('ext2: unable to write inode bitmap\n')
-		return none
-	}
-
-	bgd.unallocated_inodes++
-	bgd.write_entry(mut fs, bgd_index)
-
-	memory.free(bitmap)
-
-	return 0
-}
-
-fn (mut bgd EXT2BlockGroupDescriptor) read_entry(mut fs &EXT2Filesystem, bgd_index u32) int {
-	mut bgd_offset := u64(0)
-
-	if fs.block_size >= 2048 {
-		bgd_offset = fs.block_size
-	} else {
-		bgd_offset = fs.block_size * 2
-	}
-
-	fs.raw_device_read(voidptr(&bgd), bgd_offset + sizeof(EXT2BlockGroupDescriptor) * bgd_index,
-		sizeof(EXT2BlockGroupDescriptor)) or {
-		print('ext2: unable to read bgd entry\n')
-		return -1
-	}
-
-	return 0
-}
-
-fn (mut bgd EXT2BlockGroupDescriptor) write_entry(mut fs &EXT2Filesystem, bgd_index u32) int {
-	mut bgd_offset := u64(0)
-
-	if fs.block_size >= 2048 {
-		bgd_offset = fs.block_size
-	} else {
-		bgd_offset = fs.block_size * 2
-	}
-
-	fs.raw_device_write(voidptr(&bgd), bgd_offset + sizeof(EXT2BlockGroupDescriptor) * bgd_index,
-		sizeof(EXT2BlockGroupDescriptor)) or {
-		print('ext2: unable to read bgd entry\n')
-		return -1
-	}
-
-	return 0
-}
-
-fn (mut bgd EXT2BlockGroupDescriptor) allocate_block(mut fs &EXT2Filesystem, bgd_index u32) ?u64 {
-	if bgd.unallocated_blocks == 0 {
-		return none
-	}
-
-	bitmap := memory.calloc(lib.div_roundup(fs.block_size, u64(8)), 1)
-
-	fs.raw_device_read(bitmap, bgd.block_addr_bitmap * fs.block_size, fs.block_size) or {
-		print('ext2: unable to read bgd bitmap\n')
-		return none
-	}
-
-	for i := u64(0); i < fs.block_size; i++ {
-		if lib.bittest(bitmap, i) == false {
-			lib.bitset(bitmap, i)
-
-			fs.raw_device_write(bitmap, bgd.block_addr_bitmap * fs.block_size, fs.block_size) or {
-				print('ext2: unable to write bgd bitmap\n')
-				return none
-			}
-
-			bgd.unallocated_blocks--
-			bgd.write_entry(mut fs, bgd_index)
-
-			memory.free(bitmap)
-
-			return i
-		}
-	}
-
-	memory.free(bitmap)
-
-	return -1
-}
-
-fn (mut bgd EXT2BlockGroupDescriptor) allocate_inode(mut fs &EXT2Filesystem, bgd_index u32) ?u64 {
-	if bgd.unallocated_blocks == 0 {
-		return none
-	}
-
-	bitmap := memory.calloc(lib.div_roundup(fs.block_size, u64(8)), 1)
-
-	fs.raw_device_read(bitmap, bgd.block_addr_inode * fs.block_size, fs.block_size) or {
-		print('ext2: unable to read inode bitmap\n')
-		return none
-	}
-
-	for i := u64(0); i < fs.block_size; i++ {
-		if lib.bittest(bitmap, i) == false {
-			lib.bitset(bitmap, i)
-
-			fs.raw_device_write(bitmap, bgd.block_addr_inode * fs.block_size, fs.block_size) or {
-				print('ext2: unable to write inode bitmap\n')
-				return none
-			}
-
-			bgd.unallocated_inodes--
-			bgd.write_entry(mut fs, bgd_index)
-
-			memory.free(bitmap)
-
-			return i
-		}
-	}
-
-	memory.free(bitmap)
-
-	return -1
-}
-
-fn (mut inode EXT2Inode) read_entry(mut fs &EXT2Filesystem, inode_index u32) ?int {
-	inode_table_index := (inode_index - 1) % fs.superblock.inodes_per_group
-	bgd_index := (inode_index - 1) / fs.superblock.inodes_per_group
-
-	mut bgd := &EXT2BlockGroupDescriptor{}
-	bgd.read_entry(mut fs, bgd_index)
-
-	fs.raw_device_read(voidptr(&inode), bgd.inode_table_block * fs.block_size +
-		fs.superblock.inode_size * inode_table_index, sizeof(EXT2Inode)) or {
-		print('ext2: unable to read inode entry\n')
-		return none
-	}
-
-	return 0
-}
-
-fn (mut inode EXT2Inode) write_entry(mut fs &EXT2Filesystem, inode_index u32) ?int {
-	inode_table_index := (inode_index - 1) % fs.superblock.inodes_per_group
-	bgd_index := (inode_index - 1) / fs.superblock.inodes_per_group
-
-	mut bgd := &EXT2BlockGroupDescriptor{}
-	bgd.read_entry(mut fs, bgd_index)
-
-	fs.raw_device_write(voidptr(&inode), bgd.inode_table_block * fs.block_size +
-		fs.superblock.inode_size * inode_table_index, sizeof(EXT2Inode)) or {
-		print('ext2: unable to read inode entry\n')
-		return none
-	}
-
-	return 0
-}
-
-fn (mut fs EXT2Filesystem) raw_device_read(buf voidptr, loc u64, count u64) ?i64 {
-	lba_size := fs.backing_device.resource.stat.blksize
-
-	mut alignment := u64(0)
-	if (loc & (lba_size - 1)) + count > lba_size {
-		alignment = 0
-	}
-
-	lba_start := u64(loc / lba_size)
-	lba_cnt := u64(lib.div_roundup(count, lba_size) + alignment)
-
-	buffer := voidptr(u64(memory.pmm_alloc(lib.div_roundup(lba_cnt * lba_size, page_size))) +
-		higher_half)
-
-	fs.backing_device.resource.read(0, buffer, lba_start * lba_size, lba_cnt * lba_size) or {
-		print('ext2: unable to read from device\n')
-		return none
-	}
-
-	lba_offset := loc % lba_size
-
-	unsafe { C.memcpy(buf, voidptr(u64(buffer) + lba_offset), count) }
-
-	memory.pmm_free(voidptr(u64(buffer) - higher_half), lib.div_roundup(lba_cnt * lba_size,
-		page_size))
-
-	return i64(count)
-}
-
-fn (mut fs EXT2Filesystem) raw_device_write(buf voidptr, loc u64, count u64) ?i64 {
-	lba_size := fs.backing_device.resource.stat.blksize
-
-	mut alignment := u64(0)
-	if (loc & (lba_size - 1)) + count > lba_size {
-		alignment = 0
-	}
-
-	lba_start := u64(loc / lba_size)
-	lba_cnt := u64(lib.div_roundup(count, lba_size) + alignment)
-
-	buffer := voidptr(u64(memory.pmm_alloc(lib.div_roundup(lba_cnt * lba_size, page_size))) +
-		higher_half)
-
-	fs.backing_device.resource.read(0, buffer, lba_start * lba_size, lba_cnt * lba_size) or {
-		print('ext2: unable to write from device\n')
-		return none
-	}
-
-	lba_offset := loc % lba_size
-
-	unsafe { C.memcpy(voidptr(u64(buffer) + lba_offset), buf, count) }
-
-	fs.backing_device.resource.write(0, buffer, lba_start * lba_size, lba_cnt * lba_size) or {
-		print('ext2: unable to read from device\n')
-		return none
-	}
-
-	memory.pmm_free(voidptr(u64(buffer) - higher_half), lib.div_roundup(lba_cnt * lba_size,
-		page_size))
-
-	return i64(count)
-}
-
-pub fn ext2_init(backing_device &fs.VFSNode) (&EXT2Filesystem, bool) {
-	mut new_filesystem := &EXT2Filesystem{
-		backing_device: unsafe { backing_device }
-		superblock:     &EXT2Superblock{}
-		root_inode:     &EXT2Inode{}
-	}
-
-	new_filesystem.raw_device_read(new_filesystem.superblock, backing_device.resource.stat.blksize * 2,
-		sizeof(EXT2Superblock)) or { return 0, false }
-
-	if new_filesystem.superblock.signature != 0xef53 {
-		return 0, false
-	}
-
-	return new_filesystem, true
-}
diff --git a/kernel/modules/fs/inotify.v b/kernel/modules/fs/inotify.v
deleted file mode 100644
index 9dfe604..0000000
--- a/kernel/modules/fs/inotify.v
+++ /dev/null
@@ -1,72 +0,0 @@
-module fs
-
-// This is a stub
-import resource
-import stat
-import klock
-import file
-import errno
-import event.eventstruct
-import proc
-
-struct INotify {
-mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	event    eventstruct.Event
-	status   int
-	can_mmap bool
-}
-
-fn (mut this INotify) mmap(page u64, flags int) voidptr {
-	return unsafe { nil }
-}
-
-fn (mut this INotify) read(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	return none
-}
-
-fn (mut this INotify) write(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	return none
-}
-
-fn (mut this INotify) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	return resource.default_ioctl(handle, request, argp)
-}
-
-fn (mut this INotify) unref(handle voidptr) ? {
-	return none
-}
-
-fn (mut this INotify) link(handle voidptr) ? {
-	return none
-}
-
-fn (mut this INotify) unlink(handle voidptr) ? {
-	return none
-}
-
-fn (mut this INotify) grow(handle voidptr, new_size u64) ? {
-	return none
-}
-
-pub fn syscall_inotify_init(_ voidptr, flags int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: inotify_init(%d)\n', process.name.str, flags)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut inotify := &INotify{
-		refcount: 1
-	}
-
-	fdnum := file.fdnum_create_from_resource(unsafe { nil }, mut inotify, 0, 0, false) or {
-		return errno.err, errno.get()
-	}
-
-	return u64(fdnum), 0
-}
diff --git a/kernel/modules/fs/tmpfs.v b/kernel/modules/fs/tmpfs.v
deleted file mode 100644
index ffbb941..0000000
--- a/kernel/modules/fs/tmpfs.v
+++ /dev/null
@@ -1,230 +0,0 @@
-module fs
-
-import stat
-import klock
-import memory
-import memory.mmap
-import resource
-import lib
-import event.eventstruct
-import katomic
-
-struct TmpFSResource {
-pub mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	event    eventstruct.Event
-	status   int
-	can_mmap bool
-
-	storage  &u8
-	capacity u64
-}
-
-fn (mut this TmpFSResource) mmap(page u64, flags int) voidptr {
-	this.l.acquire()
-	defer {
-		this.l.release()
-	}
-
-	if flags & mmap.map_shared != 0 {
-		unsafe {
-			return voidptr(u64(&this.storage[page * page_size]) - higher_half)
-		}
-	}
-
-	copy_page := memory.pmm_alloc(1)
-
-	unsafe {
-		C.memcpy(voidptr(u64(copy_page) + higher_half), &this.storage[page * page_size],
-			page_size)
-	}
-
-	return copy_page
-}
-
-fn (mut this TmpFSResource) read(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	this.l.acquire()
-
-	mut actual_count := count
-
-	if loc + count > this.stat.size {
-		actual_count = u64(count - ((loc + count) - this.stat.size))
-	}
-
-	unsafe { C.memcpy(buf, &this.storage[loc], actual_count) }
-
-	this.l.release()
-
-	return i64(actual_count)
-}
-
-fn (mut this TmpFSResource) write(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	this.l.acquire()
-
-	if loc + count > this.capacity {
-		mut new_capacity := this.capacity
-
-		for loc + count > new_capacity {
-			new_capacity *= 2
-		}
-
-		new_storage := memory.realloc(this.storage, new_capacity)
-
-		if new_storage == 0 {
-			return none
-		}
-
-		this.storage = new_storage
-		this.capacity = new_capacity
-	}
-
-	unsafe { C.memcpy(&this.storage[loc], buf, count) }
-
-	if loc + count > this.stat.size {
-		this.stat.size = loc + count
-		this.stat.blocks = lib.div_roundup(this.stat.size, this.stat.blksize)
-	}
-
-	this.l.release()
-
-	return i64(count)
-}
-
-fn (mut this TmpFSResource) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	return resource.default_ioctl(handle, request, argp)
-}
-
-fn (mut this TmpFSResource) unref(handle voidptr) ? {
-	katomic.dec(mut &this.refcount)
-
-	if this.refcount != 0 {
-		return
-	}
-
-	if stat.isreg(this.stat.mode) {
-		memory.free(this.storage)
-	}
-
-	unsafe { free(this) }
-}
-
-fn (mut this TmpFSResource) link(handle voidptr) ? {
-	katomic.inc(mut &this.stat.nlink)
-}
-
-fn (mut this TmpFSResource) unlink(handle voidptr) ? {
-	katomic.dec(mut &this.stat.nlink)
-}
-
-fn (mut this TmpFSResource) grow(handle voidptr, new_size u64) ? {
-	this.l.acquire()
-	defer {
-		this.l.release()
-	}
-
-	mut new_capacity := this.capacity
-	for new_size > new_capacity {
-		new_capacity *= 2
-	}
-
-	new_storage := memory.realloc(this.storage, new_capacity)
-
-	if new_storage == 0 {
-		return none
-	}
-
-	this.storage = new_storage
-	this.capacity = new_capacity
-
-	this.stat.size = new_size
-	this.stat.blocks = lib.div_roundup(new_size, u64(this.stat.blksize))
-}
-
-struct TmpFS {
-pub mut:
-	dev_id        u64
-	inode_counter u64
-}
-
-fn (this TmpFS) instantiate() &FileSystem {
-	new := &TmpFS{}
-	return new
-}
-
-fn (this TmpFS) populate(node &VFSNode) {}
-
-fn (mut this TmpFS) mount(parent &VFSNode, name string, source &VFSNode) ?&VFSNode {
-	this.dev_id = resource.create_dev_id()
-	return this.create(parent, name, 0o644 | stat.ifdir)
-}
-
-fn (mut this TmpFS) create(parent &VFSNode, name string, mode u32) &VFSNode {
-	mut new_node := create_node(this, parent, name, stat.isdir(mode))
-
-	mut new_resource := &TmpFSResource{
-		storage:  unsafe { nil }
-		refcount: 1
-	}
-
-	if stat.isreg(mode) {
-		new_resource.capacity = 4096
-		new_resource.storage = memory.malloc(new_resource.capacity)
-		new_resource.can_mmap = true
-	}
-
-	new_resource.stat.size = 0
-	new_resource.stat.blocks = 0
-	new_resource.stat.blksize = 512
-	new_resource.stat.dev = this.dev_id
-	new_resource.stat.ino = this.inode_counter++
-	new_resource.stat.mode = mode
-	new_resource.stat.nlink = 1
-
-	new_resource.stat.atim = realtime_clock
-	new_resource.stat.ctim = realtime_clock
-	new_resource.stat.mtim = realtime_clock
-
-	new_node.resource = new_resource
-
-	return new_node
-}
-
-fn (mut this TmpFS) link(parent &VFSNode, path string, mut old_node VFSNode) ?&VFSNode {
-	mut new_node := create_node(this, parent, path, false)
-
-	katomic.inc(mut &old_node.resource.refcount)
-
-	new_node.resource = old_node.resource
-	new_node.children = old_node.children
-
-	return new_node
-}
-
-fn (mut this TmpFS) symlink(parent &VFSNode, dest string, target string) &VFSNode {
-	mut new_node := create_node(this, parent, target, false)
-
-	mut new_resource := &TmpFSResource{
-		storage:  unsafe { nil }
-		refcount: 1
-	}
-
-	new_resource.stat.size = u64(target.len)
-	new_resource.stat.blocks = 0
-	new_resource.stat.blksize = 512
-	new_resource.stat.dev = this.dev_id
-	new_resource.stat.ino = this.inode_counter++
-	new_resource.stat.mode = stat.iflnk | 0o777
-	new_resource.stat.nlink = 1
-
-	new_resource.stat.atim = realtime_clock
-	new_resource.stat.ctim = realtime_clock
-	new_resource.stat.mtim = realtime_clock
-
-	new_node.resource = new_resource
-
-	new_node.symlink_target = dest
-
-	return new_node
-}
diff --git a/kernel/modules/fs/vfs.v b/kernel/modules/fs/vfs.v
deleted file mode 100644
index 180feec..0000000
--- a/kernel/modules/fs/vfs.v
+++ /dev/null
@@ -1,1025 +0,0 @@
-@[has_globals]
-module fs
-
-import resource
-import stat
-import klock
-import proc
-import file
-import errno
-
-pub const at_fdcwd = -100
-pub const at_empty_path = 0x1000
-pub const at_symlink_follow = 0x400
-pub const at_symlink_nofollow = 0x100
-pub const at_removedir = 0x200
-pub const at_eaccess = 0x200
-pub const seek_cur = 1
-pub const seek_end = 2
-pub const seek_set = 0
-
-interface FileSystem {
-mut:
-	instantiate() &FileSystem
-	populate(&VFSNode)
-	mount(&VFSNode, string, &VFSNode) ?&VFSNode
-	create(&VFSNode, string, u32) &VFSNode
-	symlink(&VFSNode, string, string) &VFSNode
-	link(&VFSNode, string, mut VFSNode) ?&VFSNode
-}
-
-pub struct VFSNode {
-pub mut:
-	mountpoint     &VFSNode           = unsafe { nil }
-	redir          &VFSNode           = unsafe { nil }
-	resource       &resource.Resource = unsafe { nil }
-	filesystem     &FileSystem        = unsafe { nil }
-	name           string
-	parent         &VFSNode             = unsafe { nil }
-	children       &map[string]&VFSNode = unsafe { nil }
-	symlink_target string
-}
-
-__global (
-	vfs_lock    klock.Lock
-	vfs_root    &VFSNode
-	filesystems map[string]&FileSystem
-)
-
-pub fn create_node(filesystem &FileSystem, parent &VFSNode, name string, dir bool) &VFSNode {
-	mut node := &VFSNode{
-		name:       name
-		parent:     unsafe { parent }
-		mountpoint: unsafe { nil }
-		redir:      unsafe { nil }
-		children:   unsafe { nil }
-		resource:   &resource.Resource(unsafe { nil })
-		filesystem: unsafe { filesystem }
-	}
-	if dir {
-		node.children = &map[string]&VFSNode{}
-	}
-	return node
-}
-
-pub fn add_filesystem(filesystem &FileSystem, identifier string) {
-	unsafe {
-		filesystems[identifier] = filesystem
-	}
-}
-
-pub fn initialise() {
-	vfs_root = create_node(&TmpFS(unsafe { nil }), &VFSNode(unsafe { nil }), '', false)
-
-	filesystems = map[string]&FileSystem{}
-
-	// Install filesystems by name string
-	filesystems['tmpfs'] = &TmpFS{}
-	filesystems['devtmpfs'] = &DevTmpFS{}
-}
-
-fn reduce_node(node &VFSNode, follow_symlinks bool) &VFSNode {
-	if unsafe { node.redir != 0 } {
-		return reduce_node(node.redir, follow_symlinks)
-	}
-	if unsafe { node.mountpoint != 0 } {
-		return reduce_node(node.mountpoint, follow_symlinks)
-	}
-	if node.symlink_target.len != 0 && follow_symlinks == true {
-		_, next_node, _ := path2node(node.parent, node.symlink_target)
-		if unsafe { next_node == 0 } {
-			return 0
-		}
-		return reduce_node(next_node, follow_symlinks)
-	}
-	return unsafe { node }
-}
-
-fn path2node(parent &VFSNode, path string) (&VFSNode, &VFSNode, string) {
-	if path.len == 0 {
-		errno.set(errno.enoent)
-		return 0, 0, ''
-	}
-
-	mut index := u64(0)
-	mut current_node := reduce_node(parent, false)
-
-	if path[index] == `/` {
-		current_node = reduce_node(vfs_root, false)
-		for path[index] == `/` {
-			if index == u64(path.len) - 1 {
-				return current_node, current_node, ''
-			}
-			index++
-		}
-	}
-
-	for {
-		mut elem := []u8{}
-		defer {
-			unsafe { elem.free() }
-		}
-
-		for index < path.len && path[index] != `/` {
-			elem << path[index]
-			index++
-		}
-
-		elem << 0
-
-		for index < path.len && path[index] == `/` {
-			index++
-		}
-
-		last := index == u64(path.len)
-
-		elem_str := unsafe { cstring_to_vstring(&elem[0]) }
-
-		current_node = reduce_node(current_node, false)
-
-		if elem_str !in current_node.children {
-			errno.set(errno.enoent)
-			if last == true {
-				return current_node, 0, elem_str
-			}
-			return 0, 0, ''
-		}
-
-		mut new_node := reduce_node(unsafe { current_node.children[elem_str] }, false)
-
-		if last == true {
-			return current_node, new_node, elem_str
-		}
-
-		current_node = new_node
-
-		if stat.islnk(current_node.resource.stat.mode) {
-			_, current_node, _ = path2node(current_node.parent, current_node.symlink_target)
-			if voidptr(current_node) == unsafe { nil } {
-				return 0, 0, ''
-			}
-			continue
-		}
-
-		if !stat.isdir(current_node.resource.stat.mode) {
-			errno.set(errno.enotdir)
-			return 0, 0, ''
-		}
-	}
-
-	errno.set(errno.enoent)
-	return 0, 0, ''
-}
-
-fn get_parent_dir(dirfd int, path string) ?&VFSNode {
-	is_absolute := path[0] == `/`
-
-	current_process := proc.current_thread().process
-
-	mut parent := &VFSNode(unsafe { nil })
-
-	if is_absolute == true {
-		parent = vfs_root
-	} else {
-		if dirfd == at_fdcwd {
-			parent = unsafe { &VFSNode(current_process.current_directory) }
-		} else {
-			dir_fd := file.fd_from_fdnum(current_process, dirfd) or { return none }
-			dir_handle := dir_fd.handle
-			if stat.isdir(dir_handle.resource.stat.mode) == false {
-				errno.set(errno.enotdir)
-				return none
-			}
-			parent = unsafe { &VFSNode(dir_handle.node) }
-		}
-	}
-
-	return parent
-}
-
-pub fn get_node(parent &VFSNode, path string, follow_links bool) ?&VFSNode {
-	_, node, _ := path2node(parent, path)
-	if voidptr(node) == unsafe { nil } {
-		return none
-	}
-	if follow_links == true {
-		ret := reduce_node(node, true)
-		if unsafe { ret == 0 } {
-			return none
-		}
-		return ret
-	}
-	return node
-}
-
-pub fn syscall_mount(_ voidptr, src charptr, tgt charptr, fs_type charptr, mountflags u64, data voidptr) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: mount(%s, %s, %s, 0x%x, %x)\n', process.name.str, src,
-		tgt, fs_type, mountflags, data)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	source := unsafe { cstring_to_vstring(src) }
-	target := unsafe { cstring_to_vstring(tgt) }
-	fstype := unsafe { cstring_to_vstring(fs_type) }
-
-	// TODO: Not ignore mountflags and data once the current system supports it.
-	curr_dir := proc.current_thread().process.current_directory
-	mount(curr_dir, source, target, fstype) or { return errno.err, errno.get() }
-
-	return 0, 0
-}
-
-pub fn syscall_umount(_ voidptr, tgt charptr, flags u64) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: umount(%s, 0x%x)\n', process.name.str, tgt, flags)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	// TODO: Implement this once the FS supports it.
-	return errno.err, errno.enosys
-}
-
-pub fn mount(parent &VFSNode, source string, target string, filesystem string) ? {
-	if filesystem !in filesystems {
-		return none
-	}
-
-	mut source_node := &VFSNode(unsafe { nil })
-	if source.len != 0 {
-		_, source_node, _ = path2node(parent, source)
-		if voidptr(source_node) == unsafe { nil } || stat.isdir(source_node.resource.stat.mode) {
-			return none
-		}
-	}
-
-	parent_of_tgt_node, mut target_node, basename := path2node(parent, target)
-
-	mounting_root := voidptr(target_node) == voidptr(vfs_root)
-
-	if target_node == unsafe { nil }
-		|| (!mounting_root && !stat.isdir(target_node.resource.stat.mode)) {
-		return none
-	}
-
-	mut f_sys := unsafe { filesystems[filesystem].instantiate() }
-
-	mut mount_node := f_sys.mount(parent_of_tgt_node, basename, source_node)?
-
-	target_node.mountpoint = mount_node
-
-	mount_node.create_dotentries(parent_of_tgt_node)
-
-	if source.len > 0 {
-		print('vfs: Mounted `${source}` to `${target}` with filesystem `${filesystem}`\n')
-	} else {
-		print('vfs: Mounted ${filesystem} to `${target}`\n')
-	}
-}
-
-fn (mut node VFSNode) create_dotentries(parent &VFSNode) {
-	// Create . and .. entries
-	mut dot := create_node(node.filesystem, node, '.', false)
-	mut dotdot := create_node(node.filesystem, node, '..', false)
-	unsafe {
-		dot.redir = node
-		dotdot.redir = parent
-		node.children['.'] = dot
-		node.children['..'] = dotdot
-	}
-}
-
-pub fn pathname(node &VFSNode) string {
-	mut components := []string{}
-	defer {
-		unsafe { components.free() }
-	}
-
-	mut current_node := unsafe { node }
-
-	for {
-		if current_node.name == '' {
-			break
-		}
-		components << current_node.name
-		current_node = current_node.parent
-	}
-
-	if components.len == 0 {
-		return '/'
-	}
-
-	mut ret := ''
-	for i := components.len - 1; i >= 0; i-- {
-		ret += '/${components[i]}'
-	}
-
-	return ret
-}
-
-pub fn symlink(parent &VFSNode, dest string, target string) ?&VFSNode {
-	mut parent_of_tgt_node, mut target_node, basename := path2node(parent, target)
-
-	if unsafe { target_node != 0 } || unsafe { parent_of_tgt_node == 0 } {
-		errno.set(errno.eexist)
-		return none
-	}
-
-	target_node = parent_of_tgt_node.filesystem.symlink(parent_of_tgt_node, dest, basename)
-
-	unsafe {
-		parent_of_tgt_node.children[basename] = target_node
-	}
-	return target_node
-}
-
-pub fn link(parent &VFSNode, dest string, target string) ?&VFSNode {
-	mut parent_of_tgt_node, mut target_node, basename := path2node(parent, target)
-
-	if unsafe { target_node != 0 } || unsafe { parent_of_tgt_node == 0 } {
-		errno.set(errno.eexist)
-		return none
-	}
-
-	_, mut dest_node, _ := path2node(vfs_root, dest)
-
-	target_node = parent_of_tgt_node.filesystem.link(parent_of_tgt_node, dest, mut dest_node) ?
-
-	unsafe {
-		parent_of_tgt_node.children[basename] = target_node
-	}
-	return target_node
-}
-
-pub fn unlink(parent &VFSNode, name string, remove_dir bool) ? {
-	mut parent_of_tgt, mut node, basename := path2node(parent, name)
-	if voidptr(node) == unsafe { nil } {
-		return none
-	}
-
-	if stat.isdir(node.resource.stat.mode) {
-		if remove_dir == false {
-			errno.set(errno.eisdir)
-			return none
-		}
-
-		if node.children.len > 2 {
-			errno.set(errno.enotempty)
-			return none
-		}
-
-		unsafe {
-			free(node.children['.'].children)
-			free(node.children['.'])
-			free(node.children['..'].children)
-			free(node.children['..'])
-			free(node.children)
-		}
-	}
-
-	parent_of_tgt.children.delete(basename)
-
-	node.resource.unlink(unsafe { nil })?
-	node.resource.unref(unsafe { nil })?
-}
-
-pub fn create(parent &VFSNode, name string, mode u32) ?&VFSNode {
-	vfs_lock.acquire()
-	ret := internal_create(parent, name, mode)?
-	vfs_lock.release()
-	return ret
-}
-
-pub fn internal_create(parent &VFSNode, name string, mode u32) ?&VFSNode {
-	mut parent_of_tgt_node, mut target_node, basename := path2node(parent, name)
-
-	if unsafe { target_node != 0 } {
-		errno.set(errno.eexist)
-		return none
-	}
-
-	if unsafe { parent_of_tgt_node == 0 } {
-		errno.set(errno.enoent)
-		return none
-	}
-
-	target_node = parent_of_tgt_node.filesystem.create(parent_of_tgt_node, basename, mode)
-
-	unsafe {
-		parent_of_tgt_node.children[basename] = target_node
-	}
-	if stat.isdir(target_node.resource.stat.mode) {
-		target_node.create_dotentries(parent_of_tgt_node)
-	}
-
-	return target_node
-}
-
-fn fdnum_create_from_node(mut node VFSNode, flags int, oldfd int, specific bool) ?int {
-	current_process := proc.current_thread().process
-	mut fd := file.fd_create_from_resource(mut node.resource, flags) or { return none }
-	fd.handle.node = voidptr(node)
-	return file.fdnum_create_from_fd(current_process, fd, oldfd, specific)
-}
-
-pub fn syscall_unlinkat(_ voidptr, dirfd int, _path charptr, flags int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: unlinkat(%d, %s, 0x%x)\n', process.name.str, dirfd, _path,
-		flags)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	path := unsafe { cstring_to_vstring(_path) }
-
-	if path.len == 0 {
-		return errno.err, errno.enoent
-	}
-
-	parent := get_parent_dir(dirfd, path) or { return errno.err, errno.get() }
-
-	remove_dir := flags & at_removedir != 0
-
-	unlink(parent, path, remove_dir) or { return errno.err, errno.get() }
-
-	return 0, 0
-}
-
-pub fn syscall_rmdirat(_ voidptr, dirfd int, _path charptr) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: rmdirat(%d, %s)\n', process.name.str, dirfd, _path)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	path := unsafe { cstring_to_vstring(_path) }
-
-	if path.len == 0 {
-		return errno.err, errno.enoent
-	}
-
-	parent := get_parent_dir(dirfd, path) or { return errno.err, errno.get() }
-
-	mut parent_of_tgt_node, mut target_node, basename := path2node(parent, path)
-
-	if unsafe { parent_of_tgt_node == 0 } {
-		return errno.err, errno.enoent
-	}
-
-	if unsafe { target_node == 0 } {
-		return errno.err, errno.enoent
-	}
-
-	if target_node.children.len > 2 {
-		return errno.err, errno.enotempty
-	}
-
-	target_node.resource.unlink(unsafe { nil }) or {}
-	target_node.resource.unref(unsafe { nil }) or {}
-
-	unsafe {
-		free(target_node.children['.'].children)
-		free(target_node.children['.'])
-		free(target_node.children['..'].children)
-		free(target_node.children['..'])
-		free(target_node.children)
-	}
-	parent_of_tgt_node.children.delete(basename)
-
-	return 0, 0
-}
-
-pub fn syscall_mkdirat(_ voidptr, dirfd int, _path charptr, mode u32) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: mkdirat(%d, %s, 0x%x)\n', process.name.str, dirfd, _path,
-		mode)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	path := unsafe { cstring_to_vstring(_path) }
-
-	if path.len == 0 {
-		return errno.err, errno.enoent
-	}
-
-	parent := get_parent_dir(dirfd, path) or { return errno.err, errno.get() }
-
-	mut parent_of_tgt_node, mut target_node, basename := path2node(parent, path)
-
-	if unsafe { parent_of_tgt_node == 0 } {
-		return errno.err, errno.enoent
-	}
-
-	if unsafe { target_node != 0 } {
-		return errno.err, errno.eexist
-	}
-
-	internal_create(parent_of_tgt_node, basename, mode | stat.ifdir) or {
-		return errno.err, errno.get()
-	}
-
-	return 0, 0
-}
-
-pub fn syscall_readlinkat(_ voidptr, dirfd int, _path charptr, buf voidptr, limit u64) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: readlinkat(%d, %s, 0x%llx, 0x%llx)\n', process.name.str,
-		dirfd, _path, buf, limit)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	path := unsafe { cstring_to_vstring(_path) }
-
-	if path.len == 0 {
-		return errno.err, errno.enoent
-	}
-
-	parent := get_parent_dir(dirfd, path) or { return errno.err, errno.get() }
-
-	node := get_node(parent, path, false) or { return errno.err, errno.get() }
-
-	if stat.islnk(node.resource.stat.mode) == false {
-		return errno.err, errno.einval
-	}
-
-	mut to_copy := u64(node.symlink_target.len + 1)
-	if to_copy > limit {
-		to_copy = limit
-	}
-
-	unsafe { C.memcpy(buf, node.symlink_target.str, to_copy) }
-
-	return to_copy, 0
-}
-
-pub fn syscall_openat(_ voidptr, dirfd int, _path charptr, flags int, mode u32) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: openat(%d, %s, 0x%x, 0x%x)\n', process.name.str, dirfd,
-		_path, flags, mode)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	path := unsafe { cstring_to_vstring(_path) }
-
-	if path.len == 0 {
-		return errno.err, errno.enoent
-	}
-
-	parent := get_parent_dir(dirfd, path) or { return errno.err, errno.get() }
-
-	creat_flags := flags & resource.file_creation_flags_mask
-	follow_links := flags & resource.o_nofollow == 0
-
-	mut node := get_node(parent, path, follow_links) or {
-		if creat_flags & resource.o_creat == 0 {
-			return errno.err, errno.get()
-		}
-		// XXX: mlibc does not pass mode? OK... force regular file with 644
-		new_node := internal_create(parent, path, stat.ifreg | 0o644) or {
-			return errno.err, errno.get()
-		}
-		new_node
-	}
-
-	if stat.islnk(node.resource.stat.mode) {
-		return errno.err, errno.eloop
-	}
-
-	// Follow symlinks
-	node = reduce_node(node, true)
-	if unsafe { node == 0 } {
-		return errno.err, errno.get()
-	}
-
-	if !stat.isdir(node.resource.stat.mode) && flags & resource.o_directory != 0 {
-		return errno.err, errno.enotdir
-	}
-
-	fdnum := fdnum_create_from_node(mut node, flags, 0, false) or { return errno.err, errno.get() }
-
-	return u64(fdnum), 0
-}
-
-pub fn syscall_read(_ voidptr, fdnum int, buf voidptr, count u64) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: read(%d, 0x%llx, 0x%llx)\n', process.name.str, fdnum, buf,
-		count)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut fd := file.fd_from_fdnum(unsafe { nil }, fdnum) or { return errno.err, errno.get() }
-	defer {
-		fd.unref()
-	}
-	ret := fd.handle.read(buf, count) or { return errno.err, errno.get() }
-	return u64(ret), 0
-}
-
-pub fn syscall_write(_ voidptr, fdnum int, buf voidptr, count u64) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: write(%d, 0x%llx, 0x%llx)\n', process.name.str, fdnum,
-		buf, count)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut fd := file.fd_from_fdnum(unsafe { nil }, fdnum) or { return errno.err, errno.get() }
-	defer {
-		fd.unref()
-	}
-	ret := fd.handle.write(buf, count) or { return errno.err, errno.get() }
-	return u64(ret), 0
-}
-
-pub fn syscall_close(_ voidptr, fdnum int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: close(%d)\n', process.name.str, fdnum)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	file.fdnum_close(unsafe { nil }, fdnum, true) or { return errno.err, errno.get() }
-	return 0, 0
-}
-
-pub fn syscall_ioctl(_ voidptr, fdnum int, request u64, argp voidptr) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: ioctl(%d, 0x%llx, 0x%llx)\n', process.name.str, fdnum,
-		request, argp)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut fd := file.fd_from_fdnum(unsafe { nil }, fdnum) or { return errno.err, errno.get() }
-	defer {
-		fd.unref()
-	}
-	ret := fd.handle.ioctl(request, argp) or { return errno.err, errno.get() }
-	return u64(ret), 0
-}
-
-pub fn syscall_getcwd(_ voidptr, buf charptr, len u64) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: getcwd(0x%llx, %llu)\n', process.name.str, buf, len)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	cwd := pathname(proc.current_thread().process.current_directory)
-
-	if cwd.len >= len {
-		return errno.err, errno.erange
-	}
-
-	C.strcpy(buf, cwd.str)
-	return 0, 0
-}
-
-pub fn syscall_faccessat(_ voidptr, dirfd int, _path charptr, mode u32, flags int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: faccessat(%d, %s, 0x%x, 0x%x)\n', process.name.str, dirfd,
-		_path, mode, flags)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	path := unsafe { cstring_to_vstring(_path) }
-
-	if path.len == 0 {
-		return errno.err, errno.enoent
-	}
-
-	parent := get_parent_dir(dirfd, path) or { return errno.err, errno.get() }
-
-	follow_links := flags & at_symlink_nofollow == 0
-
-	get_node(parent, path, follow_links) or { return errno.err, errno.get() }
-
-	return 0, 0
-}
-
-pub fn syscall_fstatat(_ voidptr, dirfd int, _path charptr, statbuf &stat.Stat, flags int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: fstatat(%d, %s, 0x%llx, 0x%x)\n', process.name.str, dirfd,
-		_path, statbuf, flags)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	current_process := proc.current_thread().process
-
-	path := unsafe { cstring_to_vstring(_path) }
-
-	mut statsrc := &stat.Stat(unsafe { nil })
-
-	if path.len == 0 {
-		if flags & at_empty_path == 0 {
-			return errno.err, errno.enoent
-		}
-
-		if dirfd == at_fdcwd {
-			node := unsafe { &VFSNode(current_process.current_directory) }
-			statsrc = &node.resource.stat
-		} else {
-			fd := file.fd_from_fdnum(current_process, dirfd) or { return errno.err, errno.get() }
-			statsrc = &fd.handle.resource.stat
-		}
-	} else {
-		parent := get_parent_dir(dirfd, path) or { return errno.err, errno.get() }
-
-		follow_links := flags & at_symlink_nofollow == 0
-
-		node := get_node(parent, path, follow_links) or { return errno.err, errno.get() }
-
-		statsrc = &node.resource.stat
-	}
-
-	unsafe {
-		*statbuf = *statsrc
-	}
-	return 0, 0
-}
-
-pub fn syscall_fstat(_ voidptr, fdnum int, statbuf &stat.Stat) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: fstat(%d, 0x%llx)\n', process.name.str, fdnum, statbuf)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut fd := file.fd_from_fdnum(unsafe { nil }, fdnum) or { return errno.err, errno.get() }
-	defer {
-		fd.unref()
-	}
-
-	unsafe {
-		*statbuf = fd.handle.resource.stat
-	}
-	return 0, 0
-}
-
-pub fn syscall_linkat(_ voidptr, olddirfd int, _oldpath charptr, newdirfd int, _newpath charptr, flags int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: linkat(%d, %s, %d, %s, 0x%x)\n', process.name.str, olddirfd,
-		_oldpath, newdirfd, _newpath, flags)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	oldpath := unsafe { cstring_to_vstring(_oldpath) }
-	// TODO handle AT_ENPTY_PATH?
-	if oldpath.len == 0 {
-		return errno.err, errno.enoent
-	}
-
-	newpath := unsafe { cstring_to_vstring(_newpath) }
-
-	mut oldparent := get_parent_dir(olddirfd, oldpath) or { return errno.err, errno.get() }
-	mut newparent := get_parent_dir(newdirfd, newpath) or { return errno.err, errno.get() }
-
-	mut basename := ''
-
-	oldparent, _, _ = path2node(oldparent, oldpath)
-	newparent, _, basename = path2node(newparent, newpath)
-
-	// Old and new must be on the same filesystem
-	if voidptr(oldparent.filesystem) != voidptr(newparent.filesystem) {
-		return errno.err, errno.exdev
-	}
-
-	follow_links := flags & at_symlink_nofollow == 0
-
-	mut old_node := get_node(oldparent, oldpath, follow_links) or { return errno.err, errno.get() }
-
-	mut new_node := newparent.filesystem.link(newparent, newpath, mut old_node) or {
-		return errno.err, errno.get()
-	}
-
-	new_node.resource.link(unsafe { nil }) or { return errno.err, errno.get() }
-
-	unsafe {
-		newparent.children[basename] = new_node
-	}
-	return 0, 0
-}
-
-pub fn syscall_fchmod(_ voidptr, fdnum int, mode u32) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: fchmod(%d, 0x%x)\n', process.name.str, fdnum, mode)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut fd := file.fd_from_fdnum(unsafe { nil }, fdnum) or { return errno.err, errno.get() }
-	defer {
-		fd.unref()
-	}
-
-	// XXX this wont work for !tmpfs, fix that
-	fd.handle.resource.stat.mode = mode
-	return 0, 0
-}
-
-pub fn syscall_chdir(_ voidptr, _path charptr) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: chdir(%s)\n', process.name.str, _path)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	path := unsafe { cstring_to_vstring(_path) }
-
-	if path.len == 0 {
-		return errno.err, errno.enoent
-	}
-
-	mut node := get_node(process.current_directory, path, true) or { return errno.err, errno.get() }
-
-	if !stat.isdir(node.resource.stat.mode) {
-		return errno.err, errno.enotdir
-	}
-
-	process.current_directory = node
-
-	return 0, 0
-}
-
-fn C.strcpy(charptr, charptr) charptr
-
-pub fn syscall_readdir(_ voidptr, fdnum int, mut buf stat.Dirent) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: readdir(%d, 0x%llx)\n', process.name.str, fdnum, buf)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut dir_fd := file.fd_from_fdnum(unsafe { nil }, fdnum) or { return errno.err, errno.get() }
-	defer {
-		dir_fd.unref()
-	}
-
-	mut dir_handle := dir_fd.handle
-	dir_resource := dir_handle.resource
-
-	if stat.isdir(dir_resource.stat.mode) == false {
-		return errno.err, errno.enotdir
-	}
-
-	mut dir_node := unsafe { &VFSNode(dir_handle.node) }
-
-	if dir_handle.dirlist_valid == false {
-		dir_handle.dirlist.clear()
-		mut i := u64(0)
-		for name, mut orig_node in dir_node.children {
-			node := reduce_node(unsafe { *orig_node }, false)
-			t := match node.resource.stat.mode & stat.ifmt {
-				stat.ifchr {
-					stat.dt_chr
-				}
-				stat.ifblk {
-					stat.dt_blk
-				}
-				stat.ifdir {
-					stat.dt_dir
-				}
-				stat.iflnk {
-					stat.dt_lnk
-				}
-				stat.ififo {
-					stat.dt_fifo
-				}
-				stat.ifreg {
-					stat.dt_reg
-				}
-				stat.ifsock {
-					stat.dt_sock
-				}
-				else {
-					stat.dt_unknown
-				}
-			}
-			mut new_dirent := stat.Dirent{
-				ino:    node.resource.stat.ino
-				off:    i++
-				reclen: u16(sizeof(stat.Dirent))
-				@type:  u8(t)
-			}
-			C.strcpy(&new_dirent.name[0], name.str)
-			dir_handle.dirlist << new_dirent
-		}
-		dir_handle.dirlist_valid = true
-	}
-
-	if dir_handle.dirlist_index >= dir_handle.dirlist.len {
-		// End of dir.
-		return errno.err, 0
-	}
-
-	unsafe {
-		*buf = dir_handle.dirlist[dir_handle.dirlist_index]
-	}
-	dir_handle.dirlist_index++
-
-	return 0, 0
-}
-
-pub fn syscall_seek(_ voidptr, fdnum int, offset i64, whence int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: seek(%d, %lld, %d)\n', process.name.str, fdnum, offset,
-		whence)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut fd := file.fd_from_fdnum(unsafe { nil }, fdnum) or { return errno.err, errno.get() }
-	defer {
-		fd.unref()
-	}
-
-	mut handle := fd.handle
-
-	handle.l.acquire()
-	defer {
-		handle.l.release()
-	}
-
-	match handle.resource.stat.mode & stat.ifmt {
-		stat.ifchr, stat.ififo, stat.ifpipe, stat.ifsock {
-			return errno.err, errno.espipe
-		}
-		else {}
-	}
-
-	mut base := i64(0)
-	match whence {
-		seek_set {
-			base = offset
-		}
-		seek_cur {
-			base = handle.loc + offset
-		}
-		seek_end {
-			base = i64(handle.resource.stat.size) + offset
-		}
-		else {
-			return errno.err, errno.einval
-		}
-	}
-
-	if base < 0 {
-		return errno.err, errno.einval
-	}
-
-	if base > handle.resource.stat.size {
-		handle.resource.grow(voidptr(handle), u64(base)) or { return errno.err, errno.einval }
-	}
-
-	handle.loc = base
-	return u64(base), 0
-}
diff --git a/kernel/modules/futex/futex.v b/kernel/modules/futex/futex.v
deleted file mode 100644
index adb711c..0000000
--- a/kernel/modules/futex/futex.v
+++ /dev/null
@@ -1,88 +0,0 @@
-@[has_globals]
-module futex
-
-import event
-import event.eventstruct
-import klock
-import errno
-import proc
-import katomic
-
-__global (
-	futex_lock klock.Lock
-	futexes    map[u64]&eventstruct.Event
-)
-
-pub fn initialise() {
-	futexes = map[u64]&eventstruct.Event{}
-}
-
-pub fn syscall_futex_wait(_ voidptr, ptr &int, expected int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: futex_wait(0x%llx, %d)\n', process.name.str, voidptr(ptr),
-		expected)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	if katomic.load(ptr) != expected {
-		return errno.err, errno.eagain
-	}
-
-	mut e := &eventstruct.Event(unsafe { nil })
-	phys := proc.current_thread().process.pagemap.virt2phys(u64(ptr)) or {
-		return errno.err, errno.get()
-	}
-
-	futex_lock.acquire()
-
-	if phys !in futexes {
-		e = &eventstruct.Event{}
-		futexes[phys] = e
-	} else {
-		e = unsafe { futexes[phys] } // will always be present
-	}
-
-	futex_lock.release()
-
-	mut events := [e]
-	defer {
-		unsafe { events.free() }
-	}
-	event.await(mut events, true) or { return errno.err, errno.eintr }
-
-	return 0, 0
-}
-
-pub fn syscall_futex_wake(_ voidptr, ptr &int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: futex_wake(0x%llx)\n', process.name.str, voidptr(ptr))
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	// Ensure this page is not lazily mapped
-	katomic.load(ptr)
-
-	phys := proc.current_thread().process.pagemap.virt2phys(u64(ptr)) or {
-		return errno.err, errno.get()
-	}
-
-	futex_lock.acquire()
-	defer {
-		futex_lock.release()
-	}
-
-	if phys !in futexes {
-		return 0, 0
-	}
-
-	mut e := unsafe { futexes[phys] }
-	ret := event.trigger(mut e, true)
-
-	return ret, 0
-}
diff --git a/kernel/modules/initramfs/initramfs.v b/kernel/modules/initramfs/initramfs.v
deleted file mode 100644
index b2761bd..0000000
--- a/kernel/modules/initramfs/initramfs.v
+++ /dev/null
@@ -1,151 +0,0 @@
-@[has_globals]
-module initramfs
-
-import lib
-import limine
-import fs
-import stat
-import memory as _
-
-struct USTARHeader {
-	name       [100]u8
-	mode       [8]u8
-	uid        [8]u8
-	gid        [8]u8
-	size       [12]u8
-	mtime      [12]u8
-	checksum   [8]u8
-	filetype   u8
-	link_name  [100]u8
-	signature  [6]u8
-	version    [2]u8
-	owner      [32]u8
-	group      [32]u8
-	device_maj [8]u8
-	device_min [8]u8
-	prefix     [155]u8
-}
-
-enum USTARFileType {
-	regular_file  = 0x30
-	hard_link     = 0x31
-	sym_link      = 0x32
-	char_dev      = 0x33
-	block_dev     = 0x34
-	directory     = 0x35
-	fifo          = 0x36
-	gnu_long_path = 0x4c
-}
-
-fn octal_to_int(s string) u64 {
-	mut ret := u64(0)
-	for c in s {
-		ret *= 8
-		ret += u64(c) - 0x30
-	}
-	return ret
-}
-
-@[_linker_section: '.requests']
-@[cinit]
-__global (
-	volatile module_req = limine.LimineModuleRequest{
-		response: unsafe { nil }
-	}
-)
-
-@[manualfree]
-pub fn initialise() {
-	if module_req.response == unsafe { nil } {
-		panic('Modules bootloader response missing')
-	}
-
-	if module_req.response.module_count < 1 {
-		panic('No initramfs')
-	}
-
-	mut modules := module_req.response.modules
-
-	initramfs_begin := unsafe { modules[0].address }
-	initramfs_size := unsafe { modules[0].size }
-
-	println('initramfs: Address: 0x${voidptr(initramfs_begin):x}')
-	println('initramfs: Size:    ${u32(initramfs_size):u}')
-
-	print('initramfs: Unpacking...')
-
-	mut name_override := ''
-	mut current_header := &USTARHeader(unsafe { nil })
-	unsafe {
-		current_header = &USTARHeader(initramfs_begin)
-	}
-	for {
-		sig := unsafe { tos(&current_header.signature[0], 5) }
-		if sig != 'ustar' {
-			break
-		}
-
-		name := if name_override == '' {
-			unsafe { tos2(&current_header.name[0]) }
-		} else {
-			name_override
-		}
-		link_name := unsafe { tos2(&current_header.link_name[0]) }
-		size := unsafe { octal_to_int(tos2(&current_header.size[0])) }
-		mode := unsafe { octal_to_int(tos2(&current_header.mode[0])) }
-
-		name_override = ''
-		if name == './' {
-			unsafe {
-				goto next
-			}
-		}
-
-		match unsafe { USTARFileType(current_header.filetype) } {
-			.gnu_long_path {
-				// limit for safety
-				if size >= 65536 {
-					panic('initramfs: long file name exceeds 65536 characters.')
-				}
-
-				name_override = unsafe { tos(voidptr(u64(current_header) + 512), int(size)) }
-			}
-			.directory {
-				fs.create(vfs_root, name, u32(mode | stat.ifdir)) or {
-					panic('initramfs: failed to create directory ${name}')
-				}
-			}
-			.regular_file {
-				new_node := fs.create(vfs_root, name, u32(mode | stat.ifreg)) or {
-					panic('initramfs: failed to create file ${name}')
-				}
-				mut new_resource := new_node.resource
-				buf := voidptr(u64(current_header) + 512)
-				new_resource.write(0, buf, 0, size) or {
-					panic('initramfs: failed to write file ${name}')
-				}
-			}
-			.hard_link {
-				fs.link(vfs_root, link_name, name) or {
-					panic('initramfs: failed to create link ${name}')
-				}
-			}
-			.sym_link {
-				fs.symlink(vfs_root, link_name, name) or {
-					panic('initramfs: failed to create symlink ${name}')
-				}
-			}
-			else {}
-		}
-
-		next:
-		// memory.pmm_free(voidptr(u64(current_header) - higher_half), (u64(512) +
-		//	lib.align_up(size, 512)) / page_size)
-
-		current_header = unsafe {
-			&USTARHeader(usize(current_header) + usize(512) + usize(lib.align_up(size, 512)))
-		}
-	}
-
-	print('\ninitramfs: Done.\n')
-}
diff --git a/kernel/modules/ioctl/common.v b/kernel/modules/ioctl/common.v
deleted file mode 100644
index b84ad3a..0000000
--- a/kernel/modules/ioctl/common.v
+++ /dev/null
@@ -1,40 +0,0 @@
-module ioctl
-
-// https://github.com/torvalds/linux/blob/5bfc75d92efd494db37f5c4c173d3639d4772966/include/uapi/asm-generic/ioctl.h
-
-pub const fionread = 0x541b
-
-pub const ioc_nrbits = 8
-pub const ioc_typebits = 8
-pub const ioc_sizebits = 14
-pub const ioc_dirbits = 2
-
-pub const ioc_nrmask = ((1 << ioc_nrbits) - 1)
-pub const ioc_typemask = ((1 << ioc_typebits) - 1)
-pub const ioc_sizemask = ((1 << ioc_sizebits) - 1)
-pub const ioc_dirmask = ((1 << ioc_dirbits) - 1)
-
-pub const ioc_nrshift = 0
-pub const ioc_typeshift = (ioc_nrshift + ioc_nrbits)
-pub const ioc_sizeshift = (ioc_typeshift + ioc_typebits)
-pub const ioc_dirshift = (ioc_sizeshift + ioc_sizebits)
-
-@[inline]
-pub fn ioctl_dir(ioc u32) u32 {
-	return (ioc >> ioc_dirshift) & ioc_dirmask
-}
-
-@[inline]
-pub fn ioctl_type(ioc u32) u32 {
-	return (ioc >> ioc_typeshift) & ioc_typemask
-}
-
-@[inline]
-pub fn ioctl_size(ioc u32) u32 {
-	return (ioc >> ioc_sizeshift) & ioc_sizemask
-}
-
-@[inline]
-pub fn ioctl_nr(ioc u32) u32 {
-	return (ioc >> ioc_nrshift) & ioc_nrmask
-}
diff --git a/kernel/modules/ioctl/fbio.v b/kernel/modules/ioctl/fbio.v
deleted file mode 100644
index 010a01c..0000000
--- a/kernel/modules/ioctl/fbio.v
+++ /dev/null
@@ -1,9 +0,0 @@
-module ioctl
-
-pub const fbioget_vscreeninfo = 0x4600
-pub const fbioput_vscreeninfo = 0x4601
-pub const fbioget_fscreeninfo = 0x4602
-pub const fbiogetcmap = 0x4604
-pub const fbioputcmap = 0x4605
-pub const fbiopan_display = 0x4606
-pub const fbioblank = 0x4611
diff --git a/kernel/modules/ioctl/term.v b/kernel/modules/ioctl/term.v
deleted file mode 100644
index c51b7e6..0000000
--- a/kernel/modules/ioctl/term.v
+++ /dev/null
@@ -1,21 +0,0 @@
-module ioctl
-
-pub const tcgets = 0x5401
-
-pub const tcsets = 0x5402
-
-pub const tcsetsw = 0x5403
-
-pub const tcsetsf = 0x5404
-
-pub const tiocsctty = 0x540e
-
-pub const tiocgwinsz = 0x5413
-
-pub struct WinSize {
-pub mut:
-	ws_row    u16
-	ws_col    u16
-	ws_xpixel u16
-	ws_ypixel u16
-}
diff --git a/kernel/modules/katomic/katomic.v b/kernel/modules/katomic/katomic.v
deleted file mode 100644
index 8f3069e..0000000
--- a/kernel/modules/katomic/katomic.v
+++ /dev/null
@@ -1,97 +0,0 @@
-module katomic
-
-pub fn bts[T](mut var T, bit u8) bool {
-	mut ret := false
-	unsafe {
-		asm volatile amd64 {
-			lock bts var, bit
-			; +m (*var) as var
-			  =@ccc (ret)
-			; r (u16(bit)) as bit
-			; memory
-		}
-	}
-	return ret
-}
-
-pub fn btr[T](mut var T, bit u8) bool {
-	mut ret := false
-	unsafe {
-		asm volatile amd64 {
-			lock btr var, bit
-			; +m (*var) as var
-			  =@ccc (ret)
-			; r (u16(bit)) as bit
-			; memory
-		}
-	}
-	return ret
-}
-
-pub fn cas[T](mut here T, _ifthis T, writethis T) bool {
-	mut ret := false
-	mut ifthis := _ifthis
-	unsafe {
-		asm volatile amd64 {
-			lock cmpxchg here, writethis
-			; +a (ifthis)
-			  +m (*here) as here
-			  =@ccz (ret)
-			; r (writethis)
-			; memory
-		}
-	}
-	return ret
-}
-
-pub fn inc[T](mut var T) T {
-	mut diff := unsafe { T(1) }
-	unsafe {
-		asm volatile amd64 {
-			lock xadd var, diff
-			; +m (*var) as var
-			  +r (diff)
-			; ; memory
-		}
-	}
-	return diff
-}
-
-pub fn dec[T](mut var T) bool {
-	mut ret := false
-	unsafe {
-		mut diff := T(-1)
-		asm volatile amd64 {
-			lock xadd var, diff
-			; +m (*var) as var
-			  +r (diff)
-			  =@ccnz (ret)
-			; ; memory
-		}
-	}
-	return ret
-}
-
-pub fn store[T](mut var T, value T) {
-	unsafe {
-		asm volatile amd64 {
-			lock xchg var, value
-			; +m (*var) as var
-			  +r (value)
-			; ; memory
-		}
-	}
-}
-
-pub fn load[T](var &T) T {
-	mut ret := unsafe { T(0) }
-	unsafe {
-		asm volatile amd64 {
-			lock xadd var, ret
-			; +m (*var) as var
-			  +r (ret)
-			; ; memory
-		}
-	}
-	return ret
-}
diff --git a/kernel/modules/klock/klock.v b/kernel/modules/klock/klock.v
deleted file mode 100644
index 9dfd1a9..0000000
--- a/kernel/modules/klock/klock.v
+++ /dev/null
@@ -1,42 +0,0 @@
-module klock
-
-import katomic
-import x86.cpu
-
-pub struct Lock {
-pub mut:
-	l    bool
-	ints bool
-}
-
-fn C.__builtin_return_address(int) voidptr
-
-pub fn (mut l Lock) acquire() {
-	for {
-		if l.test_and_acquire() == true {
-			return
-		}
-		asm volatile amd64 {
-			pause
-			; ; ; memory
-		}
-	}
-}
-
-pub fn (mut l Lock) release() {
-	katomic.store(mut &l.l, false)
-	cpu.interrupt_toggle(l.ints)
-}
-
-pub fn (mut l Lock) test_and_acquire() bool {
-	ints := cpu.interrupt_toggle(false)
-
-	ret := katomic.cas(mut &l.l, false, true)
-	if ret == true {
-		l.ints = ints
-	} else {
-		cpu.interrupt_toggle(ints)
-	}
-
-	return ret
-}
diff --git a/kernel/modules/kprint/kprint.v b/kernel/modules/kprint/kprint.v
deleted file mode 100644
index 924b449..0000000
--- a/kernel/modules/kprint/kprint.v
+++ /dev/null
@@ -1,48 +0,0 @@
-@[has_globals]
-module kprint
-
-import klock
-import dev.serial
-import term
-
-@[markused]
-__global (
-	printf_lock klock.Lock
-	kprint_lock klock.Lock
-)
-
-pub fn syscall_kprint(_ voidptr, message charptr) {
-	$if !prod {
-		msglen := unsafe { u64(C.strlen(message)) }
-
-		kprint_lock.acquire()
-
-		unsafe {
-			for i := 0; i < msglen; i++ {
-				serial.out(message[i])
-			}
-			serial.out(`\n`)
-		}
-		kprint_lock.release()
-	}
-}
-
-pub fn kwrite(message charptr, msglen u64) {
-	kprint_lock.acquire()
-
-	$if !prod {
-		unsafe {
-			for i := 0; i < msglen; i++ {
-				serial.out(message[i])
-			}
-		}
-	}
-
-	term.print(message, msglen)
-
-	kprint_lock.release()
-}
-
-fn C.byteptr_vstring(byteptr) string
-fn C.byteptr_vstring_with_len(byteptr, int) string
-fn C.char_vstring(charptr) string
diff --git a/kernel/modules/lib/bit.v b/kernel/modules/lib/bit.v
deleted file mode 100644
index 3ade9af..0000000
--- a/kernel/modules/lib/bit.v
+++ /dev/null
@@ -1,29 +0,0 @@
-module lib
-
-pub fn bittest(bitmap voidptr, index u64) bool {
-	unsafe {
-		mut fbitmap := &u64(bitmap)
-		bits_type := sizeof(u64) * 8
-		test_index := index % bits_type
-		test_sample := fbitmap[index / bits_type]
-		return ((test_sample >> test_index) & u64(1)) != 0
-	}
-}
-
-pub fn bitset(bitmap voidptr, index u64) {
-	unsafe {
-		mut fbitmap := &u64(bitmap)
-		bits_type := sizeof(u64) * 8
-		test_index := index % bits_type
-		fbitmap[index / bits_type] |= u64(1) << test_index
-	}
-}
-
-pub fn bitreset(bitmap voidptr, index u64) {
-	unsafe {
-		mut fbitmap := &u64(bitmap)
-		bits_type := sizeof(u64) * 8
-		test_index := index % bits_type
-		fbitmap[index / bits_type] &= ~(u64(1) << test_index)
-	}
-}
diff --git a/kernel/modules/lib/math.v b/kernel/modules/lib/math.v
deleted file mode 100644
index 476ac38..0000000
--- a/kernel/modules/lib/math.v
+++ /dev/null
@@ -1,35 +0,0 @@
-module lib
-
-pub fn div_roundup[T](a T, b T) T {
-	return (a + (b - 1)) / b
-}
-
-pub fn align_up(value u64, alignment u64) u64 {
-	return div_roundup(value, alignment) * alignment
-}
-
-pub fn align_down(value u64, alignment u64) u64 {
-	return (value / alignment) * alignment
-}
-
-pub fn power(base u64, exp u64) u64 {
-	mut result := u64(1)
-	mut tmp_base := base
-	mut tmp_exp := exp
-
-	for {
-		if tmp_exp & 1 != 0 {
-			result *= tmp_base
-		}
-
-		tmp_exp >>= 1
-
-		if tmp_exp <= 0 {
-			break
-		}
-
-		tmp_base *= tmp_base
-	}
-
-	return result
-}
diff --git a/kernel/modules/lib/panic.v b/kernel/modules/lib/panic.v
deleted file mode 100644
index e1dbc17..0000000
--- a/kernel/modules/lib/panic.v
+++ /dev/null
@@ -1,59 +0,0 @@
-@[has_globals]
-module lib
-
-import x86.apic
-import x86.cpu.local as cpulocal
-import x86.cpu
-import katomic as _
-import klock
-
-__global (
-	kpanic_lock klock.Lock
-)
-
-fn C.printf_panic(charptr, ...voidptr)
-
-@[noreturn]
-pub fn kpanic(gpr_state &cpulocal.GPRState, message charptr) {
-	kpanic_lock.acquire()
-
-	asm volatile amd64 {
-		cli
-	}
-	if smp_ready {
-		for cpu_local in cpu_locals {
-			if cpulocal.current().lapic_id == cpu_local.lapic_id {
-				continue
-			}
-			apic.lapic_send_ipi(u8(cpu_local.lapic_id), abort_vector)
-		}
-	}
-
-	cpu_number := if smp_ready { cpulocal.current().cpu_number } else { 0 }
-
-	C.printf_panic(c'\n  *** Vinix KERNEL PANIC on CPU %d ***\n\n', cpu_number)
-	C.printf_panic(c'Panic info: %s\n', message)
-	if gpr_state != unsafe { nil } {
-		C.printf_panic(c'Error code: 0x%016llx\n', gpr_state.err)
-		C.printf_panic(c'Register dump:\n')
-		C.printf_panic(c'CS:RIP=%04llx:%016llx\n', gpr_state.cs, gpr_state.rip)
-		C.printf_panic(c'SS:RSP=%04llx:%016llx\n', gpr_state.ss, gpr_state.rsp)
-		C.printf_panic(c'RFLAGS=%08llx       CR2=%016llx\n', gpr_state.rflags, cpu.read_cr2())
-		C.printf_panic(c'RAX=%016llx  RBX=%016llx  RCX=%016llx  RDX=%016llx\n', gpr_state.rax,
-			gpr_state.rbx, gpr_state.rcx, gpr_state.rdx)
-		C.printf_panic(c'RSI=%016llx  RDI=%016llx  RBP=%016llx  RSP=%016llx\n', gpr_state.rsi,
-			gpr_state.rdi, gpr_state.rbp, gpr_state.rsp)
-		C.printf_panic(c'R08=%016llx  R09=%016llx  R10=%016llx  R11=%016llx\n', gpr_state.r8,
-			gpr_state.r9, gpr_state.r10, gpr_state.r11)
-		C.printf_panic(c'R12=%016llx  R13=%016llx  R14=%016llx  R15=%016llx\n', gpr_state.r12,
-			gpr_state.r13, gpr_state.r14, gpr_state.r15)
-	}
-
-	for {
-		asm volatile amd64 {
-			hlt
-		}
-	}
-
-	for {}
-}
diff --git a/kernel/modules/lib/stubs/file.v b/kernel/modules/lib/stubs/file.v
deleted file mode 100644
index e3ce2f2..0000000
--- a/kernel/modules/lib/stubs/file.v
+++ /dev/null
@@ -1,62 +0,0 @@
-@[has_globals]
-module stubs
-
-import lib
-import kprint
-
-struct C.__file {}
-
-type FILE = C.__file
-
-@[markused]
-__global (
-	stdin  = &FILE(unsafe { nil })
-	stdout = &FILE(unsafe { nil })
-	stderr = &FILE(unsafe { nil })
-)
-
-@[export: 'fflush']
-pub fn fflush(stream &FILE) int {
-	return 0
-}
-
-@[export: 'getchar']
-pub fn getchar() int {
-	lib.kpanic(unsafe { nil }, c'getchar is a stub')
-}
-
-@[export: 'getc']
-pub fn getc(stream &FILE) int {
-	lib.kpanic(unsafe { nil }, c'getc is a stub')
-}
-
-@[export: 'fgets']
-pub fn fgets(str charptr, count u64, stream &FILE) charptr {
-	lib.kpanic(unsafe { nil }, c'fgets is a stub')
-}
-
-@[export: 'popen']
-pub fn popen(command &char, typ &char) &FILE {
-	lib.kpanic(unsafe { nil }, c'popen is a stub')
-}
-
-@[export: 'pclose']
-pub fn pclose(stream &FILE) int {
-	lib.kpanic(unsafe { nil }, c'pclose is a stub')
-}
-
-@[export: 'write']
-pub fn write(fd int, buf voidptr, count u64) i64 {
-	if fd != 1 && fd != 2 {
-		lib.kpanic(unsafe { nil }, c'write to fd != 1 && fd != 2 is a stub')
-	}
-
-	kprint.kwrite(charptr(buf), count)
-
-	return i64(count)
-}
-
-@[export: 'isatty']
-pub fn isatty(fd int) int {
-	return 1
-}
diff --git a/kernel/modules/lib/stubs/misc.v b/kernel/modules/lib/stubs/misc.v
deleted file mode 100644
index 806a1aa..0000000
--- a/kernel/modules/lib/stubs/misc.v
+++ /dev/null
@@ -1,19 +0,0 @@
-module stubs
-
-import lib
-
-@[export: '__ctype_tolower_loc']
-pub fn ctype_tolower_loc() &&int {
-	lib.kpanic(unsafe { nil }, c'__ctype_tolower_loc is a stub')
-}
-
-@[export: '__ctype_toupper_loc']
-pub fn ctype_toupper_loc() &&int {
-	lib.kpanic(unsafe { nil }, c'__ctype_toupper_loc is a stub')
-}
-
-@[export: 'exit']
-@[noreturn]
-pub fn kexit(code int) {
-	lib.kpanic(unsafe { nil }, c'Kernel has called exit()')
-}
diff --git a/kernel/modules/lib/stubs/pthread.v b/kernel/modules/lib/stubs/pthread.v
deleted file mode 100644
index c153123..0000000
--- a/kernel/modules/lib/stubs/pthread.v
+++ /dev/null
@@ -1,43 +0,0 @@
-module stubs
-
-import lib
-import sched
-import event
-import proc
-
-struct C.__thread_data {}
-
-struct C.__threadattr {}
-
-@[export: 'pthread_create']
-pub fn pthread_create(t &&C.__thread_data, attr &C.__threadattr, start_routine fn (voidptr) voidptr, arg voidptr) int {
-	if attr != unsafe { nil } {
-		lib.kpanic(unsafe { nil }, c'pthread_create() called with non-NULL attr')
-	}
-
-	unsafe {
-		mut ptr := &voidptr(t)
-		*ptr = sched.new_kernel_thread(voidptr(start_routine), arg, true)
-	}
-	return 0
-}
-
-@[export: 'pthread_detach']
-pub fn pthread_detach(t &C.__thread_data) int {
-	return 0
-}
-
-@[export: 'pthread_join']
-pub fn pthread_join(t &C.__thread_data, mut retval voidptr) int {
-	unsafe {
-		*retval = event.pthread_wait(&proc.Thread(t))
-	}
-	return 0
-}
-
-@[export: 'pthread_exit']
-@[noreturn]
-pub fn pthread_exit(retval voidptr) {
-	event.pthread_exit(retval)
-	for {}
-}
diff --git a/kernel/modules/lib/stubs/string.v b/kernel/modules/lib/stubs/string.v
deleted file mode 100644
index 4b69be4..0000000
--- a/kernel/modules/lib/stubs/string.v
+++ /dev/null
@@ -1,135 +0,0 @@
-module stubs
-
-@[export: 'toupper']
-pub fn toupper(c int) int {
-	return if c >= int(`a`) && c <= int(`z`) { c - 0x20 } else { c }
-}
-
-@[export: 'memset64']
-pub fn memset64(dest voidptr, c int, size u64) voidptr {
-	unsafe {
-		mut destm := &u64(dest)
-
-		for i := 0; i < size; i++ {
-			destm[i] = u64(c)
-		}
-	}
-	return dest
-}
-
-@[export: 'strcpy']
-pub fn strcpy(dest &char, src &char) &char {
-	mut i := u64(0)
-
-	unsafe {
-		mut destm := &u8(voidptr(dest))
-		srcm := &u8(voidptr(src))
-
-		for {
-			if srcm[i] != 0 {
-				destm[i] = srcm[i]
-			} else {
-				destm[i] = u8(0)
-				return dest
-			}
-
-			i++
-		}
-
-		return dest
-	}
-}
-
-@[export: 'strncpy']
-pub fn strncpy(dest &char, src &char, n u64) &char {
-	mut i := u64(0)
-
-	unsafe {
-		mut destm := &u8(voidptr(dest))
-		srcm := &u8(voidptr(src))
-
-		for {
-			if i >= n {
-				return dest
-			}
-
-			if srcm[i] != 0 {
-				destm[i] = srcm[i]
-			} else {
-				break
-			}
-
-			i++
-		}
-
-		for j := i; j < n; j++ {
-			destm[j] = 0
-		}
-
-		return dest
-	}
-}
-
-@[export: 'strcmp']
-pub fn strcmp(_s1 &char, _s2 &char) int {
-	unsafe {
-		mut i := u64(0)
-		s1 := &u8(_s1)
-		s2 := &u8(_s2)
-
-		for {
-			c1 := s1[i]
-			c2 := s2[i]
-
-			if c1 != c2 {
-				return int(c1) - int(c2)
-			}
-
-			if c1 == 0 {
-				return 0
-			}
-
-			i++
-		}
-	}
-	return 0
-}
-
-@[export: 'strncmp']
-pub fn strncmp(_s1 &char, _s2 &char, size u64) int {
-	unsafe {
-		s1 := &u8(_s1)
-		s2 := &u8(_s2)
-
-		for i := 0; i < size; i++ {
-			c1 := s1[i]
-			c2 := s2[i]
-
-			if c1 != c2 {
-				return int(c1) - int(c2)
-			}
-
-			if c1 == 0 {
-				return 0
-			}
-		}
-	}
-	return 0
-}
-
-@[export: 'strlen']
-pub fn strlen(_ptr &char) u64 {
-	mut i := u64(0)
-
-	unsafe {
-		ptr := &u8(voidptr(_ptr))
-		for {
-			if ptr[i] == 0 {
-				break
-			}
-
-			i++
-		}
-	}
-	return i
-}
diff --git a/kernel/modules/limine/limine.v b/kernel/modules/limine/limine.v
deleted file mode 100644
index a3fb093..0000000
--- a/kernel/modules/limine/limine.v
+++ /dev/null
@@ -1,409 +0,0 @@
-@[has_globals]
-module limine
-
-@[_linker_section: '.requests_start_marker']
-@[cinit]
-__global (
-	volatile limine_requests_start_marker = [
-		u64(0xf6b8f4b39de7d1ae),
-		0xfab91a6940fcb9cf,
-		0x785c6ed015d3e316,
-		0x181e920a7852b9d9,
-	]!
-)
-
-@[_linker_section: '.requests_end_marker']
-@[cinit]
-__global (
-	volatile limine_requests_end_marker = [
-		u64(0xadc0e0531bb10d03),
-		0x9572709f31764c62,
-	]!
-)
-
-pub struct LimineBaseRevision {
-pub mut:
-	id       [2]u64 = [u64(0xf9562b2d5c95a6c8), 0x6a7b384944536bdc]!
-	revision u64
-}
-
-pub struct LimineUUID {
-pub mut:
-	a u32
-	b u16
-	c u16
-	d [8]u8
-}
-
-pub struct LimineFile {
-pub mut:
-	revision        u64
-	address         voidptr
-	size            u64
-	path            charptr
-	cmdline         charptr
-	media_type      u32
-	unused          u32
-	tftp_ip         u32
-	tftp_port       u32
-	partition_index u32
-	mbr_disk_id     u32
-	gpt_disk_uuid   LimineUUID
-	gpt_part_uuid   LimineUUID
-	part_uuid       LimineUUID
-}
-
-// Boot info
-
-pub struct LimineBootloaderInfoResponse {
-pub mut:
-	revision u64
-	name     charptr
-	version  charptr
-}
-
-pub struct LimineBootloaderInfoRequest {
-pub mut:
-	id       [4]u64 = [
-	u64(0xc7b1dd30df4c8b88),
-	0x0a82e883a194f07b,
-	0xf55038d8e2a1202f,
-	0x279426fcf5f59740,
-]!
-	revision u64
-	response &LimineBootloaderInfoResponse
-}
-
-// Stack size
-
-pub struct LimineStackSizeResponse {
-pub mut:
-	revision u64
-}
-
-pub struct LimineStackSizeRequest {
-pub mut:
-	id         [4]u64 = [
-	u64(0xc7b1dd30df4c8b88),
-	0x0a82e883a194f07b,
-	0x224ef0460a8e8926,
-	0xe1cb0fc25f46ea3d,
-]!
-	revision   u64
-	response   &LimineStackSizeResponse
-	stack_size u64
-}
-
-// HHDM
-
-pub struct LimineHHDMResponse {
-pub mut:
-	revision u64
-	offset   u64
-}
-
-pub struct LimineHHDMRequest {
-pub mut:
-	id       [4]u64 = [
-	u64(0xc7b1dd30df4c8b88),
-	0x0a82e883a194f07b,
-	0x48dcf1cb8ad2b852,
-	0x63984e959a98244b,
-]!
-	revision u64
-	response &LimineHHDMResponse
-}
-
-// Framebuffer
-
-pub struct LimineFramebuffer {
-pub mut:
-	address          voidptr
-	width            u64
-	height           u64
-	pitch            u64
-	bpp              u16
-	memory_model     u8
-	red_mask_size    u8
-	red_mask_shift   u8
-	green_mask_size  u8
-	green_mask_shift u8
-	blue_mask_size   u8
-	blue_mask_shift  u8
-	unused           u8
-	edid_size        u64
-	edid             voidptr
-}
-
-pub struct LimineFramebufferResponse {
-pub mut:
-	revision          u64
-	framebuffer_count u64
-	framebuffers      &&LimineFramebuffer
-}
-
-pub struct LimineFramebufferRequest {
-pub mut:
-	id       [4]u64 = [
-	u64(0xc7b1dd30df4c8b88),
-	0x0a82e883a194f07b,
-	0x9d5827dcd881dd75,
-	0xa3148604f6fab11b,
-]!
-	revision u64
-	response &LimineFramebufferResponse
-}
-
-// Paging mode
-
-pub const limine_paging_mode_x86_64_4lvl = 0
-pub const limine_paging_mode_x86_64_5lvl = 1
-
-pub struct LiminePagingModeResponse {
-pub mut:
-	revision u64
-	mode     u64
-}
-
-pub struct LiminePagingModeRequest {
-pub mut:
-	id       [4]u64 = [
-	u64(0xc7b1dd30df4c8b88),
-	0x0a82e883a194f07b,
-	0x95c1a0edab0944cb,
-	0xa4e5cb3842f7488a,
-]!
-	revision u64
-	response &LiminePagingModeResponse
-	mode     u64
-	max_mode u64
-	min_mode u64
-}
-
-// SMP
-
-pub struct LimineSMPInfo {
-pub mut:
-	processor_id   u32
-	lapic_id       u32
-	reserved       u64
-	goto_address   fn (&LimineSMPInfo) = unsafe { nil }
-	extra_argument u64
-}
-
-pub struct LimineSMPResponse {
-pub mut:
-	revision     u64
-	flags        u32
-	bsp_lapic_id u32
-	cpu_count    u64
-	cpus         &&LimineSMPInfo
-}
-
-pub struct LimineSMPRequest {
-pub mut:
-	id       [4]u64 = [
-	u64(0xc7b1dd30df4c8b88),
-	0x0a82e883a194f07b,
-	0x95a67b819a1b857e,
-	0xa0b61b723b6a73e0,
-]!
-	revision u64
-	response &LimineSMPResponse
-	flags    u64
-}
-
-// Memory map
-
-pub const limine_memmap_usable = 0
-pub const limine_memmap_bootloader_reclaimable = 5
-pub const limine_memmap_kernel_and_modules = 6
-
-pub struct LimineMemmapEntry {
-pub mut:
-	base   u64
-	length u64
-	@type  u64
-}
-
-pub struct LimineMemmapResponse {
-pub mut:
-	revision    u64
-	entry_count u64
-	entries     &&LimineMemmapEntry
-}
-
-pub struct LimineMemmapRequest {
-pub mut:
-	id       [4]u64 = [
-	u64(0xc7b1dd30df4c8b88),
-	0x0a82e883a194f07b,
-	0x67cf3d9d378a806f,
-	0xe304acdfc50c3c62,
-]!
-	revision u64
-	response &LimineMemmapResponse
-}
-
-// Entry point
-
-pub struct LimineEntryPointResponse {
-pub mut:
-	revision u64
-}
-
-pub struct LimineEntryPointRequest {
-pub mut:
-	id       [4]u64 = [
-	u64(0xc7b1dd30df4c8b88),
-	0x0a82e883a194f07b,
-	0x13d86c035a1cd3e1,
-	0x2b0caa89d8f3026a,
-]!
-	revision u64
-	response &LimineEntryPointResponse
-	entry    fn () = unsafe { nil }
-}
-
-// Kernel file
-
-pub struct LimineKernelFileResponse {
-pub mut:
-	revision    u64
-	kernel_file &LimineFile
-}
-
-pub struct LimineKernelFileRequest {
-pub mut:
-	id       [4]u64 = [
-	u64(0xc7b1dd30df4c8b88),
-	0x0a82e883a194f07b,
-	0xad97e90e83f1ed67,
-	0x31eb5d1c5ff23b69,
-]!
-	revision u64
-	response &LimineKernelFileResponse
-}
-
-// Module
-
-pub struct LimineModuleResponse {
-pub mut:
-	revision     u64
-	module_count u64
-	modules      &&LimineFile
-}
-
-pub struct LimineModuleRequest {
-pub mut:
-	id       [4]u64 = [
-	u64(0xc7b1dd30df4c8b88),
-	0x0a82e883a194f07b,
-	0x3e7e279702be32af,
-	0xca1c4f3bd1280cee,
-]!
-	revision u64
-	response &LimineModuleResponse
-}
-
-// RSDP
-
-pub struct LimineRSDPResponse {
-pub mut:
-	revision u64
-	address  voidptr
-}
-
-pub struct LimineRSDPRequest {
-pub mut:
-	id       [4]u64 = [
-	u64(0xc7b1dd30df4c8b88),
-	0x0a82e883a194f07b,
-	0xc5e77b6b397e7b43,
-	0x27637845accdcf3c,
-]!
-	revision u64
-	response &LimineRSDPResponse
-}
-
-// SMBIOS
-
-pub struct LimineSMBIOSResponse {
-pub mut:
-	revision u64
-	entry_32 voidptr
-	entry_64 voidptr
-}
-
-pub struct LimineSMBIOSRequest {
-pub mut:
-	id       [4]u64 = [
-	u64(0xc7b1dd30df4c8b88),
-	0x0a82e883a194f07b,
-	0x9e9046f11e095391,
-	0xaa4a520fefbde5ee,
-]!
-	revision u64
-	response &LimineSMBIOSResponse
-}
-
-// EFI system table
-
-pub struct LimineEFISystemTableResponse {
-pub mut:
-	revision u64
-	address  voidptr
-}
-
-pub struct LimineEFISystemTableRequest {
-pub mut:
-	id       [4]u64 = [
-	u64(0xc7b1dd30df4c8b88),
-	0x0a82e883a194f07b,
-	0x5ceba5163eaaf6d6,
-	0x0a6981610cf65fcc,
-]!
-	revision u64
-	response &LimineEFISystemTableResponse
-}
-
-// Boot time
-
-pub struct LimineBootTimeResponse {
-pub mut:
-	revision  u64
-	boot_time i64
-}
-
-pub struct LimineBootTimeRequest {
-pub mut:
-	id       [4]u64 = [
-	u64(0xc7b1dd30df4c8b88),
-	0x0a82e883a194f07b,
-	0x502746e184c088aa,
-	0xfbc5ec83e6327893,
-]!
-	revision u64
-	response &LimineBootTimeResponse
-}
-
-// Kernel address
-
-pub struct LimineKernelAddressResponse {
-pub mut:
-	revision      u64
-	physical_base u64
-	virtual_base  u64
-}
-
-pub struct LimineKernelAddressRequest {
-pub mut:
-	id       [4]u64 = [
-	u64(0xc7b1dd30df4c8b88),
-	0x0a82e883a194f07b,
-	0x71ba76863cc55f63,
-	0xb2644a48c516a487,
-]!
-	revision u64
-	response &LimineKernelAddressResponse
-}
diff --git a/kernel/modules/memory/mmap/mmap.v b/kernel/modules/memory/mmap/mmap.v
deleted file mode 100644
index 8648258..0000000
--- a/kernel/modules/memory/mmap/mmap.v
+++ /dev/null
@@ -1,541 +0,0 @@
-module mmap
-
-import memory
-import resource
-import proc
-import errno
-import x86.cpu
-import x86.cpu.local as cpulocal
-import lib
-
-pub const prot_none = 0x00
-pub const prot_read = 0x01
-pub const prot_write = 0x02
-pub const prot_exec = 0x04
-pub const map_private = 0x02
-pub const map_shared = 0x01
-pub const map_fixed = 0x10
-pub const map_anon = 0x20
-pub const map_anonymous = 0x20
-
-pub struct MmapRangeLocal {
-pub mut:
-	pagemap &memory.Pagemap  = unsafe { nil }
-	global  &MmapRangeGlobal = unsafe { nil }
-	base    u64
-	length  u64
-	offset  i64
-	prot    int
-	flags   int
-}
-
-pub struct MmapRangeGlobal {
-pub mut:
-	shadow_pagemap memory.Pagemap
-	locals         []&MmapRangeLocal
-	resource       &resource.Resource = unsafe { nil }
-	base           u64
-	length         u64
-	offset         i64
-}
-
-pub fn list_ranges(pagemap &memory.Pagemap) {
-	C.printf(c'Ranges for %llx:\n', voidptr(pagemap))
-	for i := u64(0); i < pagemap.mmap_ranges.len; i++ {
-		r := unsafe { &MmapRangeLocal(pagemap.mmap_ranges[i]) }
-		C.printf(c'                                Base: %p  Length: %p  Offset: %p\n',
-			r.base, r.length, r.offset)
-		C.printf(c'    Global: %p  Base: %p  Length: %p  Offset: %p\n', r.global, r.global.base,
-			r.global.length, r.global.offset)
-	}
-}
-
-fn addr2range(pagemap &memory.Pagemap, addr u64) ?(&MmapRangeLocal, u64, u64) {
-	for i := u64(0); i < pagemap.mmap_ranges.len; i++ {
-		r := unsafe { &MmapRangeLocal(pagemap.mmap_ranges[i]) }
-		if addr >= r.base && addr < r.base + r.length {
-			memory_page := addr / page_size
-			file_page := u64(r.offset) / page_size + (memory_page - r.base / page_size)
-			return r, memory_page, file_page
-		}
-	}
-	return none
-}
-
-pub fn delete_pagemap(mut pagemap memory.Pagemap) ? {
-	pagemap.l.acquire()
-
-	mmap_ranges := pagemap.mmap_ranges
-
-	for ptr in mmap_ranges {
-		local_range := unsafe { &MmapRangeLocal(ptr) }
-
-		munmap_unlocked(mut pagemap, voidptr(local_range.base), local_range.length) or {}
-	}
-
-	unsafe {
-		mmap_ranges.free()
-		pagemap.mmap_ranges.free()
-		free(pagemap)
-	}
-}
-
-pub fn fork_pagemap(_old_pagemap &memory.Pagemap) ?&memory.Pagemap {
-	mut old_pagemap := unsafe { _old_pagemap }
-	mut new_pagemap := memory.new_pagemap()
-
-	old_pagemap.l.acquire()
-	defer {
-		old_pagemap.l.release()
-	}
-
-	for ptr in old_pagemap.mmap_ranges {
-		local_range := unsafe { &MmapRangeLocal(ptr) }
-		mut global_range := local_range.global
-
-		mut new_local_range := &MmapRangeLocal{
-			pagemap: unsafe { nil }
-			global:  unsafe { nil }
-		}
-		unsafe {
-			*new_local_range = *local_range
-		}
-		new_local_range.pagemap = new_pagemap
-
-		if voidptr(global_range.resource) != unsafe { nil } {
-			global_range.resource.refcount++
-		}
-
-		if local_range.flags & map_shared != 0 {
-			global_range.locals << new_local_range
-			for i := local_range.base; i < local_range.base + local_range.length; i += page_size {
-				old_pte := old_pagemap.virt2pte(i, false) or { continue }
-				new_pte := new_pagemap.virt2pte(i, true) or { return none }
-				unsafe {
-					*new_pte = *old_pte
-				}
-			}
-		} else {
-			mut new_global_range := &MmapRangeGlobal{
-				resource:       unsafe { nil }
-				shadow_pagemap: memory.Pagemap{
-					top_level: unsafe { &u64(0) }
-				}
-			}
-
-			new_global_range.resource = global_range.resource
-			new_global_range.base = global_range.base
-			new_global_range.length = global_range.length
-			new_global_range.offset = global_range.offset
-
-			new_local_range.global = new_global_range
-
-			new_global_range.locals = []&MmapRangeLocal{}
-			new_global_range.locals << new_local_range
-
-			new_global_range.shadow_pagemap.top_level = &u64(memory.pmm_alloc(1))
-
-			if local_range.flags & map_anonymous != 0 {
-				for i := local_range.base; i < local_range.base + local_range.length; i += page_size {
-					old_pte := old_pagemap.virt2pte(i, false) or { continue }
-					if unsafe { *old_pte } & 1 == 0 {
-						continue
-					}
-					new_pte := new_pagemap.virt2pte(i, true) or { return none }
-					new_spte := new_global_range.shadow_pagemap.virt2pte(i, true) or { return none }
-					page := memory.pmm_alloc_nozero(1)
-					unsafe {
-						C.memcpy(voidptr(u64(page) + higher_half), voidptr(
-							(*old_pte & memory.pte_flags_mask) + higher_half), page_size)
-						*new_pte = (*old_pte & ~memory.pte_flags_mask) | u64(page)
-						*new_spte = *new_pte
-					}
-				}
-			} else {
-				panic('non anon fork')
-			}
-		}
-
-		new_pagemap.mmap_ranges << voidptr(new_local_range)
-	}
-
-	return new_pagemap
-}
-
-pub fn map_page_in_range(_g &MmapRangeGlobal, virt_addr u64, phys_addr u64, prot int) ? {
-	mut g := unsafe { _g }
-
-	mut pt_flags := memory.pte_present | memory.pte_user
-	if prot & prot_write != 0 {
-		pt_flags |= memory.pte_writable
-	}
-	if prot & prot_exec == 0 {
-		pt_flags |= memory.pte_noexec
-	}
-
-	g.shadow_pagemap.map_page(virt_addr, phys_addr, pt_flags) or { return none }
-
-	for i := u64(0); i < g.locals.len; i++ {
-		mut l := g.locals[i]
-		if virt_addr < l.base || virt_addr >= l.base + l.length {
-			continue
-		}
-		l.pagemap.map_page(virt_addr, phys_addr, pt_flags) or { return none }
-	}
-}
-
-pub fn map_range(mut pagemap memory.Pagemap, _virt_addr u64, phys_addr u64, _length u64, prot int, _flags int) ? {
-	flags := _flags | map_anonymous
-
-	virt_addr := lib.align_down(_virt_addr, page_size)
-	length := lib.align_up(_length + (_virt_addr - virt_addr), page_size)
-
-	mut range_local := &MmapRangeLocal{
-		pagemap: unsafe { pagemap }
-		base:    virt_addr
-		length:  length
-		prot:    prot
-		flags:   flags
-		global:  unsafe { nil }
-	}
-
-	mut range_global := &MmapRangeGlobal{
-		locals:         []&MmapRangeLocal{}
-		base:           virt_addr
-		length:         length
-		resource:       unsafe { nil }
-		shadow_pagemap: memory.Pagemap{
-			top_level: unsafe { &u64(0) }
-		}
-	}
-
-	range_local.global = range_global
-
-	range_global.locals << range_local
-	range_global.shadow_pagemap.top_level = &u64(memory.pmm_alloc(1))
-
-	pagemap.l.acquire()
-	pagemap.mmap_ranges << voidptr(range_local)
-	pagemap.l.release()
-
-	for i := u64(0); i < length; i += page_size {
-		map_page_in_range(range_global, virt_addr + i, phys_addr + i, prot) or { return none }
-	}
-}
-
-pub fn pf_handler(gpr_state &cpulocal.GPRState) ? {
-	if gpr_state.err & 1 != 0 {
-		// It was a protection violation, crash
-		return none
-	}
-
-	mut current_thread := proc.current_thread()
-
-	asm volatile amd64 {
-		sti
-	}
-	defer {
-		asm volatile amd64 {
-			cli
-		}
-	}
-
-	mut process := current_thread.process
-	mut pagemap := process.pagemap
-
-	addr := cpu.read_cr2()
-
-	pagemap.l.acquire()
-
-	mut range_local, memory_page, file_page := addr2range(pagemap, addr) or {
-		pagemap.l.release()
-		return none
-	}
-
-	pagemap.l.release()
-
-	mut page := unsafe { nil }
-
-	if range_local.flags & map_anonymous != 0 {
-		page = memory.pmm_alloc(1)
-	} else {
-		page = range_local.global.resource.mmap(file_page, range_local.flags)
-	}
-
-	map_page_in_range(range_local.global, memory_page * page_size, u64(page), range_local.prot) or {
-		return none
-	}
-}
-
-pub fn mmap(_pagemap &memory.Pagemap, addr voidptr, _length u64, prot int, flags int, _resource &resource.Resource, offset i64) ?voidptr {
-	mut pagemap := unsafe { _pagemap }
-	mut resource_ := unsafe { _resource }
-
-	if _length == 0 {
-		C.printf(c'mmap: length is 0\n')
-		errno.set(errno.einval)
-		return none
-	}
-
-	length := lib.align_up(_length, page_size)
-
-	if flags & map_anonymous == 0 && resource_.can_mmap == false {
-		errno.set(errno.enodev)
-		return none
-	}
-
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	mut base := u64(0)
-	if flags & map_fixed != 0 {
-		base = u64(addr)
-
-		munmap(mut pagemap, voidptr(base), length)?
-	} else {
-		base = process.mmap_anon_non_fixed_base
-		process.mmap_anon_non_fixed_base += length + page_size
-	}
-
-	mut range_local := &MmapRangeLocal{
-		pagemap: pagemap
-		base:    base
-		length:  length
-		offset:  offset
-		prot:    prot
-		flags:   flags
-		global:  unsafe { nil }
-	}
-
-	mut range_global := &MmapRangeGlobal{
-		locals:         []&MmapRangeLocal{}
-		base:           base
-		length:         length
-		resource:       resource_
-		offset:         offset
-		shadow_pagemap: memory.Pagemap{
-			top_level: unsafe { &u64(0) }
-		}
-	}
-
-	range_local.global = range_global
-
-	range_global.locals << range_local
-	range_global.shadow_pagemap.top_level = &u64(memory.pmm_alloc(1))
-
-	pagemap.l.acquire()
-	pagemap.mmap_ranges << voidptr(range_local)
-	pagemap.l.release()
-
-	if voidptr(resource_) != unsafe { nil } {
-		resource_.refcount++
-	}
-
-	return voidptr(base)
-}
-
-pub fn syscall_munmap(_ voidptr, addr voidptr, length u64) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: munmap(0x%llx, 0x%llx)\n', process.name.str, addr, length)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	munmap(mut process.pagemap, addr, length) or { return errno.err, errno.get() }
-
-	return 0, 0
-}
-
-pub fn syscall_mprotect(_ voidptr, addr voidptr, length u64, prot int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: mprotect(0x%llx, 0x%llx, 0x%x)\n', process.name.str, addr,
-		length, prot)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mprotect(mut process.pagemap, addr, length, prot) or { return errno.err, errno.get() }
-
-	return 0, 0
-}
-
-pub fn mprotect(mut pagemap memory.Pagemap, addr voidptr, len u64, prot int) ? {
-	pagemap.l.acquire()
-	defer {
-		pagemap.l.release()
-	}
-
-	mprotect_unlocked(mut pagemap, addr, len, prot)?
-}
-
-pub fn mprotect_unlocked(mut pagemap memory.Pagemap, addr voidptr, _length u64, prot int) ? {
-	if _length == 0 {
-		C.printf(c'munmap: length is 0\n')
-		errno.set(errno.einval)
-		return none
-	}
-
-	length := lib.align_up(_length, page_size)
-
-	for i := u64(addr); i < u64(addr) + length; i += page_size {
-		mut local_range, _, _ := addr2range(pagemap, i) or { continue }
-
-		mut global_range := local_range.global
-
-		if local_range.prot == prot {
-			continue
-		}
-
-		snip_begin := i
-		for {
-			i += page_size
-			if i >= local_range.base + local_range.length || i >= u64(addr) + length {
-				break
-			}
-		}
-		snip_end := i
-		snip_size := snip_end - snip_begin
-
-		if snip_begin > local_range.base && snip_end < local_range.base + local_range.length {
-			// Create new range for portion after snip
-			mut postsplit_range := &MmapRangeLocal{
-				pagemap: local_range.pagemap
-				base:    snip_end
-				length:  (local_range.base + local_range.length) - snip_end
-				offset:  local_range.offset + i64(snip_end - local_range.base)
-				prot:    local_range.prot
-				flags:   local_range.flags
-				global:  local_range.global
-			}
-			global_range.locals << postsplit_range
-			pagemap.mmap_ranges << postsplit_range
-			local_range.length -= postsplit_range.length
-		}
-
-		for j := snip_begin; j < snip_end; j += page_size {
-			mut pt_flags := memory.pte_present | memory.pte_user
-			if prot & prot_write != 0 {
-				pt_flags |= memory.pte_writable
-			}
-			if prot & prot_exec == 0 {
-				pt_flags |= memory.pte_noexec
-			}
-			pagemap.flag_page(j, pt_flags) or {}
-		}
-
-		if snip_size == local_range.length {
-			local_range.prot = prot
-		} else {
-			new_offset := local_range.offset + i64(snip_begin - local_range.base)
-
-			if snip_begin == local_range.base {
-				local_range.offset += i64(snip_size)
-				local_range.base = snip_end
-			}
-			local_range.length -= snip_size
-
-			mut new_range := &MmapRangeLocal{
-				pagemap: local_range.pagemap
-				base:    snip_begin
-				length:  snip_size
-				offset:  new_offset
-				prot:    prot
-				flags:   local_range.flags
-				global:  local_range.global
-			}
-			global_range.locals << new_range
-			pagemap.mmap_ranges << new_range
-		}
-	}
-}
-
-pub fn munmap(mut pagemap memory.Pagemap, addr voidptr, len u64) ? {
-	pagemap.l.acquire()
-	defer {
-		pagemap.l.release()
-	}
-
-	munmap_unlocked(mut pagemap, addr, len)?
-}
-
-pub fn munmap_unlocked(mut pagemap memory.Pagemap, addr voidptr, _length u64) ? {
-	if _length == 0 {
-		C.printf(c'munmap: length is 0\n')
-		errno.set(errno.einval)
-		return none
-	}
-
-	length := lib.align_up(_length, page_size)
-
-	for i := u64(addr); i < u64(addr) + length; i += page_size {
-		mut local_range, _, _ := addr2range(pagemap, i) or { continue }
-
-		mut global_range := local_range.global
-
-		snip_begin := i
-		for {
-			i += page_size
-			if i >= local_range.base + local_range.length || i >= u64(addr) + length {
-				break
-			}
-		}
-		snip_end := i
-		snip_size := snip_end - snip_begin
-
-		if snip_begin > local_range.base && snip_end < local_range.base + local_range.length {
-			// Create new range for portion after snip
-			mut postsplit_range := &MmapRangeLocal{
-				pagemap: local_range.pagemap
-				base:    snip_end
-				length:  (local_range.base + local_range.length) - snip_end
-				offset:  local_range.offset + i64(snip_end - local_range.base)
-				prot:    local_range.prot
-				flags:   local_range.flags
-				global:  local_range.global
-			}
-			global_range.locals << postsplit_range
-			pagemap.mmap_ranges << postsplit_range
-			local_range.length -= postsplit_range.length
-		}
-
-		for j := snip_begin; j < snip_end; j += page_size {
-			pagemap.unmap_page(j) or {}
-		}
-
-		if snip_size == local_range.length {
-			if global_range.locals.len == 1 {
-				if local_range.flags & map_anonymous != 0 {
-					for j := global_range.base; j < global_range.base + global_range.length; j += page_size {
-						phys := global_range.shadow_pagemap.virt2phys(j) or { continue }
-						global_range.shadow_pagemap.unmap_page(j) or {
-							errno.set(errno.einval)
-							return none
-						}
-						memory.pmm_free(voidptr(phys), 1)
-					}
-				} else {
-					// global_range.resource.munmap(i)
-				}
-				memory.pmm_free(global_range.shadow_pagemap.top_level, 1)
-				unsafe {
-					global_range.locals.free()
-					free(global_range)
-				}
-			} else {
-				global_range.locals.delete(global_range.locals.index(local_range))
-			}
-			pagemap.mmap_ranges.delete(pagemap.mmap_ranges.index(local_range))
-			unsafe { free(local_range) }
-		} else {
-			if snip_begin == local_range.base {
-				local_range.offset += i64(snip_size)
-				local_range.base = snip_end
-			}
-			local_range.length -= snip_size
-		}
-	}
-}
diff --git a/kernel/modules/memory/physical.v b/kernel/modules/memory/physical.v
deleted file mode 100644
index ec929e8..0000000
--- a/kernel/modules/memory/physical.v
+++ /dev/null
@@ -1,383 +0,0 @@
-@[has_globals; manualfree]
-module memory
-
-import lib
-import klock
-import limine
-
-__global (
-	pmm_lock            klock.Lock
-	pmm_bitmap          = unsafe { nil }
-	pmm_avl_page_count  = u64(0)
-	pmm_last_used_index = u64(0)
-	free_pages          = u64(0)
-	higher_half         = u64(0)
-)
-
-@[_linker_section: '.requests']
-@[cinit]
-__global (
-	volatile hhdm_req = limine.LimineHHDMRequest{
-		response: unsafe { nil }
-	}
-)
-
-pub fn print_free() {
-	pmm_lock.acquire()
-	defer {
-		pmm_lock.release()
-	}
-	C.printf(c'pmm: Free pages: %llu\n', free_pages)
-}
-
-pub fn pmm_init() {
-	if hhdm_req.response == unsafe { nil } {
-		lib.kpanic(unsafe { nil }, c'HHDM bootloader response missing')
-	}
-	higher_half = hhdm_req.response.offset
-
-	C.printf(c'pmm: Higher half direct map at: %p\n', higher_half)
-
-	if memmap_req.response == unsafe { nil } {
-		lib.kpanic(unsafe { nil }, c'Memory map bootloader response missing')
-	}
-	memmap := memmap_req.response
-
-	unsafe {
-		mut highest_address := u64(0)
-		mut entries := memmap.entries
-
-		// Calculate how big the memory map needs to be.
-		for i := 0; i < memmap.entry_count; i++ {
-			C.printf(c'pmm: Memory map entry %d: 0x%llx->0x%llx  0x%llx\n', i, entries[i].base,
-				entries[i].length, entries[i].@type)
-
-			if entries[i].@type != u32(limine.limine_memmap_usable)
-				&& entries[i].@type != u32(limine.limine_memmap_bootloader_reclaimable)
-				&& entries[i].@type != u32(limine.limine_memmap_kernel_and_modules) {
-				continue
-			}
-			top := entries[i].base + entries[i].length
-			if top > highest_address {
-				highest_address = top
-			}
-		}
-
-		// Calculate the needed size for the bitmap in bytes and align it to page size.
-		pmm_avl_page_count = lib.div_roundup(highest_address, page_size)
-		bitmap_size := lib.align_up(pmm_avl_page_count / 8, page_size)
-
-		C.printf(c'pmm: Bitmap size: %llu\n', bitmap_size)
-
-		// Find a hole for the bitmap in the memory map.
-		for i := 0; i < memmap.entry_count; i++ {
-			if entries[i].@type != u32(limine.limine_memmap_usable) {
-				continue
-			}
-			if entries[i].length >= bitmap_size {
-				pmm_bitmap = voidptr(entries[i].base + higher_half)
-
-				// Initialise entire bitmap to 1 (non-free)
-				C.memset(pmm_bitmap, 0xff, bitmap_size)
-
-				entries[i].length -= bitmap_size
-				entries[i].base += bitmap_size
-
-				break
-			}
-		}
-
-		// Populate free bitmap entries according to the memory map.
-		for i := 0; i < memmap.entry_count; i++ {
-			if entries[i].@type != u32(limine.limine_memmap_usable) {
-				continue
-			}
-
-			for j := u64(0); j < entries[i].length; j += page_size {
-				free_pages++
-				lib.bitreset(pmm_bitmap, (entries[i].base + j) / page_size)
-			}
-		}
-	}
-	print_free()
-
-	// Initialise slabs
-	slabs[0].init(8)
-	slabs[1].init(16)
-	slabs[2].init(32)
-	slabs[3].init(64)
-	slabs[4].init(128)
-	slabs[5].init(256)
-	slabs[6].init(512)
-	slabs[7].init(1024)
-	slabs[8].init(2048)
-}
-
-fn inner_alloc(count u64, limit u64) voidptr {
-	mut p := 0
-
-	for pmm_last_used_index < limit {
-		if !lib.bittest(pmm_bitmap, pmm_last_used_index) {
-			pmm_last_used_index++
-			p++
-			if u64(p) == count {
-				page := pmm_last_used_index - count
-				for i := page; i < pmm_last_used_index; i++ {
-					lib.bitset(pmm_bitmap, i)
-				}
-				return voidptr(page * page_size)
-			}
-		} else {
-			pmm_last_used_index++
-			p = 0
-		}
-	}
-	return 0
-}
-
-pub fn pmm_alloc_nozero(count u64) voidptr {
-	pmm_lock.acquire()
-	defer {
-		pmm_lock.release()
-	}
-
-	last := pmm_last_used_index
-	mut ret := inner_alloc(count, pmm_avl_page_count)
-
-	if ret == 0 {
-		pmm_last_used_index = 0
-
-		ret = inner_alloc(count, last)
-		if ret == 0 {
-			lib.kpanic(unsafe { nil }, c'Out of memory')
-		}
-	}
-
-	free_pages -= count
-
-	return ret
-}
-
-pub fn pmm_alloc(count u64) voidptr {
-	ret := pmm_alloc_nozero(count)
-
-	// We always zero out memory for security reasons
-	unsafe {
-		mut ptr := &u64(u64(ret) + higher_half)
-		for i := u64(0); i < (count * page_size) / 8; i++ {
-			ptr[i] = 0
-		}
-	}
-	return ret
-}
-
-pub fn pmm_free(ptr voidptr, count u64) {
-	pmm_lock.acquire()
-	defer {
-		pmm_lock.release()
-	}
-	unsafe {
-		mut p := &u64(u64(ptr) + higher_half)
-		for i := u64(0); i < (count * page_size) / 8; i++ {
-			p[i] = 0xaaaaaaaaaaaaaaaa
-		}
-	}
-	page := u64(ptr) / page_size
-	for i := page; i < page + count; i++ {
-		lib.bitreset(pmm_bitmap, i)
-	}
-	free_pages += count
-}
-
-pub struct Slab {
-mut:
-	@lock      klock.Lock
-	first_free u64
-	ent_size   u64
-}
-
-struct SlabHeader {
-mut:
-	slab &Slab
-}
-
-pub fn (mut this Slab) init(ent_size u64) {
-	this.ent_size = ent_size
-	this.first_free = u64(pmm_alloc_nozero(1))
-	this.first_free += higher_half
-
-	avl_size := page_size - lib.align_up(sizeof(SlabHeader), ent_size)
-	mut slabptr := unsafe { &SlabHeader(this.first_free) }
-	unsafe {
-		(*slabptr).slab = this
-	}
-	this.first_free += lib.align_up(sizeof(SlabHeader), ent_size)
-
-	mut arr := unsafe { &u64(this.first_free) }
-	max := avl_size / ent_size - 1
-	fact := ent_size / 8
-	for i := u64(0); i < max; i++ {
-		unsafe {
-			arr[i * fact] = u64(&arr[(i + 1) * fact])
-		}
-	}
-
-	unsafe {
-		arr[max * fact] = u64(0)
-	}
-}
-
-pub fn (mut this Slab) alloc() voidptr {
-	this.@lock.acquire()
-	defer {
-		this.@lock.release()
-	}
-
-	if this.first_free == 0 {
-		this.init(this.ent_size)
-	}
-
-	mut old_free := unsafe { &u64(this.first_free) }
-	this.first_free = *old_free
-
-	unsafe { C.memset(voidptr(old_free), 0, this.ent_size) }
-
-	return voidptr(old_free)
-}
-
-pub fn (mut this Slab) sfree(ptr voidptr) {
-	this.@lock.acquire()
-	defer {
-		this.@lock.release()
-	}
-
-	if ptr == unsafe { nil } {
-		return
-	}
-
-	unsafe { C.memset(ptr, 0xaa, this.ent_size) }
-
-	mut new_head := &u64(ptr)
-	unsafe {
-		*new_head = this.first_free
-	}
-	this.first_free = u64(new_head)
-}
-
-__global (
-	slabs [9]Slab
-)
-
-struct MallocMetadata {
-mut:
-	pages u64
-	size  u64
-}
-
-@[export: 'free']
-pub fn free(ptr voidptr) {
-	if ptr == unsafe { nil } {
-		return
-	}
-
-	if u64(ptr) & u64(0xfff) == 0 {
-		big_free(ptr)
-		return
-	}
-
-	mut slab_hdr := unsafe { &SlabHeader(u64(ptr) & ~u64(0xfff)) }
-
-	slab_hdr.slab.sfree(ptr)
-}
-
-fn big_free(ptr voidptr) {
-	metadata := unsafe { &MallocMetadata(u64(ptr) - page_size) }
-
-	pmm_free(voidptr(u64(metadata) - higher_half), metadata.pages + 1)
-}
-
-fn slab_for(size u64) ?&Slab {
-	for mut s in slabs {
-		if s.ent_size >= size {
-			return unsafe { s }
-		}
-	}
-
-	return none
-}
-
-@[export: 'malloc']
-pub fn malloc(size u64) voidptr {
-	mut slab := slab_for(size) or { return big_alloc(size) }
-
-	return slab.alloc()
-}
-
-fn big_alloc(size u64) voidptr {
-	page_count := lib.div_roundup(size, page_size)
-
-	ptr := pmm_alloc(page_count + 1)
-
-	if ptr == 0 {
-		return 0
-	}
-
-	mut metadata := unsafe { &MallocMetadata(u64(ptr) + higher_half) }
-
-	metadata.pages = page_count
-	metadata.size = size
-
-	return voidptr(u64(ptr) + higher_half + page_size)
-}
-
-@[export: 'realloc']
-pub fn realloc(ptr voidptr, new_size u64) voidptr {
-	if ptr == 0 {
-		return malloc(new_size)
-	}
-
-	if u64(ptr) & u64(0xfff) == 0 {
-		return big_realloc(ptr, new_size)
-	}
-
-	slab_hdr := unsafe { &SlabHeader(u64(ptr) & ~u64(0xfff)) }
-	mut slab := slab_hdr.slab
-
-	if new_size > slab.ent_size {
-		mut new_ptr := malloc(new_size)
-		unsafe { C.memcpy(new_ptr, ptr, slab.ent_size) }
-		slab.sfree(ptr)
-		return new_ptr
-	}
-
-	return ptr
-}
-
-fn big_realloc(ptr voidptr, new_size u64) voidptr {
-	mut metadata := unsafe { &MallocMetadata(u64(ptr) - page_size) }
-
-	if lib.div_roundup(metadata.size, page_size) == lib.div_roundup(new_size, page_size) {
-		metadata.size = new_size
-		return ptr
-	}
-
-	new_ptr := unsafe { malloc(new_size) }
-	if new_ptr == 0 {
-		return 0
-	}
-
-	if metadata.size > new_size {
-		unsafe { C.memcpy(new_ptr, ptr, new_size) }
-	} else {
-		unsafe { C.memcpy(new_ptr, ptr, metadata.size) }
-	}
-
-	free(ptr)
-
-	return new_ptr
-}
-
-@[export: 'calloc']
-pub fn calloc(a u64, b u64) voidptr {
-	return unsafe { malloc(a * b) }
-}
diff --git a/kernel/modules/memory/virtual.v b/kernel/modules/memory/virtual.v
deleted file mode 100644
index 503a9c5..0000000
--- a/kernel/modules/memory/virtual.v
+++ /dev/null
@@ -1,347 +0,0 @@
-@[has_globals]
-module memory
-
-import lib
-import limine
-import klock
-import x86.cpu
-
-fn C.text_start()
-fn C.text_end()
-fn C.rodata_start()
-fn C.rodata_end()
-fn C.data_start()
-fn C.data_end()
-
-pub const pte_present = u64(1) << 0
-pub const pte_writable = u64(1) << 1
-pub const pte_user = u64(1) << 2
-pub const pte_noexec = u64(1) << 63
-pub const pte_flags_mask = ~(u64(0xfff) | pte_present | pte_writable | pte_user | pte_noexec)
-
-__global (
-	page_size       = u64(0x1000)
-	la57            = bool(false)
-	kernel_pagemap  Pagemap
-	vmm_initialised = bool(false)
-)
-
-pub struct Pagemap {
-pub mut:
-	l           klock.Lock
-	top_level   &u64 = unsafe { nil }
-	mmap_ranges []voidptr
-}
-
-fn C.get_kernel_end_addr() u64
-
-pub fn new_pagemap() &Pagemap {
-	mut top_level := &u64(pmm_alloc(1))
-	if top_level == 0 {
-		panic('new_pagemap() allocation failure')
-	}
-
-	// Import higher half from kernel pagemap
-	mut p1 := unsafe { &u64(u64(top_level) + higher_half) }
-	p2 := unsafe { &u64(u64(kernel_pagemap.top_level) + higher_half) }
-	for i := u64(256); i < 512; i++ {
-		unsafe {
-			p1[i] = p2[i]
-		}
-	}
-	return &Pagemap{
-		top_level:   top_level
-		mmap_ranges: []voidptr{}
-	}
-}
-
-pub fn (pagemap &Pagemap) virt2pte(virt u64, allocate bool) ?&u64 {
-	pml5_entry := (virt & (u64(0x1ff) << 48)) >> 48
-	pml4_entry := (virt & (u64(0x1ff) << 39)) >> 39
-	pml3_entry := (virt & (u64(0x1ff) << 30)) >> 30
-	pml2_entry := (virt & (u64(0x1ff) << 21)) >> 21
-	pml1_entry := (virt & (u64(0x1ff) << 12)) >> 12
-
-	pml5 := pagemap.top_level
-	pml4 := if !la57 {
-		pagemap.top_level
-	} else {
-		get_next_level(pml5, pml5_entry, allocate) or { return none }
-	}
-	pml3 := get_next_level(pml4, pml4_entry, allocate) or { return none }
-	pml2 := get_next_level(pml3, pml3_entry, allocate) or { return none }
-	pml1 := get_next_level(pml2, pml2_entry, allocate) or { return none }
-
-	return unsafe { &u64(u64(&pml1[pml1_entry]) + higher_half) }
-}
-
-pub fn (pagemap &Pagemap) virt2phys(virt u64) ?u64 {
-	pte_p := pagemap.virt2pte(virt, false) or { return none }
-	if unsafe { *pte_p } & 1 == 0 {
-		return none
-	}
-	return unsafe { *pte_p } & pte_flags_mask
-}
-
-pub fn (mut pagemap Pagemap) switch_to() {
-	top_level := pagemap.top_level
-
-	asm volatile amd64 {
-		mov cr3, top_level
-		; ; r (top_level)
-		; memory
-	}
-}
-
-fn get_next_level(current_level &u64, index u64, allocate bool) ?&u64 {
-	mut ret := unsafe { &u64(0) }
-
-	mut entry := unsafe { &u64(u64(current_level) + higher_half + index * 8) }
-
-	// Check if entry is present
-	if unsafe { *entry } & 0x01 != 0 {
-		// If present, return pointer to it
-		ret = unsafe { &u64(*entry & pte_flags_mask) }
-	} else {
-		if allocate == false {
-			return none
-		}
-
-		// Else, allocate the page table
-		ret = pmm_alloc(1)
-		if ret == 0 {
-			return none
-		}
-		unsafe {
-			*entry = u64(ret) | 0b111
-		}
-	}
-	return ret
-}
-
-pub fn (mut pagemap Pagemap) unmap_page(virt u64) ? {
-	pml5_entry := (virt & (u64(0x1ff) << 48)) >> 48
-	pml4_entry := (virt & (u64(0x1ff) << 39)) >> 39
-	pml3_entry := (virt & (u64(0x1ff) << 30)) >> 30
-	pml2_entry := (virt & (u64(0x1ff) << 21)) >> 21
-	pml1_entry := (virt & (u64(0x1ff) << 12)) >> 12
-
-	mut pml5 := pagemap.top_level
-	mut pml5_p := unsafe { &u64(u64(pml5) + higher_half) }
-	mut pml4 := if !la57 {
-		pagemap.top_level
-	} else {
-		get_next_level(pml5, pml5_entry, false) or { return none }
-	}
-	mut pml4_p := unsafe { &u64(u64(pml4) + higher_half) }
-	mut pml3 := get_next_level(pml4, pml4_entry, false) or { return none }
-	mut pml3_p := unsafe { &u64(u64(pml3) + higher_half) }
-	mut pml2 := get_next_level(pml3, pml3_entry, false) or { return none }
-	mut pml2_p := unsafe { &u64(u64(pml2) + higher_half) }
-	mut pml1 := get_next_level(pml2, pml2_entry, false) or { return none }
-	mut pml1_p := unsafe { &u64(u64(pml1) + higher_half) }
-
-	mut pte_p := unsafe { &u64(u64(&pml1[pml1_entry]) + higher_half) }
-
-	unsafe {
-		*pte_p = 0
-
-		mut i := u64(0)
-		for ; i < 512; i++ {
-			if pml1_p[i] != 0 {
-				break
-			}
-		}
-		if i == 512 {
-			pmm_free(pml1, 1)
-			pml2_p[pml2_entry] = 0
-		}
-
-		i = u64(0)
-		for ; i < 512; i++ {
-			if pml2_p[i] != 0 {
-				break
-			}
-		}
-		if i == 512 {
-			pmm_free(pml2, 1)
-			pml3_p[pml3_entry] = 0
-		}
-
-		i = u64(0)
-		for ; i < 512; i++ {
-			if pml3_p[i] != 0 {
-				break
-			}
-		}
-		if i == 512 {
-			pmm_free(pml3, 1)
-			pml4_p[pml4_entry] = 0
-		}
-		if la57 {
-			for ; i < 512; i++ {
-				if pml4_p[i] != 0 {
-					break
-				}
-			}
-			if i == 512 {
-				pmm_free(pml4, 1)
-				pml5_p[pml5_entry] = 0
-			}
-		}
-	}
-	current_cr3 := cpu.read_cr3()
-	if current_cr3 == u64(pagemap.top_level) {
-		cpu.invlpg(virt)
-	}
-}
-
-pub fn (mut pagemap Pagemap) flag_page(virt u64, flags u64) ? {
-	pte_p := pagemap.virt2pte(virt, false) or { return none }
-
-	unsafe {
-		*pte_p &= pte_flags_mask
-	}
-	unsafe {
-		*pte_p |= flags
-	}
-	current_cr3 := cpu.read_cr3()
-	if current_cr3 == u64(pagemap.top_level) {
-		cpu.invlpg(virt)
-	}
-}
-
-pub fn (mut pagemap Pagemap) map_page(virt u64, phys u64, flags u64) ? {
-	pagemap.l.acquire()
-	defer {
-		pagemap.l.release()
-	}
-
-	pml5_entry := (virt & (u64(0x1ff) << 48)) >> 48
-	pml4_entry := (virt & (u64(0x1ff) << 39)) >> 39
-	pml3_entry := (virt & (u64(0x1ff) << 30)) >> 30
-	pml2_entry := (virt & (u64(0x1ff) << 21)) >> 21
-	pml1_entry := (virt & (u64(0x1ff) << 12)) >> 12
-
-	pml5 := pagemap.top_level
-	pml4 := if !la57 {
-		pagemap.top_level
-	} else {
-		get_next_level(pml5, pml5_entry, true) or { return none }
-	}
-	pml3 := get_next_level(pml4, pml4_entry, true) or { return none }
-	pml2 := get_next_level(pml3, pml3_entry, true) or { return none }
-	mut pml1 := get_next_level(pml2, pml2_entry, true) or { return none }
-
-	entry := unsafe { &u64(u64(pml1) + higher_half + pml1_entry * 8) }
-
-	unsafe {
-		*entry = phys | flags
-	}
-}
-
-@[_linker_section: '.requests']
-@[cinit]
-__global (
-	volatile kaddr_req       = limine.LimineKernelAddressRequest{
-		response: unsafe { nil }
-	}
-	volatile memmap_req      = limine.LimineMemmapRequest{
-		response: unsafe { nil }
-	}
-	volatile paging_mode_req = limine.LiminePagingModeRequest{
-		response: unsafe { nil }
-		revision: 1
-		mode:     limine.limine_paging_mode_x86_64_5lvl
-		max_mode: limine.limine_paging_mode_x86_64_5lvl
-		min_mode: limine.limine_paging_mode_x86_64_4lvl
-	}
-)
-
-fn map_kernel_span(virt u64, phys u64, len u64, flags u64) {
-	aligned_len := lib.align_up(len, page_size)
-
-	print('vmm: Kernel: Mapping 0x${phys:x} to 0x${virt:x}, length: 0x${aligned_len:x}\n')
-
-	for i := u64(0); i < aligned_len; i += page_size {
-		kernel_pagemap.map_page(virt + i, phys + i, flags) or { panic('vmm init failure') }
-	}
-}
-
-pub fn vmm_init() {
-	if paging_mode_req.response != unsafe { nil } {
-		if paging_mode_req.response.mode == limine.limine_paging_mode_x86_64_5lvl {
-			print('vmm: Using 5 level paging\n')
-			la57 = true
-		}
-	}
-
-	kernel_pagemap.top_level = pmm_alloc(1)
-	if kernel_pagemap.top_level == 0 {
-		panic('vmm_init() allocation failure')
-	}
-
-	// Since the higher half has to be shared amongst all address spaces,
-	// we need to initialise every single higher half PML3 so they can be
-	// shared.
-	for i := u64(256); i < 512; i++ {
-		// get_next_level will allocate the PML3s for us.
-		get_next_level(kernel_pagemap.top_level, i, true) or { panic('vmm init failure') }
-	}
-
-	// Map kernel
-	if kaddr_req.response == unsafe { nil } {
-		panic('Kernel address bootloader response missing')
-	}
-	print('vmm: Kernel physical base: 0x${kaddr_req.response.physical_base:x}\n')
-	print('vmm: Kernel virtual base: 0x${kaddr_req.response.virtual_base:x}\n')
-	virtual_base := kaddr_req.response.virtual_base
-	physical_base := kaddr_req.response.physical_base
-
-	// Map kernel text
-	text_virt := u64(voidptr(C.text_start))
-	text_phys := (text_virt - virtual_base) + physical_base
-	text_len := u64(voidptr(C.text_end)) - text_virt
-	map_kernel_span(text_virt, text_phys, text_len, pte_present)
-
-	// Map kernel rodata
-	rodata_virt := u64(voidptr(C.rodata_start))
-	rodata_phys := (rodata_virt - virtual_base) + physical_base
-	rodata_len := u64(voidptr(C.rodata_end)) - rodata_virt
-	map_kernel_span(rodata_virt, rodata_phys, rodata_len, pte_present | pte_noexec)
-
-	// Map kernel data
-	data_virt := u64(voidptr(C.data_start))
-	data_phys := (data_virt - virtual_base) + physical_base
-	data_len := u64(voidptr(C.data_end)) - data_virt
-	map_kernel_span(data_virt, data_phys, data_len, pte_present | pte_noexec | pte_writable)
-
-	for i := u64(0); i < 0x100000000; i += page_size {
-		kernel_pagemap.map_page(i + higher_half, i, pte_present | pte_noexec | pte_writable) or {
-			panic('vmm init failure')
-		}
-	}
-
-	memmap := memmap_req.response
-
-	entries := memmap.entries
-	for i := 0; i < memmap.entry_count; i++ {
-		base := unsafe { lib.align_down(entries[i].base, page_size) }
-		top := unsafe { lib.align_up(entries[i].base + entries[i].length, page_size) }
-		if top <= u64(0x100000000) {
-			continue
-		}
-		for j := base; j < top; j += page_size {
-			if j < u64(0x100000000) {
-				continue
-			}
-			kernel_pagemap.map_page(j + higher_half, j, pte_present | pte_noexec | pte_writable) or {
-				panic('vmm init failure')
-			}
-		}
-	}
-
-	kernel_pagemap.switch_to()
-
-	vmm_initialised = true
-}
diff --git a/kernel/modules/net/hostname.v b/kernel/modules/net/hostname.v
deleted file mode 100644
index a7b8b2e..0000000
--- a/kernel/modules/net/hostname.v
+++ /dev/null
@@ -1,32 +0,0 @@
-@[has_globals]
-module net
-
-import errno
-
-const hostname_len = 64
-
-__global (
-	hostname [hostname_len]char
-)
-
-pub fn syscall_gethostname(_ voidptr, name charptr, len u64) (u64, u64) {
-	real_len := unsafe { C.strlen(&hostname[0]) }
-
-	if len < real_len {
-		return errno.err, errno.enametoolong
-	}
-
-	unsafe { C.memcpy(name, &hostname[0], real_len + 1) }
-	return 0, 0
-}
-
-pub fn syscall_sethostname(_ voidptr, name charptr, len u64) (u64, u64) {
-	if len > hostname_len - 1 {
-		return errno.err, errno.einval
-	}
-
-	unsafe { C.memcpy(&hostname[0], name, len) }
-	hostname[len] = char(`\0`)
-
-	return 0, 0
-}
diff --git a/kernel/modules/pci/device.v b/kernel/modules/pci/device.v
deleted file mode 100644
index 8ae6022..0000000
--- a/kernel/modules/pci/device.v
+++ /dev/null
@@ -1,172 +0,0 @@
-module pci
-
-import x86.kio
-import bitmap
-
-pub struct PCIDevice {
-pub:
-	bus      u8
-	slot     u8
-	function u8
-	parent   i64
-pub mut:
-	device_id         u16
-	vendor_id         u16
-	revision_id       u16
-	class             u8
-	subclass          u8
-	prog_if           u8
-	multifunction     bool
-	irq_pin           u8
-	msi_offset        u16
-	msix_offset       u16
-	msi_support       bool
-	msix_support      bool
-	msix_table_bitmap bitmap.GenericBitmap
-	msix_table_size   u16
-}
-
-pub struct PCIBar {
-pub:
-	base            u64
-	size            u64
-	is_mmio         bool
-	is_prefetchable bool
-}
-
-pub fn (mut dev PCIDevice) read_info() {
-	config0 := dev.read[int](0)
-	config8 := dev.read[int](0x8)
-	configc := dev.read[int](0xc)
-	config3c := dev.read[int](0x3c)
-
-	dev.device_id = u16(config0 >> 16)
-	dev.vendor_id = u16(config0)
-	dev.revision_id = u8(config8)
-	dev.subclass = u8(config8 >> 16)
-	dev.class = u8(config8 >> 24)
-	dev.prog_if = u8(config8 >> 8)
-	dev.multifunction = if configc & 0x800000 != 0 { true } else { false }
-	dev.irq_pin = u8(config3c >> 8)
-}
-
-pub fn (dev &PCIDevice) read[T](offset u32) T {
-	dev.get_address(offset)
-	return kio.port_in[T](u16(0xcfc + (offset & 3)))
-}
-
-pub fn (dev &PCIDevice) write[T](offset u32, value T) {
-	dev.get_address(offset)
-	kio.port_out[T](u16(0xcfc + (offset & 3)), value)
-}
-
-pub fn (dev &PCIDevice) is_bar_present(bar u8) bool {
-	assert bar <= 5
-	reg_index := 0x10 + bar * 4
-	return if dev.read[u32](reg_index) != 0 { true } else { false }
-}
-
-pub fn (dev &PCIDevice) get_bar(bar u8) PCIBar {
-	assert bar <= 5
-
-	reg_index := 0x10 + bar * 4
-	bar_low := dev.read[u32](reg_index)
-	mut bar_size_low := dev.read[u32](reg_index)
-
-	is_mmio := if bar_low & 1 == 0 { true } else { false }
-	is_prefetchable := is_mmio && bar_low & (1 << 3) != 0
-	is_64_bits := is_mmio && ((bar_low >> 1) & 0b11) == 0b10
-	bar_high := if is_64_bits { dev.read[u32](reg_index + 4) } else { 0 }
-
-	base := ((u64(bar_high) << 32) | bar_low) & ~u32(if is_mmio { 0b1111 } else { 0b11 })
-
-	dev.write[u32](reg_index, 0xFFFFFFFF)
-	bar_size_low = dev.read[u32](reg_index)
-	dev.write[u32](reg_index, bar_low)
-
-	bar_size_high := if is_64_bits {
-		dev.write[u32](reg_index + 4, 0xFFFFFFFF)
-		ret := dev.read[u32](reg_index + 4)
-		dev.write[u32](reg_index + 4, bar_high)
-		ret
-	} else {
-		0xFFFFFFFF
-	}
-
-	mut size := ((u64(bar_size_high) << 32) | bar_size_low) & ~u64(if is_mmio {
-		0b1111
-	} else {
-		0b11
-	})
-	size = ~size + 1
-
-	return PCIBar{base, size, is_mmio, is_prefetchable}
-}
-
-pub fn (dev &PCIDevice) set_msi(vector u8) {
-	mut message_control := dev.read[u16](dev.msi_offset + 2)
-
-	mut reg0 := 0x4
-	mut reg1 := 0x8
-
-	if ((message_control >> 7) & 1) == 1 { // 64 bit support
-		reg1 = 0xc
-	}
-
-	address := (0xfee << 20) | (bsp_lapic_id << 12)
-	data := vector
-
-	dev.write[u32](u32(dev.msi_offset + reg0), address)
-	dev.write[u32](u32(dev.msi_offset + reg1), data)
-
-	message_control |= 1 // enable=1
-	message_control &= ~(0b111 << 4) // mme=0
-	dev.write[u16](dev.msi_offset + 2, message_control)
-}
-
-pub fn (dev &PCIDevice) set_msix(vector u8) bool {
-	msix_vector := dev.msix_table_bitmap.alloc() or {
-		print('pci: [${dev.bus:x}:${dev.slot:x}:${dev.function:x}:${dev.parent:x}] msix no free vectors\n')
-		return false
-	}
-
-	table_ptr := dev.read[u32](dev.msix_offset + 4)
-	dev.read[u32](dev.msix_offset + 8)
-
-	bar_index := table_ptr & 0b111
-	bar_offset := (table_ptr >> 3) << 3
-
-	if dev.is_bar_present(u8(bar_index)) == false {
-		print('pci: [${dev.bus:x}:${dev.slot:x}:${dev.function:x}:${dev.parent:x}] msix table bar not present\n')
-		return false
-	}
-
-	table_bar := dev.get_bar(u8(bar_index))
-	bar_base := table_bar.base + bar_offset + u64(msix_vector * 16)
-
-	address := (0xfee << 20) | (bsp_lapic_id << 12)
-	data := vector
-
-	kio.mmout(unsafe { &u32(bar_base) }, address) // address low
-	kio.mmout(unsafe { &u32(bar_base + 4) }, u32(0)) // address high
-	kio.mmout(unsafe { &u32(bar_base + 8) }, data) // data
-	kio.mmout(unsafe { &u32(bar_base + 12) }, u32(0)) // vector control
-	mut message_control := dev.read[u16](dev.msix_offset + 2)
-
-	message_control |= (1 << 15) // enable=1
-	message_control &= ~(1 << 14) // mask=0
-	dev.write[u16](dev.msix_offset + 2, message_control)
-
-	return true
-}
-
-pub fn (dev &PCIDevice) enable_bus_mastering() {
-	if (dev.read[u32](0x4) & (1 << 2)) == 0 {
-		dev.write[u32](0x4, dev.read[u32](0x4) | (1 << 2))
-	}
-}
-
-fn (dev &PCIDevice) get_address(offset u32) {
-	address := (u32(dev.bus) << 16) | (u32(dev.slot) << 11) | (u32(dev.function) << 8) | (offset & ~(u32(3))) | 0x80000000
-	kio.port_out[u32](0xcf8, address)
-}
diff --git a/kernel/modules/pci/scan.v b/kernel/modules/pci/scan.v
deleted file mode 100644
index 3af0dee..0000000
--- a/kernel/modules/pci/scan.v
+++ /dev/null
@@ -1,139 +0,0 @@
-@[has_globals]
-module pci
-
-__global (
-	scanned_devices []&PCIDevice
-)
-
-const max_function = 8
-
-const max_device = 32
-
-const max_bus = 256
-
-pub fn initialise() {
-	print('pci: Building device scan\n')
-	mut root_bus := PCIDevice{}
-	configc := root_bus.read[u32](0xc)
-
-	if (configc & 0x800000) == 0 {
-		check_bus(0, -1)
-	} else {
-		for function := u8(0); function < max_function; function++ {
-			host_bridge := PCIDevice{
-				bus:      0
-				slot:     0
-				function: function
-				parent:   0
-			}
-			config0 := host_bridge.read[u32](0)
-			if config0 == 0xffffffff {
-				continue
-			}
-
-			check_bus(function, -1)
-		}
-	}
-}
-
-fn check_bus(bus u8, parent i64) {
-	for dev := u8(0); dev < max_device; dev++ {
-		for func := u8(0); func < max_function; func++ {
-			check_function(bus, dev, func, parent)
-		}
-	}
-}
-
-fn check_function(bus u8, slot u8, function u8, parent i64) {
-	mut device := &PCIDevice{
-		bus:      bus
-		slot:     slot
-		function: function
-		parent:   parent
-	}
-	device.read_info()
-	if device.device_id == 0xffff && device.vendor_id == 0xffff {
-		return
-	}
-
-	// Handle PCI to PCI bridges, and we are done.
-	if device.class == 0x6 && device.subclass == 0x4 {
-		config := device.read[u32](0x18)
-		check_bus(u8(config >> 8), 1)
-	} else {
-		scanned_devices << device
-
-		status := device.read[u16](0x6)
-
-		if (status & (1 << 4)) != 0 { // parse capabilities list
-			mut off := device.read[u8](0x34)
-
-			for off > 0 {
-				id := device.read[u8](off)
-
-				match id {
-					0x5 {
-						device.msi_support = true
-						device.msi_offset = off
-					}
-					0x11 {
-						device.msix_support = true
-						device.msix_offset = off
-
-						message_control := device.read[u16](off + 2)
-
-						device.msix_table_size = message_control & 0x7FF
-						device.msix_table_bitmap.initialise(device.msix_table_size)
-					}
-					else {}
-				}
-
-				off = device.read[u8](off + 1)
-			}
-		}
-
-		print('pci: Found [${device.bus:x}:${device.slot:x}:${device.function:x}:${device.parent:x}]\n')
-	}
-}
-
-pub fn get_device_by_vendor(vendor_id u16, device_id u16, index u32) ?&PCIDevice {
-	mut count := 0
-	for device in scanned_devices {
-		if device.vendor_id == vendor_id && device.device_id == device_id {
-			if count == index {
-				return unsafe { device }
-			} else {
-				count += 1
-			}
-		}
-	}
-	return none
-}
-
-pub fn get_device_by_coordinates(bus u8, slot u8, function u8, index u32) ?&PCIDevice {
-	mut count := 0
-	for device in scanned_devices {
-		if device.bus == bus && device.slot == slot && device.function == function {
-			if count == index {
-				return unsafe { device }
-			} else {
-				count += 1
-			}
-		}
-	}
-	return none
-}
-
-pub fn get_device_by_class(class u8, subclass u8, progif u8, index u32) ?&PCIDevice {
-	mut count := 0
-	for device in scanned_devices {
-		if device.class == class && device.subclass == subclass && device.prog_if == progif {
-			if count == index {
-				return unsafe { device }
-			} else {
-				count += 1
-			}
-		}
-	}
-	return none
-}
diff --git a/kernel/modules/pipe/pipe.v b/kernel/modules/pipe/pipe.v
deleted file mode 100644
index b556060..0000000
--- a/kernel/modules/pipe/pipe.v
+++ /dev/null
@@ -1,224 +0,0 @@
-module pipe
-
-import resource
-import stat
-import klock
-import event
-import event.eventstruct
-import errno
-import file
-import katomic
-import proc
-
-// A pipe is a circular buffer
-pub const pipe_buf = 4096
-
-pub struct Pipe {
-pub mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	status   int
-	can_mmap bool
-
-	data      &u8
-	read_ptr  u64
-	write_ptr u64
-	capacity  u64
-	used      u64
-	event     eventstruct.Event
-}
-
-pub fn initialise() {}
-
-pub fn create() ?&Pipe {
-	mut p := &Pipe{
-		data:     unsafe { malloc(pipe_buf) }
-		capacity: pipe_buf
-	}
-	p.stat.mode = stat.ifpipe
-
-	return p
-}
-
-pub fn syscall_pipe(_ voidptr, pipefds &int, flags int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: pipe(0x%llx, 0x%x)\n', process.name.str, voidptr(pipefds),
-		flags)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut new_pipe := create() or { return errno.err, errno.get() }
-
-	rd_fd := file.fdnum_create_from_resource(unsafe { nil }, mut new_pipe, flags, 0, false) or {
-		return errno.err, errno.get()
-	}
-
-	wr_fd := file.fdnum_create_from_resource(unsafe { nil }, mut new_pipe, flags, 0, false) or {
-		return errno.err, errno.get()
-	}
-
-	unsafe {
-		pipefds[0] = rd_fd
-		pipefds[1] = wr_fd
-	}
-	return 0, 0
-}
-
-fn (mut this Pipe) mmap(page u64, flags int) voidptr {
-	return 0
-}
-
-fn (mut this Pipe) read(_handle voidptr, buf voidptr, loc u64, _count u64) ?i64 {
-	mut count := _count
-
-	this.l.acquire()
-	defer {
-		this.l.release()
-	}
-
-	handle := unsafe { &file.Handle(_handle) }
-
-	// If pipe is empty, block or return if nonblock
-	for katomic.load(&this.used) == 0 {
-		// Return EOF if the pipe was closed
-		if this.refcount <= 1 {
-			return 0
-		}
-		if handle.flags & resource.o_nonblock != 0 {
-			return 0
-		}
-		this.l.release()
-		mut events := [&this.event]
-		event.await(mut events, true) or {
-			unsafe { events.free() }
-			errno.set(errno.eintr)
-			return none
-		}
-		unsafe { events.free() }
-		this.l.acquire()
-	}
-
-	if this.used < count {
-		count = this.used
-	}
-
-	// Calculate sizes before and after wrap-around and new ptr location
-	mut before_wrap := u64(0)
-	mut after_wrap := u64(0)
-	mut new_ptr_loc := u64(0)
-	if this.read_ptr + count > this.capacity {
-		before_wrap = this.capacity - this.read_ptr
-		after_wrap = count - before_wrap
-		new_ptr_loc = after_wrap
-	} else {
-		before_wrap = count
-		after_wrap = 0
-		new_ptr_loc = this.read_ptr + count
-		if new_ptr_loc == this.capacity {
-			new_ptr_loc = 0
-		}
-	}
-
-	unsafe { C.memcpy(buf, &this.data[this.read_ptr], before_wrap) }
-	if after_wrap != 0 {
-		unsafe { C.memcpy(voidptr(u64(buf) + before_wrap), this.data, after_wrap) }
-	}
-
-	this.read_ptr = new_ptr_loc
-	this.used -= count
-
-	if this.used == 0 {
-		this.status &= ~file.pollin
-	}
-	if this.used < this.capacity {
-		this.status |= file.pollout
-	}
-	event.trigger(mut this.event, false)
-
-	return i64(count)
-}
-
-fn (mut this Pipe) write(handle voidptr, buf voidptr, loc u64, _count u64) ?i64 {
-	mut count := _count
-
-	this.l.acquire()
-	defer {
-		this.l.release()
-	}
-
-	// If pipe is full, block or return if nonblock
-	for katomic.load(&this.used) == this.capacity {
-		// We don't do nonblock yet
-		this.l.release()
-		mut events := [&this.event]
-		event.await(mut events, true) or {
-			unsafe { events.free() }
-			errno.set(errno.eintr)
-			return none
-		}
-		unsafe { events.free() }
-		this.l.acquire()
-	}
-
-	if this.used + count > this.capacity {
-		count = this.capacity - this.used
-	}
-
-	// Calculate sizes before and after wrap-around and new ptr location
-	mut before_wrap := u64(0)
-	mut after_wrap := u64(0)
-	mut new_ptr_loc := u64(0)
-	if this.write_ptr + count > this.capacity {
-		before_wrap = this.capacity - this.write_ptr
-		after_wrap = count - before_wrap
-		new_ptr_loc = after_wrap
-	} else {
-		before_wrap = count
-		after_wrap = 0
-		new_ptr_loc = this.write_ptr + count
-		if new_ptr_loc == this.capacity {
-			new_ptr_loc = 0
-		}
-	}
-
-	unsafe { C.memcpy(&this.data[this.write_ptr], buf, before_wrap) }
-	if after_wrap != 0 {
-		unsafe { C.memcpy(this.data, voidptr(u64(buf) + before_wrap), after_wrap) }
-	}
-
-	this.write_ptr = new_ptr_loc
-	this.used += count
-
-	if this.used == this.capacity {
-		this.status &= ~file.pollout
-	}
-	this.status |= file.pollin
-	event.trigger(mut this.event, false)
-
-	return i64(count)
-}
-
-fn (mut this Pipe) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	return resource.default_ioctl(handle, request, argp)
-}
-
-fn (mut this Pipe) unref(handle voidptr) ? {
-	katomic.dec(mut &this.refcount)
-	event.trigger(mut this.event, false)
-}
-
-fn (mut this Pipe) unlink(handle voidptr) ? {
-	katomic.dec(mut &this.stat.nlink)
-}
-
-fn (mut this Pipe) link(handle voidptr) ? {
-	katomic.inc(mut &this.stat.nlink)
-}
-
-fn (mut this Pipe) grow(handle voidptr, new_size u64) ? {
-	return none
-}
diff --git a/kernel/modules/proc/proc.v b/kernel/modules/proc/proc.v
deleted file mode 100644
index c8dd5a2..0000000
--- a/kernel/modules/proc/proc.v
+++ /dev/null
@@ -1,101 +0,0 @@
-@[has_globals]
-module proc
-
-import klock
-import x86.cpu.local as cpulocal
-import memory
-import katomic
-import event.eventstruct
-
-pub const max_fds = 256
-
-pub const max_events = 32
-
-pub struct Process {
-pub mut:
-	pid                      int
-	ppid                     int
-	pagemap                  &memory.Pagemap = unsafe { nil }
-	thread_stack_top         u64
-	threads                  []&Thread
-	fds_lock                 klock.Lock
-	fds                      [max_fds]voidptr
-	children                 []&Process
-	mmap_anon_non_fixed_base u64
-	current_directory        voidptr
-	event                    eventstruct.Event
-	status                   int
-	name                     string
-}
-
-pub struct SigAction {
-pub mut:
-	sa_sigaction voidptr
-	sa_mask      u64
-	sa_flags     int
-}
-
-pub struct Thread {
-pub mut:
-	// Fixed members, DO NOT MOVE
-	running_on   u64
-	self         voidptr
-	errno        u64
-	kernel_stack u64
-	user_stack   u64
-	syscall_num  u64
-	// Movable members
-	tid                int
-	is_in_queue        bool
-	l                  klock.Lock
-	process            &Process = unsafe { nil }
-	gpr_state          cpulocal.GPRState
-	gs_base            u64
-	fs_base            u64
-	pf_stack           u64
-	cr3                u64
-	fpu_storage        voidptr
-	yield_await        klock.Lock
-	timeslice          u64
-	which_event        u64
-	exit_value         voidptr
-	exited             eventstruct.Event
-	sigentry           u64
-	sigactions         [256]SigAction
-	pending_signals    u64
-	masked_signals     u64
-	enqueued_by_signal bool
-	stacks             []voidptr
-	signalfds_lock     klock.Lock
-	signalfds          []voidptr
-	attached_events    [max_events]&eventstruct.Event
-	attached_events_i  u64
-}
-
-pub fn current_thread() &Thread {
-	mut ret := &Thread(unsafe { nil })
-
-	asm volatile amd64 {
-		mov ret, gs:[8] // get self
-		; =r (ret)
-	}
-
-	return ret
-}
-
-__global (
-	processes [65536]&Process
-)
-
-pub fn allocate_pid(process &Process) ?int {
-	for i := int(1); i < 65536; i++ {
-		if katomic.cas[&Process](mut &processes[i], unsafe { nil }, process) {
-			return i
-		}
-	}
-	return none
-}
-
-pub fn free_pid(pid int) {
-	katomic.store[&Process](mut &processes[pid], unsafe { nil })
-}
diff --git a/kernel/modules/resource/resource.v b/kernel/modules/resource/resource.v
deleted file mode 100644
index 093daa4..0000000
--- a/kernel/modules/resource/resource.v
+++ /dev/null
@@ -1,72 +0,0 @@
-@[has_globals]
-module resource
-
-import stat
-import klock
-import ioctl
-import errno
-import event.eventstruct
-
-pub const o_path = 0o10000000
-
-pub const o_accmode = (0o03 | o_path)
-pub const o_exec = o_path
-pub const o_rdonly = 0o00
-pub const o_rdwr = 0o02
-pub const o_search = o_path
-pub const o_wronly = 0o01
-pub const o_append = 0o2000
-pub const o_creat = 0o100
-pub const o_directory = 0o200000
-pub const o_excl = 0o200
-pub const o_noctty = 0o400
-pub const o_nofollow = 0o400000
-pub const o_trunc = 0o1000
-pub const o_nonblock = 0o4000
-pub const o_dsync = 0o10000
-pub const o_rsync = 0o4010000
-pub const o_sync = 0o4010000
-pub const o_cloexec = 0o2000000
-
-pub const file_creation_flags_mask = o_creat | o_directory | o_excl | o_noctty | o_nofollow | o_trunc
-pub const file_descriptor_flags_mask = o_cloexec
-pub const file_status_flags_mask = ~(file_creation_flags_mask | file_descriptor_flags_mask)
-
-pub interface Resource {
-mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	event    eventstruct.Event
-	status   int
-	can_mmap bool
-	grow(handle voidptr, new_size u64) ?
-	read(handle voidptr, buf voidptr, loc u64, count u64) ?i64
-	write(handle voidptr, buf voidptr, loc u64, count u64) ?i64
-	ioctl(handle voidptr, request u64, argp voidptr) ?int
-	unref(handle voidptr) ?
-	link(handle voidptr) ?
-	unlink(handle voidptr) ?
-	mmap(page u64, flags int) voidptr
-}
-
-__global (
-	dev_id_counter = u64(1)
-)
-
-pub fn create_dev_id() u64 {
-	return dev_id_counter++
-}
-
-pub fn default_ioctl(handle voidptr, request u64, _ voidptr) ?int {
-	match request {
-		ioctl.tcgets, ioctl.tcsets, ioctl.tiocsctty, ioctl.tiocgwinsz {
-			errno.set(errno.enotty)
-			return none
-		}
-		else {
-			errno.set(errno.einval)
-			return none
-		}
-	}
-}
diff --git a/kernel/modules/sched/sched.v b/kernel/modules/sched/sched.v
deleted file mode 100644
index 364bdc8..0000000
--- a/kernel/modules/sched/sched.v
+++ /dev/null
@@ -1,572 +0,0 @@
-@[has_globals]
-module sched
-
-import x86.cpu
-import x86.cpu.local as cpulocal
-import x86.idt
-import x86.apic
-import katomic
-import proc
-import memory
-import memory.mmap
-import elf
-import lib
-import errno
-
-const stack_size = u64(0x200000)
-
-const max_running_threads = int(512)
-
-__global (
-	scheduler_vector        u8
-	scheduler_running_queue [512]&proc.Thread
-	kernel_process          &proc.Process
-)
-
-pub fn initialise() {
-	scheduler_vector = idt.allocate_vector()
-	println('sched: Scheduler interrupt vector is 0x${scheduler_vector:x}')
-
-	interrupt_table[scheduler_vector] = voidptr(scheduler_isr)
-	idt.set_ist(scheduler_vector, 1)
-
-	kernel_process = &proc.Process{
-		pagemap: &kernel_pagemap
-	}
-}
-
-fn get_next_thread() &proc.Thread {
-	mut cpu_local := cpulocal.current()
-
-	mut orig_i := cpu_local.last_run_queue_index
-
-	if orig_i >= max_running_threads {
-		orig_i = 0
-	}
-
-	mut index := orig_i + 1
-
-	for {
-		if index >= max_running_threads {
-			index = 0
-		}
-
-		mut t := scheduler_running_queue[index]
-
-		if unsafe { t != 0 } {
-			if t.l.test_and_acquire() == true {
-				cpu_local.last_run_queue_index = index
-				return t
-			}
-		}
-
-		if index == orig_i {
-			break
-		}
-
-		index++
-	}
-
-	cpu_local.last_run_queue_index = index
-	return unsafe { nil }
-}
-
-fn C.userland__dispatch_a_signal(context &cpulocal.GPRState)
-
-fn scheduler_isr(_ u32, gpr_state &cpulocal.GPRState) {
-	apic.lapic_timer_stop()
-
-	mut cpu_local := cpulocal.current()
-
-	katomic.store(mut &cpu_local.is_idle, false)
-
-	mut current_thread := proc.current_thread()
-
-	mut next_thread := get_next_thread()
-
-	if unsafe { current_thread != 0 } {
-		current_thread.yield_await.release()
-
-		if unsafe { next_thread == nil } && current_thread.is_in_queue {
-			apic.lapic_eoi()
-			apic.lapic_timer_oneshot(mut cpu_local, scheduler_vector, current_thread.timeslice)
-			return
-		}
-		unsafe {
-			current_thread.gpr_state = *gpr_state
-		}
-		current_thread.gs_base = cpu.get_kernel_gs_base()
-		current_thread.fs_base = cpu.get_fs_base()
-		current_thread.cr3 = cpu.read_cr3()
-		fpu_save(current_thread.fpu_storage)
-		katomic.store(mut &current_thread.running_on, u64(-1))
-		current_thread.l.release()
-	}
-
-	if unsafe { next_thread == nil } {
-		apic.lapic_eoi()
-		cpu.set_gs_base(u64(&cpu_local.cpu_number))
-		cpu.set_kernel_gs_base(u64(&cpu_local.cpu_number))
-		katomic.store(mut &cpu_local.is_idle, true)
-		kernel_pagemap.switch_to()
-		await()
-	}
-
-	current_thread = next_thread
-
-	cpu.set_gs_base(u64(current_thread))
-	if current_thread.gpr_state.cs == 0x43 {
-		cpu.set_kernel_gs_base(current_thread.gs_base)
-	} else {
-		cpu.set_kernel_gs_base(u64(current_thread))
-	}
-	cpu.set_fs_base(current_thread.fs_base)
-
-	cpu_local.tss.ist3 = current_thread.pf_stack
-
-	if cpu.read_cr3() != current_thread.cr3 {
-		cpu.write_cr3(current_thread.cr3)
-	}
-
-	fpu_restore(current_thread.fpu_storage)
-
-	katomic.store(mut &current_thread.running_on, cpu_local.cpu_number)
-
-	apic.lapic_eoi()
-	apic.lapic_timer_oneshot(mut cpu_local, scheduler_vector, current_thread.timeslice)
-
-	new_gpr_state := &current_thread.gpr_state
-
-	if new_gpr_state.cs == user_code_seg {
-		// C.userland__dispatch_a_signal(new_gpr_state)
-	}
-
-	asm volatile amd64 {
-		mov rsp, new_gpr_state
-		pop rax
-		mov ds, eax
-		pop rax
-		mov es, eax
-		pop rax
-		pop rbx
-		pop rcx
-		pop rdx
-		pop rsi
-		pop rdi
-		pop rbp
-		pop r8
-		pop r9
-		pop r10
-		pop r11
-		pop r12
-		pop r13
-		pop r14
-		pop r15
-		add rsp, 8
-		swapgs
-		iretq
-		; ; rm (new_gpr_state)
-		; memory
-	}
-
-	for {}
-}
-
-pub fn enqueue_thread(_thread &proc.Thread, by_signal bool) bool {
-	mut t := unsafe { _thread }
-
-	if t.is_in_queue == true {
-		return true
-	}
-
-	katomic.store(mut &t.enqueued_by_signal, by_signal)
-
-	for i := u64(0); i < max_running_threads; i++ {
-		if katomic.cas[&proc.Thread](mut &scheduler_running_queue[i], unsafe { nil },
-			t)
-		{
-			t.is_in_queue = true
-
-			// Check if any CPU is idle and wake it up
-			for cpu in cpu_locals {
-				if katomic.load(&cpu.is_idle) == true {
-					apic.lapic_send_ipi(u8(cpu.lapic_id), scheduler_vector)
-					break
-				}
-			}
-
-			return true
-		}
-	}
-
-	return false
-}
-
-pub fn dequeue_thread(_thread &proc.Thread) bool {
-	mut t := unsafe { _thread }
-
-	if t.is_in_queue == false {
-		return true
-	}
-
-	for i := u64(0); i < max_running_threads; i++ {
-		if katomic.cas[&proc.Thread](mut &scheduler_running_queue[i], t, unsafe { nil }) {
-			t.is_in_queue = false
-			return true
-		}
-	}
-
-	return false
-}
-
-// Like dequeue_thread(), but it stops it immediately
-pub fn intercept_thread(_thread &proc.Thread) ? {
-	mut t := unsafe { _thread }
-
-	if voidptr(t) == voidptr(proc.current_thread()) {
-		return none
-	}
-
-	dequeue_thread(t)
-
-	running_on := t.running_on
-
-	if running_on == u64(-1) {
-		return
-	}
-
-	apic.lapic_send_ipi(u8(cpu_locals[running_on].lapic_id), scheduler_vector)
-
-	t.l.acquire()
-	t.l.release()
-}
-
-pub fn yield(save_ctx bool) {
-	asm volatile amd64 {
-		cli
-	}
-
-	apic.lapic_timer_stop()
-
-	mut cpu_local := cpulocal.current()
-
-	mut current_thread := proc.current_thread()
-
-	if save_ctx == true {
-		current_thread.yield_await.acquire()
-	} else {
-		cpu.set_gs_base(u64(&cpu_local.cpu_number))
-		cpu.set_kernel_gs_base(u64(&cpu_local.cpu_number))
-	}
-
-	apic.lapic_send_ipi(u8(cpu_local.lapic_id), scheduler_vector)
-
-	asm volatile amd64 {
-		sti
-	}
-
-	if save_ctx == true {
-		current_thread.yield_await.acquire()
-		current_thread.yield_await.release()
-	} else {
-		for {
-			asm volatile amd64 {
-				hlt
-			}
-		}
-	}
-}
-
-pub fn dequeue_and_yield() {
-	asm volatile amd64 {
-		cli
-	}
-	dequeue_thread(proc.current_thread())
-	yield(true)
-}
-
-@[noreturn]
-pub fn dequeue_and_die() {
-	asm volatile amd64 {
-		cli
-	}
-	mut t := proc.current_thread()
-	dequeue_thread(t)
-	// for ptr in t.stacks {
-	// memory.pmm_free(ptr, sched.stack_size / page_size)
-	//}
-	unsafe {
-		// t.stacks.free()
-		// free(t)
-	}
-	yield(false)
-	for {}
-}
-
-pub fn new_kernel_thread(pc voidptr, arg voidptr, autoenqueue bool) &proc.Thread {
-	mut stacks := []voidptr{}
-
-	stack_phys := memory.pmm_alloc(stack_size / page_size)
-	stacks << stack_phys
-	stack := u64(stack_phys) + stack_size + higher_half
-
-	gpr_state := cpulocal.GPRState{
-		cs:     kernel_code_seg
-		ds:     kernel_data_seg
-		es:     kernel_data_seg
-		ss:     kernel_data_seg
-		rflags: 0x202
-		rip:    u64(pc)
-		rdi:    u64(arg)
-		rbp:    u64(0)
-		rsp:    stack
-	}
-
-	mut t := &proc.Thread{
-		process:     kernel_process
-		cr3:         u64(kernel_process.pagemap.top_level)
-		gpr_state:   gpr_state
-		timeslice:   5000
-		running_on:  u64(-1)
-		stacks:      stacks
-		fpu_storage: voidptr(u64(memory.pmm_alloc(lib.div_roundup(fpu_storage_size, page_size))) +
-			higher_half)
-	}
-
-	unsafe { stacks.free() }
-
-	t.self = voidptr(t)
-	t.gs_base = u64(voidptr(t))
-
-	if autoenqueue == true {
-		enqueue_thread(t, false)
-	}
-
-	return t
-}
-
-pub fn syscall_new_thread(_ voidptr, pc voidptr, stack u64) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: new_thread(0x%llx, 0x%llx)\n', process.name.str, pc, stack)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut empty_string_array := []string{}
-	defer {
-		unsafe { empty_string_array.free() }
-	}
-
-	mut new_thread := new_user_thread(process, false, pc, unsafe { nil }, stack, empty_string_array,
-		empty_string_array, unsafe { nil }, false) or { return errno.err, errno.get() }
-
-	enqueue_thread(new_thread, false)
-
-	return u64(new_thread.tid), 0
-}
-
-pub fn new_user_thread(_process &proc.Process, want_elf bool, pc voidptr, arg voidptr, _stack u64, argv []string, envp []string, auxval &elf.Auxval, autoenqueue bool) ?&proc.Thread {
-	mut process := unsafe { _process }
-
-	mut stacks := []voidptr{}
-	defer {
-		unsafe { stacks.free() }
-	}
-
-	mut stack := unsafe { &u64(0) }
-	mut stack_vma := u64(0)
-
-	if _stack == 0 {
-		stack_phys := memory.pmm_alloc(stack_size / page_size)
-		stack = unsafe { &u64(u64(stack_phys) + stack_size + higher_half) }
-
-		stack_vma = process.thread_stack_top
-		process.thread_stack_top -= stack_size
-		stack_bottom_vma := process.thread_stack_top
-		process.thread_stack_top -= page_size
-
-		mmap.map_range(mut process.pagemap, stack_bottom_vma, u64(stack_phys), stack_size,
-			mmap.prot_read | mmap.prot_write, mmap.map_anonymous) or { return none }
-	} else {
-		stack = &u64(voidptr(_stack))
-		stack_vma = _stack
-	}
-
-	kernel_stack_phys := memory.pmm_alloc(stack_size / page_size)
-	stacks << kernel_stack_phys
-	kernel_stack := u64(kernel_stack_phys) + stack_size + higher_half
-
-	pf_stack_phys := memory.pmm_alloc(stack_size / page_size)
-	stacks << pf_stack_phys
-	pf_stack := u64(pf_stack_phys) + stack_size + higher_half
-
-	gpr_state := cpulocal.GPRState{
-		cs:     user_code_seg
-		ds:     user_data_seg
-		es:     user_data_seg
-		ss:     user_data_seg
-		rflags: 0x202
-		rip:    u64(pc)
-		rdi:    u64(arg)
-		rsp:    u64(stack_vma)
-	}
-
-	mut t := &proc.Thread{
-		process:      process
-		cr3:          u64(process.pagemap.top_level)
-		gpr_state:    gpr_state
-		timeslice:    5000
-		running_on:   u64(-1)
-		kernel_stack: kernel_stack
-		pf_stack:     pf_stack
-		stacks:       stacks
-		fpu_storage:  voidptr(u64(memory.pmm_alloc(lib.div_roundup(fpu_storage_size, page_size))) +
-			higher_half)
-	}
-
-	t.self = voidptr(t)
-	t.gs_base = u64(0)
-	t.fs_base = u64(0)
-
-	// Set up FPU control word and MXCSR as defined in the sysv ABI
-	fpu_restore(t.fpu_storage)
-
-	default_fcw := u16(0b1100111111)
-
-	asm volatile amd64 {
-		fldcw default_fcw
-		; ; m (default_fcw)
-		; memory
-	}
-
-	default_mxcsr := u32(0b1111110000000)
-
-	asm volatile amd64 {
-		ldmxcsr default_mxcsr
-		; ; m (default_mxcsr)
-		; memory
-	}
-
-	fpu_save(t.fpu_storage)
-
-	// Set all sigactions to default
-	for mut sa in t.sigactions {
-		sa.sa_sigaction = voidptr(-2)
-	}
-
-	if want_elf == true {
-		unsafe {
-			stack_top := stack
-			mut orig_stack_vma := stack_vma
-
-			for elem in envp {
-				stack = &u64(u64(stack) - u64(elem.len + 1))
-				C.memcpy(voidptr(stack), elem.str, elem.len + 1)
-			}
-			for elem in argv {
-				stack = &u64(u64(stack) - u64(elem.len + 1))
-				C.memcpy(voidptr(stack), elem.str, elem.len + 1)
-			}
-
-			stack = &u64(u64(stack) - (u64(stack) & 0x0f))
-
-			// Ensure final stack pointer is 16 byte aligned
-			if (argv.len + envp.len + 1) & 1 != 0 {
-				stack = &stack[-1]
-			}
-
-			// Zero auxiliary vector entry
-			stack[-1] = 0
-			stack = &stack[-1]
-			stack[-1] = 0
-			stack = &stack[-1]
-
-			stack = &stack[-2]
-			stack[0] = elf.at_secure
-			stack[1] = 0
-			stack = &stack[-2]
-			stack[0] = elf.at_entry
-			stack[1] = auxval.at_entry
-			stack = &stack[-2]
-			stack[0] = elf.at_phdr
-			stack[1] = auxval.at_phdr
-			stack = &stack[-2]
-			stack[0] = elf.at_phent
-			stack[1] = auxval.at_phent
-			stack = &stack[-2]
-			stack[0] = elf.at_phnum
-			stack[1] = auxval.at_phnum
-
-			stack[-1] = 0
-			stack = &stack[-1]
-			stack = &stack[-envp.len]
-			for i := u64(0); i < envp.len; i++ {
-				orig_stack_vma -= u64(envp[i].len) + 1
-				stack[i] = orig_stack_vma
-			}
-
-			stack[-1] = 0
-			stack = &stack[-1]
-			stack = &stack[-argv.len]
-			for i := u64(0); i < argv.len; i++ {
-				orig_stack_vma -= u64(argv[i].len) + 1
-				stack[i] = orig_stack_vma
-			}
-
-			stack[-1] = u64(argv.len)
-			stack = &stack[-1]
-
-			t.gpr_state.rsp -= u64(stack_top) - u64(stack)
-		}
-	}
-
-	if autoenqueue == true {
-		enqueue_thread(t, false)
-	}
-
-	t.tid = process.threads.len
-	process.threads << t
-
-	return t
-}
-
-pub fn new_process(old_process &proc.Process, pagemap &memory.Pagemap) ?&proc.Process {
-	mut new_process := &proc.Process{
-		pagemap: unsafe { nil }
-	}
-
-	new_process.pid = proc.allocate_pid(new_process) or { return none }
-
-	if unsafe { old_process != 0 } {
-		new_process.ppid = old_process.pid
-		new_process.pagemap = mmap.fork_pagemap(old_process.pagemap) or { return none }
-		new_process.thread_stack_top = old_process.thread_stack_top
-		new_process.mmap_anon_non_fixed_base = old_process.mmap_anon_non_fixed_base
-		new_process.current_directory = old_process.current_directory
-	} else {
-		new_process.ppid = 0
-		new_process.pagemap = unsafe { pagemap }
-		new_process.thread_stack_top = u64(0x70000000000)
-		new_process.mmap_anon_non_fixed_base = u64(0x80000000000)
-		new_process.current_directory = voidptr(vfs_root)
-	}
-
-	return new_process
-}
-
-pub fn await() {
-	asm volatile amd64 {
-		cli
-	}
-	mut cpu_local := cpulocal.current()
-	apic.lapic_timer_oneshot(mut cpu_local, scheduler_vector, 20000)
-	asm volatile amd64 {
-		sti
-		1:
-		hlt
-		jmp b1
-		; ; ; memory
-	}
-}
diff --git a/kernel/modules/socket/public/public.v b/kernel/modules/socket/public/public.v
deleted file mode 100644
index ea1e823..0000000
--- a/kernel/modules/socket/public/public.v
+++ /dev/null
@@ -1,41 +0,0 @@
-module public
-
-import resource { Resource }
-
-pub const af_inet = 2
-pub const af_inet6 = 10
-pub const af_unix = 1
-pub const af_local = 1
-pub const af_unspec = 0
-pub const af_netlink = 16
-
-pub const sock_nonblock = 0o4000
-pub const sock_cloexec = 0o2000000
-
-pub interface Socket {
-	Resource
-mut:
-	bind(handle voidptr, _addr voidptr, addrlen u32) ?
-	connect(handle voidptr, _addr voidptr, addrlen u32) ?
-	peername(handle voidptr, _addr voidptr, addrlen &u32) ?
-	listen(handle voidptr, backlog int) ?
-	accept(handle voidptr) ?&Resource
-	recvmsg(handle voidptr, msg &MsgHdr, flags int) ?u64
-}
-
-pub struct IoVec {
-pub mut:
-	iov_base voidptr
-	iov_len  u64
-}
-
-pub struct MsgHdr {
-pub mut:
-	msg_name       voidptr
-	msg_namelen    u32
-	msg_iov        &IoVec
-	msg_iovlen     u64
-	msg_control    voidptr
-	msg_controllen u64
-	msg_flags      int
-}
diff --git a/kernel/modules/socket/socket.v b/kernel/modules/socket/socket.v
deleted file mode 100644
index f7dd7b8..0000000
--- a/kernel/modules/socket/socket.v
+++ /dev/null
@@ -1,280 +0,0 @@
-module socket
-
-import resource
-import file
-import errno
-import socket.public as sock_pub
-import socket.unix as sock_unix
-import proc
-
-pub fn initialise() {}
-
-fn socketpair_create(domain int, @type int, protocol int) ?(&resource.Resource, &resource.Resource) {
-	match domain {
-		sock_pub.af_unix {
-			socket0, socket1 := sock_unix.create_pair(@type)?
-			return &resource.Resource(*socket0), &resource.Resource(*socket1)
-		}
-		else {
-			C.printf(c'socket: Unknown domain: %d\n', domain)
-			errno.set(errno.einval)
-			return none
-		}
-	}
-}
-
-fn socket_create(domain int, @type int, protocol int) ?&resource.Resource {
-	match domain {
-		sock_pub.af_unix {
-			ret := sock_unix.create(@type)?
-			return ret
-		}
-		else {
-			C.printf(c'socket: Unknown domain: %d\n', domain)
-			errno.set(errno.einval)
-			return none
-		}
-	}
-}
-
-pub fn syscall_socketpair(_ voidptr, domain int, @type int, protocol int, ret &int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: socketpair(%d, 0x%x, %d, 0x%llx)\n', process.name.str,
-		domain, @type, protocol, voidptr(ret))
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut socket0, mut socket1 := socketpair_create(domain, @type, protocol) or {
-		return errno.err, errno.get()
-	}
-
-	mut flags := int(0)
-	if @type & sock_pub.sock_cloexec != 0 {
-		flags |= resource.o_cloexec
-	}
-	if @type & sock_pub.sock_nonblock != 0 {
-		flags |= resource.o_nonblock
-	}
-
-	unsafe {
-		ret[0] = file.fdnum_create_from_resource(nil, mut socket0, flags, 0, false) or {
-			return errno.err, errno.get()
-		}
-
-		ret[1] = file.fdnum_create_from_resource(nil, mut socket1, flags, 0, false) or {
-			return errno.err, errno.get()
-		}
-	}
-	return 0, 0
-}
-
-pub fn syscall_socket(_ voidptr, domain int, @type int, protocol int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: socket(%d, 0x%x, %d)\n', process.name.str, domain, @type,
-		protocol)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut sock := socket_create(domain, @type, protocol) or { return errno.err, errno.get() }
-
-	mut flags := int(0)
-	if @type & sock_pub.sock_cloexec != 0 {
-		flags |= resource.o_cloexec
-	}
-	if @type & sock_pub.sock_nonblock != 0 {
-		flags |= resource.o_nonblock
-	}
-
-	ret := file.fdnum_create_from_resource(unsafe { nil }, mut sock, flags, 0, false) or {
-		return errno.err, errno.get()
-	}
-
-	return u64(ret), 0
-}
-
-pub fn syscall_accept(_ voidptr, fdnum int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: accept(%d)\n', process.name.str, fdnum)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut fd := file.fd_from_fdnum(unsafe { nil }, fdnum) or { return errno.err, errno.get() }
-	defer {
-		fd.unref()
-	}
-
-	mut res := fd.handle.resource
-
-	mut sock := &sock_pub.Socket(unsafe { nil })
-
-	if mut res is sock_unix.UnixSocket {
-		sock = res
-	} else {
-		return errno.err, errno.einval
-	}
-
-	mut connection_socket := sock.accept(fd.handle) or { return errno.err, errno.get() }
-
-	ret := file.fdnum_create_from_resource(unsafe { nil }, mut connection_socket, 0, 0,
-		false) or { return errno.err, errno.get() }
-
-	return u64(ret), 0
-}
-
-pub fn syscall_bind(_ voidptr, fdnum int, _addr voidptr, addrlen u32) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: bind(%d, 0x%llx, 0x%llx)\n', process.name.str, fdnum, _addr,
-		addrlen)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut fd := file.fd_from_fdnum(unsafe { nil }, fdnum) or { return errno.err, errno.get() }
-	defer {
-		fd.unref()
-	}
-
-	mut res := fd.handle.resource
-
-	mut sock := &sock_pub.Socket(unsafe { nil })
-
-	if mut res is sock_unix.UnixSocket {
-		sock = res
-	} else {
-		return errno.err, errno.einval
-	}
-
-	sock.bind(fd.handle, _addr, addrlen) or { return errno.err, errno.get() }
-
-	return 0, 0
-}
-
-pub fn syscall_listen(_ voidptr, fdnum int, backlog int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: listen(%d, %d)\n', process.name.str, fdnum, backlog)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut fd := file.fd_from_fdnum(unsafe { nil }, fdnum) or { return errno.err, errno.get() }
-	defer {
-		fd.unref()
-	}
-
-	mut res := fd.handle.resource
-
-	mut sock := &sock_pub.Socket(unsafe { nil })
-
-	if mut res is sock_unix.UnixSocket {
-		sock = res
-	} else {
-		return errno.err, errno.einval
-	}
-
-	sock.listen(fd.handle, backlog) or { return errno.err, errno.get() }
-
-	return 0, 0
-}
-
-pub fn syscall_recvmsg(_ voidptr, fdnum int, msg &sock_pub.MsgHdr, flags int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: recvmsg(%d, 0x%llx, 0x%x)\n', process.name.str, fdnum,
-		voidptr(msg), flags)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut fd := file.fd_from_fdnum(unsafe { nil }, fdnum) or { return errno.err, errno.get() }
-	defer {
-		fd.unref()
-	}
-
-	mut res := fd.handle.resource
-
-	mut sock := &sock_pub.Socket(unsafe { nil })
-
-	if mut res is sock_unix.UnixSocket {
-		sock = res
-	} else {
-		return errno.err, errno.einval
-	}
-
-	ret := sock.recvmsg(fd.handle, msg, flags) or { return errno.err, errno.get() }
-
-	return ret, 0
-}
-
-pub fn syscall_connect(_ voidptr, fdnum int, _addr voidptr, addrlen u32) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: connect(%d, 0x%llx, 0x%llx)\n', process.name.str, fdnum,
-		_addr, addrlen)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut fd := file.fd_from_fdnum(unsafe { nil }, fdnum) or { return errno.err, errno.get() }
-	defer {
-		fd.unref()
-	}
-
-	mut res := fd.handle.resource
-
-	mut sock := &sock_pub.Socket(unsafe { nil })
-
-	if mut res is sock_unix.UnixSocket {
-		sock = res
-	} else {
-		return errno.err, errno.einval
-	}
-
-	sock.connect(fd.handle, _addr, addrlen) or { return errno.err, errno.get() }
-
-	return 0, 0
-}
-
-pub fn syscall_getpeername(_ voidptr, fdnum int, _addr voidptr, addrlen &u32) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: getpeername(%d, 0x%llx, 0x%llx)\n', process.name.str, fdnum,
-		_addr, addrlen)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut fd := file.fd_from_fdnum(unsafe { nil }, fdnum) or { return errno.err, errno.get() }
-	defer {
-		fd.unref()
-	}
-
-	mut res := fd.handle.resource
-
-	mut sock := &sock_pub.Socket(unsafe { nil })
-
-	if mut res is sock_unix.UnixSocket {
-		sock = res
-	} else {
-		return errno.err, errno.einval
-	}
-
-	sock.peername(fd.handle, _addr, addrlen) or { return errno.err, errno.get() }
-
-	return 0, 0
-}
diff --git a/kernel/modules/socket/unix/unix.v b/kernel/modules/socket/unix/unix.v
deleted file mode 100644
index e3c4583..0000000
--- a/kernel/modules/socket/unix/unix.v
+++ /dev/null
@@ -1,521 +0,0 @@
-module unix
-
-import stat
-import klock
-import event.eventstruct
-import errno
-import proc
-import fs
-import socket.public as sock_pub
-import event
-import file
-import resource
-import katomic
-import ioctl
-
-pub const sock_buf = 0x100000
-
-pub struct SockaddrUn {
-pub mut:
-	sun_family u16
-	sun_path   [108]u8
-}
-
-pub struct UnixSocket {
-pub mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	status   int
-	can_mmap bool
-	event    eventstruct.Event
-
-	name      SockaddrUn
-	listening bool
-	backlog   []&UnixSocket
-
-	connection_event eventstruct.Event
-	connected        bool
-	peer             &UnixSocket = unsafe { nil }
-
-	data      &u8 = unsafe { nil }
-	read_ptr  u64
-	write_ptr u64
-	capacity  u64
-	used      u64
-}
-
-fn (mut this UnixSocket) mmap(page u64, flags int) voidptr {
-	return 0
-}
-
-fn (mut this UnixSocket) read(_handle voidptr, buf voidptr, loc u64, _count u64) ?i64 {
-	mut count := _count
-
-	this.l.acquire()
-	defer {
-		this.l.release()
-	}
-
-	handle := unsafe { &file.Handle(_handle) }
-
-	// If pipe is empty, block or return if nonblock
-	for katomic.load(&this.used) == 0 {
-		// Return EOF if the pipe was closed
-		//		if this.refcount <= 1 {
-		//			return 0
-		//		}
-		if handle.flags & resource.o_nonblock != 0 {
-			errno.set(errno.ewouldblock)
-			return none
-		}
-		this.l.release()
-		mut events := [&this.event]
-		event.await(mut events, true) or {
-			unsafe { events.free() }
-			errno.set(errno.eintr)
-			return none
-		}
-		unsafe { events.free() }
-		this.l.acquire()
-	}
-
-	if this.used < count {
-		count = this.used
-	}
-
-	// Calculate sizes before and after wrap-around and new ptr location
-	mut before_wrap := u64(0)
-	mut after_wrap := u64(0)
-	mut new_ptr_loc := u64(0)
-	if this.read_ptr + count > this.capacity {
-		before_wrap = this.capacity - this.read_ptr
-		after_wrap = count - before_wrap
-		new_ptr_loc = after_wrap
-	} else {
-		before_wrap = count
-		after_wrap = 0
-		new_ptr_loc = this.read_ptr + count
-		if new_ptr_loc == this.capacity {
-			new_ptr_loc = 0
-		}
-	}
-
-	unsafe { C.memcpy(buf, &this.data[this.read_ptr], before_wrap) }
-	if after_wrap != 0 {
-		unsafe { C.memcpy(voidptr(u64(buf) + before_wrap), this.data, after_wrap) }
-	}
-
-	this.read_ptr = new_ptr_loc
-	this.used -= count
-
-	this.peer.status |= file.pollout
-	event.trigger(mut this.peer.event, false)
-
-	this.status &= ~file.pollin
-
-	return i64(count)
-}
-
-fn (mut this UnixSocket) write(_handle voidptr, buf voidptr, loc u64, _count u64) ?i64 {
-	mut count := _count
-
-	mut peer := this.peer
-
-	peer.l.acquire()
-	defer {
-		peer.l.release()
-	}
-
-	handle := unsafe { &file.Handle(_handle) }
-
-	// If pipe is full, block or return if nonblock
-	for katomic.load(&peer.used) == peer.capacity {
-		if handle.flags & resource.o_nonblock != 0 {
-			errno.set(errno.ewouldblock)
-			return none
-		}
-
-		peer.l.release()
-		mut events := [&peer.event]
-		event.await(mut events, true) or {
-			unsafe { events.free() }
-			errno.set(errno.eintr)
-			return none
-		}
-		unsafe { events.free() }
-		peer.l.acquire()
-	}
-
-	if peer.used + count > peer.capacity {
-		count = peer.capacity - peer.used
-	}
-
-	// Calculate sizes before and after wrap-around and new ptr location
-	mut before_wrap := u64(0)
-	mut after_wrap := u64(0)
-	mut new_ptr_loc := u64(0)
-	if peer.write_ptr + count > peer.capacity {
-		before_wrap = peer.capacity - peer.write_ptr
-		after_wrap = count - before_wrap
-		new_ptr_loc = after_wrap
-	} else {
-		before_wrap = count
-		after_wrap = 0
-		new_ptr_loc = peer.write_ptr + count
-		if new_ptr_loc == peer.capacity {
-			new_ptr_loc = 0
-		}
-	}
-
-	unsafe { C.memcpy(&peer.data[peer.write_ptr], buf, before_wrap) }
-	if after_wrap != 0 {
-		unsafe { C.memcpy(peer.data, voidptr(u64(buf) + before_wrap), after_wrap) }
-	}
-
-	peer.write_ptr = new_ptr_loc
-	peer.used += count
-
-	peer.status |= file.pollin
-	event.trigger(mut peer.event, false)
-
-	return i64(count)
-}
-
-fn (mut this UnixSocket) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	match request {
-		ioctl.fionread {
-			if this.listening {
-				errno.set(errno.einval)
-				return none
-			}
-			mut retp := &u64(argp)
-			unsafe {
-				*retp = this.used
-			}
-			return 0
-		}
-		else {
-			return resource.default_ioctl(handle, request, argp)
-		}
-	}
-}
-
-fn (mut this UnixSocket) unref(handle voidptr) ? {
-	return none
-}
-
-fn (mut this UnixSocket) link(handle voidptr) ? {
-	return none
-}
-
-fn (mut this UnixSocket) unlink(handle voidptr) ? {
-	return none
-}
-
-fn (mut this UnixSocket) grow(handle voidptr, new_size u64) ? {
-	return none
-}
-
-fn (mut this UnixSocket) peername(handle voidptr, _addr voidptr, addrlen &u32) ? {
-	if this.connected == false {
-		errno.set(errno.enotconn)
-		return none
-	}
-
-	mut actual_size := unsafe { *addrlen }
-	if actual_size < sizeof(SockaddrUn) {
-		actual_size = sizeof(SockaddrUn)
-	}
-
-	unsafe { C.memcpy(_addr, voidptr(&this.peer.name), actual_size) }
-	unsafe {
-		*addrlen = actual_size
-	}
-}
-
-fn (mut this UnixSocket) accept(_handle voidptr) ?&resource.Resource {
-	if this.listening == false {
-		errno.set(errno.einval)
-		return none
-	}
-
-	this.l.acquire()
-	defer {
-		this.l.release()
-	}
-
-	handle := unsafe { &file.Handle(_handle) }
-
-	for this.backlog.len == 0 {
-		this.status &= ~file.pollin
-		if handle.flags & resource.o_nonblock != 0 {
-			errno.set(errno.ewouldblock)
-			return none
-		}
-		this.l.release()
-		mut events := [&this.event]
-		event.await(mut events, true) or {
-			unsafe { events.free() }
-			errno.set(errno.eintr)
-			return none
-		}
-		unsafe { events.free() }
-		this.l.acquire()
-	}
-
-	mut peer := this.backlog.pop()
-
-	mut connection_socket := &UnixSocket{
-		refcount:  1
-		peer:      peer
-		connected: true
-		name:      peer.name
-		data:      unsafe { malloc(sock_buf) }
-		capacity:  sock_buf
-	}
-
-	peer.refcount++
-	peer.peer = connection_socket
-	peer.connected = true
-
-	if this.backlog.len == 0 {
-		this.status &= ~file.pollin
-	}
-
-	event.trigger(mut peer.connection_event, false)
-
-	mut events := [&this.connection_event]
-	event.await(mut events, true) or {
-		unsafe { events.free() }
-		errno.set(errno.eintr)
-		return none
-	}
-	unsafe { events.free() }
-
-	return connection_socket
-}
-
-fn (mut this UnixSocket) connect(handle voidptr, _addr voidptr, addrlen u32) ? {
-	addr := unsafe { &SockaddrUn(_addr) }
-
-	if addr.sun_family != sock_pub.af_unix {
-		errno.set(errno.einval)
-		return none
-	}
-
-	mut t := proc.current_thread()
-
-	path := unsafe { cstring_to_vstring(&addr.sun_path[0]) }
-
-	C.printf(c'UNIX socket: Wants to connect to %s\n', path.str)
-
-	mut target := fs.get_node(t.process.current_directory, path, true) or { return none }
-
-	mut target_res := target.resource
-
-	mut socket := &UnixSocket(unsafe { nil })
-
-	if mut target_res is UnixSocket {
-		socket = target_res
-	} else {
-		errno.set(errno.einval)
-		return none
-	}
-
-	// ----
-
-	if socket.listening == false {
-		errno.set(errno.econnrefused)
-		return none
-	}
-
-	socket.l.acquire()
-
-	socket.backlog << this
-
-	socket.status |= file.pollin
-	event.trigger(mut socket.event, false)
-
-	socket.l.release()
-
-	mut events := [&this.connection_event]
-	event.await(mut events, true) or {
-		unsafe { events.free() }
-		errno.set(errno.eintr)
-		return none
-	}
-	unsafe { events.free() }
-
-	event.trigger(mut socket.connection_event, false)
-
-	C.printf(c'UNIX socket: Connected!\n')
-
-	this.status |= file.pollout
-	event.trigger(mut this.event, false)
-}
-
-fn (mut this UnixSocket) bind(handle voidptr, _addr voidptr, addrlen u32) ? {
-	addr := unsafe { &SockaddrUn(_addr) }
-
-	if addr.sun_family != sock_pub.af_unix {
-		errno.set(errno.einval)
-		return none
-	}
-
-	mut t := proc.current_thread()
-
-	path := unsafe { cstring_to_vstring(&addr.sun_path[0]) }
-
-	mut node := fs.create(t.process.current_directory, path, stat.ifsock) or { return none }
-
-	this.stat = node.resource.stat
-	node.resource = unsafe { this }
-
-	this.name = *addr
-}
-
-fn (mut this UnixSocket) listen(handle voidptr, backlog int) ? {
-	this.backlog = []&UnixSocket{cap: backlog}
-	this.listening = true
-}
-
-fn (mut this UnixSocket) recvmsg(_handle voidptr, msg &sock_pub.MsgHdr, flags int) ?u64 {
-	if flags != 0 {
-		panic('UNIX socket recv does not support flags')
-	}
-
-	this.l.acquire()
-	defer {
-		this.l.release()
-	}
-
-	handle := unsafe { &file.Handle(_handle) }
-
-	mut count := u64(0)
-	for i := u64(0); i < msg.msg_iovlen; i++ {
-		count += unsafe { msg.msg_iov[i].iov_len }
-	}
-
-	C.printf(c'%d iovecs, %llu bytes\n', msg.msg_iovlen, count)
-
-	// If pipe is empty, block or return if nonblock
-	for katomic.load(&this.used) == 0 {
-		// Return EOF if the pipe was closed
-		//		if this.refcount <= 1 {
-		//			return 0
-		//		}
-		this.peer.status |= file.pollout
-		event.trigger(mut this.peer.event, false)
-		if handle.flags & resource.o_nonblock != 0 {
-			errno.set(errno.ewouldblock)
-			return none
-		}
-		this.l.release()
-		mut events := [&this.event]
-		event.await(mut events, true) or {
-			unsafe { events.free() }
-			errno.set(errno.eintr)
-			return none
-		}
-		unsafe { events.free() }
-		this.l.acquire()
-	}
-
-	if this.used < count {
-		count = this.used
-	}
-
-	// Calculate sizes before and after wrap-around and new ptr location
-	mut before_wrap := u64(0)
-	mut after_wrap := u64(0)
-	mut new_ptr_loc := u64(0)
-	if this.read_ptr + count > this.capacity {
-		before_wrap = this.capacity - this.read_ptr
-		after_wrap = count - before_wrap
-		new_ptr_loc = after_wrap
-	} else {
-		before_wrap = count
-		after_wrap = 0
-		new_ptr_loc = this.read_ptr + count
-		if new_ptr_loc == this.capacity {
-			new_ptr_loc = 0
-		}
-	}
-
-	mut tmpbuf := unsafe { &u8(malloc(before_wrap + after_wrap)) }
-	unsafe { C.memcpy(tmpbuf, &this.data[this.read_ptr], before_wrap) }
-	if after_wrap != 0 {
-		unsafe { C.memcpy(voidptr(u64(tmpbuf) + before_wrap), this.data, after_wrap) }
-	}
-
-	mut transferred := u64(0)
-	mut left := before_wrap + after_wrap
-	for i := u64(0); i < msg.msg_iovlen; i++ {
-		iov := unsafe { &msg.msg_iov[i] }
-
-		to_transfer := if iov.iov_len < left { iov.iov_len } else { left }
-
-		unsafe {
-			C.memcpy(iov.iov_base, voidptr(u64(tmpbuf) + transferred), to_transfer)
-		}
-
-		transferred += to_transfer
-		left -= to_transfer
-	}
-
-	unsafe { free(tmpbuf) }
-
-	this.read_ptr = new_ptr_loc
-	this.used -= transferred
-
-	this.peer.status |= file.pollout
-	event.trigger(mut this.peer.event, false)
-
-	if msg.msg_name != unsafe { nil } && this.connected {
-		mut actual_size := msg.msg_namelen
-		if actual_size < sizeof(SockaddrUn) {
-			actual_size = sizeof(SockaddrUn)
-		}
-
-		unsafe { C.memcpy(msg.msg_name, voidptr(&this.peer.name), actual_size) }
-		unsafe {
-			msg.msg_namelen = actual_size
-		}
-	}
-
-	C.printf(c'Successfully received %llu bytes\n', transferred)
-
-	this.status &= ~file.pollin
-
-	return transferred
-}
-
-pub fn create(@type int) ?&UnixSocket {
-	mut ret := &UnixSocket{
-		refcount: 1
-		peer:     unsafe { nil }
-		data:     unsafe { malloc(sock_buf) }
-		capacity: sock_buf
-	}
-	ret.name.sun_family = sock_pub.af_unix
-	return ret
-}
-
-pub fn create_pair(@type int) ?(&UnixSocket, &UnixSocket) {
-	mut a := &UnixSocket{
-		refcount: 1
-		peer:     unsafe { nil }
-		data:     unsafe { malloc(sock_buf) }
-		capacity: sock_buf
-	}
-	a.name.sun_family = sock_pub.af_unix
-	mut b := &UnixSocket{
-		refcount: 1
-		peer:     unsafe { nil }
-		data:     unsafe { malloc(sock_buf) }
-		capacity: sock_buf
-	}
-	b.name.sun_family = sock_pub.af_unix
-	return a, b
-}
diff --git a/kernel/modules/stat/stat.v b/kernel/modules/stat/stat.v
deleted file mode 100644
index 61b9cb2..0000000
--- a/kernel/modules/stat/stat.v
+++ /dev/null
@@ -1,79 +0,0 @@
-module stat
-
-import time
-
-pub const ifmt = 0xf000
-pub const ifblk = 0x6000
-pub const ifchr = 0x2000
-pub const ififo = 0x1000
-pub const ifreg = 0x8000
-pub const ifdir = 0x4000
-pub const iflnk = 0xa000
-pub const ifsock = 0xc000
-pub const ifpipe = 0x3000
-
-pub fn isblk(mode u32) bool {
-	return (mode & ifmt) == ifblk
-}
-
-pub fn ischr(mode u32) bool {
-	return (mode & ifmt) == ifchr
-}
-
-pub fn isifo(mode u32) bool {
-	return (mode & ifmt) == ififo
-}
-
-pub fn isreg(mode u32) bool {
-	return (mode & ifmt) == ifreg
-}
-
-pub fn isdir(mode u32) bool {
-	return (mode & ifmt) == ifdir
-}
-
-pub fn islnk(mode u32) bool {
-	return (mode & ifmt) == iflnk
-}
-
-pub fn issock(mode u32) bool {
-	return (mode & ifmt) == ifsock
-}
-
-pub struct Stat {
-pub mut:
-	dev     u64
-	ino     u64
-	nlink   u64
-	mode    u32
-	uid     u32
-	gid     u32
-	pad0    u32
-	rdev    u64
-	size    i64
-	blksize i64
-	blocks  i64
-	atim    time.TimeSpec
-	mtim    time.TimeSpec
-	ctim    time.TimeSpec
-	pad1    [3]i64
-}
-
-pub const dt_unknown = 0
-pub const dt_fifo = 1
-pub const dt_chr = 2
-pub const dt_dir = 4
-pub const dt_blk = 6
-pub const dt_reg = 8
-pub const dt_lnk = 10
-pub const dt_sock = 12
-pub const dt_wht = 14
-
-pub struct Dirent {
-pub mut:
-	ino    u64
-	off    u64
-	reclen u16
-	@type  u8
-	name   [1024]u8
-}
diff --git a/kernel/modules/syscall/syscall.v b/kernel/modules/syscall/syscall.v
deleted file mode 100644
index 4dda733..0000000
--- a/kernel/modules/syscall/syscall.v
+++ /dev/null
@@ -1,82 +0,0 @@
-module syscall
-
-import x86.cpu.local as cpulocal
-// import userland
-
-@[markused]
-fn leave(context &cpulocal.GPRState) {
-	asm volatile amd64 {
-		cli
-	}
-
-	// userland.dispatch_a_signal(context)
-}
-
-@[_naked]
-fn syscall_entry() {
-	asm volatile amd64 {
-		swapgs // Save user stack
-		mov gs:[32], rsp // Switch to kernel stack
-		mov rsp, gs:[24]
-		push 0x3b
-		push gs:[32]
-		push r11
-		push 0x43
-		push rcx
-		push 0
-		push r15
-		push r14
-		push r13
-		push r12
-		push r11
-		push r10
-		push r9
-		push r8
-		push rbp
-		push rdi
-		push rsi
-		push rdx
-		push rcx
-		push rbx
-		push rax
-		mov eax, es
-		push rax
-		mov eax, ds
-		push rax
-		sti // syscall num
-		mov gs:[40], rdi
-		xor rbp, rbp
-		mov rbx, rdi
-		mov rcx, r10
-		mov rdi, rsp
-		lea rax, [rip + syscall_table]
-		call [rax + rbx * 8 + 0]
-		mov [rsp + 16], rax
-		mov [rsp + 40], rdx
-		mov rdi, rsp
-		call syscall__leave
-		pop rax
-		mov ds, eax
-		pop rax
-		mov es, eax
-		pop rax
-		pop rbx
-		pop rcx
-		pop rdx
-		pop rsi
-		pop rdi
-		pop rbp
-		pop r8
-		pop r9
-		pop r10
-		pop r11
-		pop r12
-		pop r13
-		pop r14
-		pop r15 // Restore user stack
-		mov rsp, gs:[32]
-		swapgs
-		sysretq
-		; ; ; memory
-	}
-}
diff --git a/kernel/modules/syscall/table/syscall_table.v b/kernel/modules/syscall/table/syscall_table.v
deleted file mode 100644
index c5c6947..0000000
--- a/kernel/modules/syscall/table/syscall_table.v
+++ /dev/null
@@ -1,93 +0,0 @@
-@[has_globals]
-module table
-
-import kprint
-import file
-import fs
-import x86.cpu
-import userland
-import futex
-import pipe
-import socket
-import memory.mmap
-import time.sys
-import net
-import sched
-import errno
-
-__global (
-	syscall_table [66]voidptr
-)
-
-fn syscall_vacant(_ voidptr) (u64, u64) {
-	return u64(-1), errno.enosys
-}
-
-pub fn init_syscall_table() {
-	syscall_table[0] = voidptr(kprint.syscall_kprint)
-	syscall_table[1] = voidptr(file.syscall_mmap)
-	syscall_table[2] = voidptr(fs.syscall_openat)
-	syscall_table[3] = voidptr(fs.syscall_read)
-	syscall_table[4] = voidptr(fs.syscall_write)
-	syscall_table[5] = voidptr(fs.syscall_seek)
-	syscall_table[6] = voidptr(fs.syscall_close)
-	syscall_table[7] = voidptr(cpu.syscall_set_fs_base)
-	syscall_table[8] = voidptr(cpu.syscall_set_gs_base)
-	syscall_table[9] = voidptr(fs.syscall_ioctl)
-	syscall_table[10] = voidptr(fs.syscall_fstat)
-	syscall_table[11] = voidptr(fs.syscall_fstatat)
-	syscall_table[12] = voidptr(file.syscall_fcntl)
-	syscall_table[13] = voidptr(file.syscall_dup3)
-	syscall_table[14] = voidptr(userland.syscall_fork)
-	syscall_table[15] = voidptr(userland.syscall_exit)
-	syscall_table[16] = voidptr(userland.syscall_waitpid)
-	syscall_table[17] = voidptr(userland.syscall_execve)
-	syscall_table[18] = voidptr(fs.syscall_chdir)
-	syscall_table[19] = voidptr(fs.syscall_readdir)
-	syscall_table[20] = voidptr(fs.syscall_faccessat)
-	syscall_table[21] = voidptr(pipe.syscall_pipe)
-	syscall_table[22] = voidptr(fs.syscall_mkdirat)
-	syscall_table[23] = voidptr(futex.syscall_futex_wait)
-	syscall_table[24] = voidptr(futex.syscall_futex_wake)
-	syscall_table[25] = voidptr(fs.syscall_getcwd)
-	syscall_table[26] = voidptr(userland.syscall_kill)
-	syscall_table[27] = voidptr(userland.syscall_sigentry)
-	syscall_table[28] = voidptr(userland.syscall_sigprocmask)
-	syscall_table[29] = voidptr(userland.syscall_sigaction)
-	syscall_table[30] = voidptr(userland.syscall_sigreturn)
-	syscall_table[31] = voidptr(userland.syscall_getpid)
-	syscall_table[32] = voidptr(userland.syscall_getppid)
-	syscall_table[33] = voidptr(fs.syscall_readlinkat)
-	syscall_table[34] = voidptr(mmap.syscall_munmap)
-	syscall_table[35] = voidptr(fs.syscall_unlinkat)
-	syscall_table[36] = voidptr(file.syscall_ppoll)
-	syscall_table[37] = voidptr(fs.syscall_rmdirat)
-	syscall_table[38] = voidptr(userland.syscall_getgroups)
-	syscall_table[39] = voidptr(socket.syscall_socket)
-	syscall_table[40] = voidptr(socket.syscall_bind)
-	syscall_table[41] = voidptr(socket.syscall_listen)
-	syscall_table[42] = voidptr(fs.syscall_inotify_init)
-	syscall_table[43] = voidptr(fs.syscall_mount)
-	syscall_table[44] = voidptr(fs.syscall_umount)
-	syscall_table[45] = voidptr(userland.syscall_signalfd)
-	syscall_table[46] = voidptr(socket.syscall_socketpair)
-	syscall_table[47] = voidptr(syscall_vacant)
-	syscall_table[48] = voidptr(mmap.syscall_mprotect)
-	syscall_table[49] = voidptr(syscall_vacant)
-	syscall_table[50] = voidptr(sys.syscall_clock_get)
-	syscall_table[51] = voidptr(net.syscall_gethostname)
-	syscall_table[52] = voidptr(net.syscall_sethostname)
-	syscall_table[53] = voidptr(sys.syscall_nanosleep)
-	syscall_table[54] = voidptr(syscall_vacant)
-	syscall_table[55] = voidptr(syscall_vacant)
-	syscall_table[56] = voidptr(syscall_vacant)
-	syscall_table[57] = voidptr(fs.syscall_fchmod)
-	syscall_table[58] = voidptr(fs.syscall_linkat)
-	syscall_table[59] = voidptr(socket.syscall_connect)
-	syscall_table[60] = voidptr(socket.syscall_getpeername)
-	syscall_table[61] = voidptr(socket.syscall_accept)
-	syscall_table[62] = voidptr(socket.syscall_recvmsg)
-	syscall_table[63] = voidptr(syscall_vacant)
-	syscall_table[64] = voidptr(syscall_vacant)
-	syscall_table[65] = voidptr(sched.syscall_new_thread)
-}
diff --git a/kernel/modules/term/term.v b/kernel/modules/term/term.v
deleted file mode 100644
index 32b93b3..0000000
--- a/kernel/modules/term/term.v
+++ /dev/null
@@ -1,84 +0,0 @@
-@[has_globals]
-module term
-
-import klock
-import dev.fbdev.api
-import dev.fbdev.simple
-import limine
-import flanterm as _
-import memory
-
-__global (
-	flanterm_ctx        voidptr
-	terminal_print_lock klock.Lock
-	terminal_rows       = u64(0)
-	terminal_cols       = u64(0)
-	framebuffer_tag     = &limine.LimineFramebuffer(unsafe { nil })
-	framebuffer_width   = u64(0)
-	framebuffer_height  = u64(0)
-)
-
-@[_linker_section: '.requests']
-@[cinit]
-__global (
-	volatile fb_req = limine.LimineFramebufferRequest{
-		response: unsafe { nil }
-	}
-)
-
-pub fn initialise() {
-	if fb_req.response == unsafe { nil } {
-		panic('Framebuffer bootloader response missing')
-	}
-	framebuffer_tag = unsafe { fb_req.response.framebuffers[0] }
-	framebuffer_width = framebuffer_tag.width
-	framebuffer_height = framebuffer_tag.height
-
-	flanterm_ctx = unsafe {
-		C.flanterm_fb_init(voidptr(memory.malloc), voidptr(memory.free), framebuffer_tag.address,
-			framebuffer_width, framebuffer_height, framebuffer_tag.pitch, framebuffer_tag.red_mask_size,
-			framebuffer_tag.red_mask_shift, framebuffer_tag.green_mask_size, framebuffer_tag.green_mask_shift,
-			framebuffer_tag.blue_mask_size, framebuffer_tag.blue_mask_shift, nil, nil,
-			nil, nil, nil, nil, nil, nil, 0, 0, 1, 0, 0, 0)
-	}
-
-	C.flanterm_get_dimensions(flanterm_ctx, &terminal_cols, &terminal_rows)
-}
-
-pub fn framebuffer_init() {
-	sfb_config := simple.SimpleFBConfig{
-		physical_address: u64(framebuffer_tag.address)
-		width:            u32(framebuffer_width)
-		height:           u32(framebuffer_height)
-		stride:           u32(framebuffer_tag.pitch)
-		bits_per_pixel:   u32(framebuffer_tag.bpp)
-		red:              api.FBBitfield{
-			offset:    framebuffer_tag.red_mask_shift
-			length:    framebuffer_tag.red_mask_size
-			msb_right: 0
-		}
-		green:            api.FBBitfield{
-			offset:    framebuffer_tag.green_mask_shift
-			length:    framebuffer_tag.green_mask_size
-			msb_right: 0
-		}
-		blue:             api.FBBitfield{
-			offset:    framebuffer_tag.blue_mask_shift
-			length:    framebuffer_tag.blue_mask_size
-			msb_right: 0
-		}
-		transp:           api.FBBitfield{
-			offset:    0
-			length:    0
-			msb_right: 0
-		}
-	}
-
-	simple.register_simple_framebuffer(sfb_config)
-}
-
-pub fn print(s voidptr, len u64) {
-	terminal_print_lock.acquire()
-	C.flanterm_write(flanterm_ctx, s, len)
-	terminal_print_lock.release()
-}
diff --git a/kernel/modules/termios/termios.v b/kernel/modules/termios/termios.v
deleted file mode 100644
index 6a56ca4..0000000
--- a/kernel/modules/termios/termios.v
+++ /dev/null
@@ -1,97 +0,0 @@
-module termios
-
-pub const brkint = 0o0002
-
-pub const ignpar = 0o0004
-
-pub const echo = 0o0010
-
-pub const echoe = 0o0020
-
-pub const echok = 0o0040
-
-pub const echonl = 0o0100
-
-pub const icanon = 0o0002
-
-pub const inlcr = 0o0100
-
-pub const igncr = 0o0200
-
-pub const icrnl = 0o0400
-
-pub const ixon = 0o2000
-
-pub const imaxbel = 0o20000
-
-pub const iexten = 0o100000
-
-pub const isig = 0o0001
-
-pub const noflsh = 0o0200
-
-pub const tostop = 0o0400
-
-pub const echoctl = 0o1000
-
-pub const echoprt = 0o2000
-
-pub const echoke = 0o4000
-
-pub const opost = 0o0001
-
-pub const onlcr = 0o0004
-
-pub const cs8 = 0o0060
-
-pub const cread = 0o0200
-
-pub const nccs = 32
-
-pub const veof = 4
-
-pub const veol = 11
-
-pub const verase = 2
-
-pub const vintr = 0
-
-pub const vkill = 3
-
-pub const vmin = 6
-
-pub const vquit = 1
-
-pub const vstart = 8
-
-pub const vstop = 9
-
-pub const vsusp = 10
-
-pub const vtime = 5
-
-pub const vdiscard = 13
-
-pub const vreprint = 12
-
-pub const vwerase = 14
-
-pub const vlnext = 15
-
-pub const b38400 = 15
-
-pub struct Termios {
-pub mut:
-	c_iflag u32
-	c_oflag u32
-	c_cflag u32
-	c_lflag u32
-	c_line  u8
-	c_cc    [nccs]u8
-	ibaud   u32
-	obaud   u32
-}
-
-pub fn ctrl(c u8) u8 {
-	return c & 0o37
-}
diff --git a/kernel/modules/time/pit.v b/kernel/modules/time/pit.v
deleted file mode 100644
index 9866cee..0000000
--- a/kernel/modules/time/pit.v
+++ /dev/null
@@ -1,51 +0,0 @@
-module time
-
-import x86.kio
-import x86.idt
-import x86.cpu.local as cpulocal
-
-pub const pit_dividend = u64(1193182)
-
-pub fn pit_get_current_count() u16 {
-	kio.port_out[u8](0x43, 0)
-	lo := kio.port_in[u8](0x40)
-	hi := kio.port_in[u8](0x40)
-	return (u16(hi) << 8) | lo
-}
-
-pub fn pit_set_reload_value(new_count u16) {
-	// Channel 0, lo/hi access mode, mode 2 (rate generator)
-	kio.port_out[u8](0x43, 0x34)
-	kio.port_out[u8](0x40, u8(new_count))
-	kio.port_out[u8](0x40, u8(new_count >> 8))
-}
-
-pub fn pit_set_frequency(frequency u64) {
-	mut new_divisor := pit_dividend / frequency
-	if pit_dividend % frequency > frequency / 2 {
-		new_divisor++
-	}
-
-	pit_set_reload_value(u16(new_divisor))
-}
-
-fn C.x86__apic__io_apic_set_irq_redirect(lapic_id u32, vector u8, irq u8, status bool)
-
-pub fn pit_initialise() {
-	pit_set_frequency(timer_frequency)
-
-	vect := idt.allocate_vector()
-
-	print('timer: PIT vector is 0x${vect:x}\n')
-
-	interrupt_table[vect] = voidptr(pit_handler)
-
-	C.x86__apic__io_apic_set_irq_redirect(cpu_locals[0].lapic_id, vect, 0, true)
-}
-
-fn C.x86__apic__lapic_eoi()
-
-fn pit_handler(num u32, gpr_state &cpulocal.GPRState) {
-	timer_handler()
-	C.x86__apic__lapic_eoi()
-}
diff --git a/kernel/modules/time/sys/syscalls.v b/kernel/modules/time/sys/syscalls.v
deleted file mode 100644
index 0f92b93..0000000
--- a/kernel/modules/time/sys/syscalls.v
+++ /dev/null
@@ -1,112 +0,0 @@
-module sys
-
-import time
-import errno
-import event
-import event.eventstruct
-import proc
-
-pub fn nsleep(ns i64) {
-	mut interval := time.TimeSpec{
-		tv_sec:  ns / 1000000000
-		tv_nsec: ns
-	}
-
-	mut timer := time.new_timer(interval)
-	defer {
-		timer.disarm()
-	}
-
-	mut events := []&eventstruct.Event{}
-	defer {
-		unsafe { events.free() }
-	}
-	events << &timer.event
-
-	event.await(mut events, true) or {}
-}
-
-pub fn syscall_clock_get(_ voidptr, clock_type int, ret &time.TimeSpec) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: clock_get(%d, 0x%llx)\n', process.name.str, clock_type,
-		voidptr(ret))
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	match clock_type {
-		time.clock_type_monotonic {
-			unsafe {
-				*ret = monotonic_clock
-			}
-		}
-		time.clock_type_realtime {
-			unsafe {
-				*ret = realtime_clock
-			}
-		}
-		else {
-			C.printf(c'clock_get: Unknown clock type\n')
-			return errno.err, errno.einval
-		}
-	}
-
-	return 0, 0
-}
-
-pub fn syscall_nanosleep(_ voidptr, req &time.TimeSpec, mut rem time.TimeSpec) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: nanosleep(0x%llx, 0x%llx)\n', process.name.str, voidptr(req),
-		voidptr(rem))
-
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	if req.tv_sec == 0 && req.tv_nsec == 0 {
-		return 0, 0
-	}
-
-	if req.tv_sec < 0 || req.tv_nsec < 0 || req.tv_nsec >= 1000000000 {
-		return errno.err, errno.einval
-	}
-
-	mut events := []&eventstruct.Event{}
-	defer {
-		unsafe { events.free() }
-	}
-
-	mut target_time := *req
-
-	mut timer := time.new_timer(target_time)
-	events << &timer.event
-
-	defer {
-		timer.disarm()
-	}
-
-	event.await(mut events, true) or {
-		if rem != unsafe { nil } {
-			rem.tv_sec = monotonic_clock.tv_sec - target_time.tv_sec
-			rem.tv_nsec = monotonic_clock.tv_nsec - target_time.tv_nsec
-
-			if rem.tv_nsec < 0 {
-				rem.tv_nsec += 1000000000
-				rem.tv_sec--
-			}
-
-			if rem.tv_sec < 0 {
-				rem.tv_sec = 0
-				rem.tv_nsec = 0
-			}
-		}
-
-		return errno.err, errno.eintr
-	}
-
-	return 0, 0
-}
diff --git a/kernel/modules/time/time.v b/kernel/modules/time/time.v
deleted file mode 100644
index 4690e2c..0000000
--- a/kernel/modules/time/time.v
+++ /dev/null
@@ -1,157 +0,0 @@
-@[has_globals]
-module time
-
-import event.eventstruct
-import klock
-import limine
-
-pub const timer_frequency = u64(1000)
-
-pub const clock_type_realtime = 0
-pub const clock_type_monotonic = 1
-
-pub struct TimeSpec {
-pub mut:
-	tv_sec  i64
-	tv_nsec i64
-}
-
-pub fn (mut this TimeSpec) add(interval TimeSpec) {
-	if this.tv_nsec + interval.tv_nsec > 999999999 {
-		diff := (this.tv_nsec + interval.tv_nsec) - 1000000000
-		this.tv_nsec = diff
-		this.tv_sec++
-	} else {
-		this.tv_nsec += interval.tv_nsec
-	}
-	this.tv_sec += interval.tv_sec
-}
-
-pub fn (mut this TimeSpec) sub(interval TimeSpec) bool {
-	if interval.tv_nsec > this.tv_nsec {
-		diff := interval.tv_nsec - this.tv_nsec
-		this.tv_nsec = 999999999 - diff
-		if this.tv_sec == 0 {
-			this.tv_sec = 0
-			this.tv_nsec = 0
-			return true
-		}
-		this.tv_sec--
-	} else {
-		this.tv_nsec -= interval.tv_nsec
-	}
-	if interval.tv_sec > this.tv_sec {
-		this.tv_sec = 0
-		this.tv_nsec = 0
-		return true
-	}
-	this.tv_sec -= interval.tv_sec
-	if this.tv_sec == 0 && this.tv_nsec == 0 {
-		return true
-	}
-	return false
-}
-
-__global (
-	monotonic_clock TimeSpec
-	realtime_clock  TimeSpec
-)
-
-@[_linker_section: '.requests']
-@[cinit]
-__global (
-	volatile boottime_req = limine.LimineBootTimeRequest{
-		response: unsafe { nil }
-	}
-)
-
-pub fn initialise() {
-	epoch := if boottime_req.response != unsafe { nil } {
-		boottime_req.response.boot_time
-	} else {
-		0
-	}
-
-	monotonic_clock = TimeSpec{i64(epoch), 0}
-	realtime_clock = TimeSpec{i64(epoch), 0}
-
-	pit_initialise()
-}
-
-fn C.event__trigger(mut event eventstruct.Event, drop bool) u64
-
-fn timer_handler() {
-	interval := TimeSpec{0, i64(1000000000 / timer_frequency)}
-
-	monotonic_clock.add(interval)
-	realtime_clock.add(interval)
-
-	if timers_lock.test_and_acquire() == true {
-		for i := 0; i < armed_timers.len; i++ {
-			mut timer := armed_timers[i]
-			if timer.fired == true {
-				continue
-			}
-			if timer.when.sub(interval) {
-				C.event__trigger(mut &timer.event, false)
-				timer.fired = true
-			}
-		}
-
-		timers_lock.release()
-	}
-}
-
-pub struct Timer {
-pub mut:
-	when  TimeSpec
-	event eventstruct.Event
-	index int
-	fired bool
-}
-
-__global (
-	timers_lock  klock.Lock
-	armed_timers []&Timer
-)
-
-pub fn (mut this Timer) disarm() {
-	timers_lock.acquire()
-	defer {
-		timers_lock.release()
-	}
-
-	if armed_timers.len == 0 || this.index == -1 {
-		return
-	}
-	if this.index >= armed_timers.len {
-		return
-	}
-
-	armed_timers[this.index] = armed_timers[armed_timers.len - 1]
-	armed_timers[this.index].index = this.index
-	armed_timers.delete_last()
-	this.index = -1
-}
-
-pub fn (mut this Timer) arm() {
-	timers_lock.acquire()
-
-	this.fired = false
-	this.index = armed_timers.len
-	armed_timers << this
-
-	timers_lock.release()
-}
-
-pub fn new_timer(when TimeSpec) &Timer {
-	mut timer := &Timer{
-		when:  when
-		fired: false
-		index: -1
-	}
-
-	timer.arm()
-
-	return timer
-}
diff --git a/kernel/modules/uacpi/uacpi.v b/kernel/modules/uacpi/uacpi.v
deleted file mode 100644
index 974c174..0000000
--- a/kernel/modules/uacpi/uacpi.v
+++ /dev/null
@@ -1,373 +0,0 @@
-module uacpi
-
-import klock
-import event
-import event.eventstruct
-import time
-import x86.kio
-import memory
-import lib
-import kprint
-import lib.stubs
-import x86.hpet
-import pci
-
-pub enum UACPIStatus {
-	ok                      = 0
-	mapping_failed          = 1
-	out_of_memory           = 2
-	bad_checksum            = 3
-	invalid_signature       = 4
-	invalid_table_length    = 5
-	not_found               = 6
-	invalid_argument        = 7
-	unimplemented           = 8
-	already_exists          = 9
-	internal_error          = 10
-	type_mismatch           = 11
-	init_level_mismatch     = 12
-	namespace_node_dangling = 13
-	no_handler              = 14
-	no_resource_end_tag     = 15
-	compiled_out            = 16
-	hardware_timeout        = 17
-	timeout                 = 18
-	overridden              = 19
-	denied                  = 20
-}
-
-pub enum InterruptModel {
-	pic     = 0
-	ioapic  = 1
-	iosapic = 2
-}
-
-@[c_extern]
-fn C.uacpi_initialize(flags u64) UACPIStatus
-@[c_extern]
-fn C.uacpi_namespace_load() UACPIStatus
-@[c_extern]
-fn C.uacpi_namespace_initialize() UACPIStatus
-@[c_extern]
-fn C.uacpi_set_interrupt_model(InterruptModel) UACPIStatus
-@[c_extern]
-fn C.uacpi_status_to_string(UACPIStatus) charptr
-
-@[export: 'uacpi_kernel_log']
-pub fn uacpi_kernel_log(level int, str charptr) {
-	kprint.kwrite(str, stubs.strlen(str))
-}
-
-@[export: 'uacpi_kernel_get_rsdp']
-pub fn uacpi_kernel_get_rsdp(phys &u64) UACPIStatus {
-	unsafe {
-		*phys = u64(rsdp) - higher_half
-	}
-	return UACPIStatus.ok
-}
-
-@[export: 'uacpi_kernel_create_spinlock']
-pub fn uacpi_kernel_create_spinlock() voidptr {
-	mut l := &klock.Lock{}
-	return unsafe { voidptr(l) }
-}
-
-@[export: 'uacpi_kernel_free_spinlock']
-pub fn uacpi_kernel_free_spinlock(handle voidptr) {
-	mut l := unsafe { &klock.Lock(handle) }
-	unsafe {
-		l.free()
-		free(l)
-	}
-}
-
-@[export: 'uacpi_kernel_lock_spinlock']
-pub fn uacpi_kernel_lock_spinlock(handle voidptr) u64 {
-	mut l := unsafe { &klock.Lock(handle) }
-	l.acquire()
-	return 0
-}
-
-@[export: 'uacpi_kernel_unlock_spinlock']
-pub fn uacpi_kernel_unlock_spinlock(handle voidptr, cpu_flags u64) {
-	mut l := unsafe { &klock.Lock(handle) }
-	l.release()
-}
-
-@[export: 'uacpi_kernel_acquire_mutex']
-pub fn uacpi_kernel_acquire_mutex(handle voidptr, timeout u16) UACPIStatus {
-	return UACPIStatus.ok
-}
-
-@[export: 'uacpi_kernel_release_mutex']
-pub fn uacpi_kernel_release_mutex(handle voidptr) {
-}
-
-@[export: 'uacpi_kernel_create_mutex']
-pub fn uacpi_kernel_create_mutex() voidptr {
-	return unsafe { malloc(1) }
-}
-
-@[export: 'uacpi_kernel_free_mutex']
-pub fn uacpi_kernel_free_mutex(handle voidptr) {
-	unsafe { free(handle) }
-}
-
-@[export: 'uacpi_kernel_create_event']
-pub fn uacpi_kernel_create_event() voidptr {
-	mut e := &eventstruct.Event{}
-	return unsafe { voidptr(e) }
-}
-
-@[export: 'uacpi_kernel_free_event']
-pub fn uacpi_kernel_free_event(handle voidptr) {
-	mut e := unsafe { &eventstruct.Event(handle) }
-	unsafe {
-		e.free()
-		free(e)
-	}
-}
-
-@[export: 'uacpi_kernel_signal_event']
-pub fn uacpi_kernel_signal_event(handle voidptr) {
-	mut e := unsafe { &eventstruct.Event(handle) }
-	event.trigger(mut e, false)
-}
-
-@[export: 'uacpi_kernel_wait_for_event']
-pub fn uacpi_kernel_wait_for_event(handle voidptr, timeout u16) bool {
-	target_time := time.TimeSpec{
-		tv_sec:  u64(timeout) / 1000
-		tv_nsec: (u64(timeout) % 1000) * 1000000
-	}
-	mut timer := time.new_timer(target_time)
-	defer {
-		timer.disarm()
-		unsafe {
-			timer.free()
-			free(timer)
-		}
-	}
-	mut events := if timeout == 0xffff {
-		[unsafe { &eventstruct.Event(handle) }]
-	} else {
-		[unsafe { &eventstruct.Event(handle) }, &timer.event]
-	}
-	event.await(mut events, true) or { return false }
-	return true
-}
-
-@[export: 'uacpi_kernel_reset_event']
-pub fn uacpi_kernel_reset_event(handle voidptr) {
-}
-
-@[export: 'uacpi_kernel_stall']
-pub fn uacpi_kernel_stall(usec u8) {
-	for i := 0; i < usec; i++ {
-		kio.port_in[u8](0x80)
-	}
-}
-
-@[export: 'uacpi_kernel_sleep']
-pub fn uacpi_kernel_sleep(msec u64) {
-	target_time := time.TimeSpec{
-		tv_sec:  u64(msec) / 1000
-		tv_nsec: (u64(msec) % 1000) * 1000000
-	}
-	mut timer := time.new_timer(target_time)
-	defer {
-		timer.disarm()
-		unsafe {
-			timer.free()
-			free(timer)
-		}
-	}
-	mut events := [&timer.event]
-	event.await(mut events, true) or {}
-}
-
-@[export: 'uacpi_kernel_alloc']
-pub fn uacpi_kernel_alloc(size u64) voidptr {
-	return unsafe { malloc(size) }
-}
-
-@[export: 'uacpi_kernel_free']
-pub fn uacpi_kernel_free(ptr voidptr) {
-	unsafe { free(ptr) }
-}
-
-@[export: 'uacpi_kernel_schedule_work']
-pub fn uacpi_kernel_schedule_work(work_type int, work_handler voidptr, handle voidptr) UACPIStatus {
-	return UACPIStatus.unimplemented
-}
-
-@[export: 'uacpi_kernel_wait_for_work_completion']
-pub fn uacpi_kernel_wait_for_work_completion() UACPIStatus {
-	return UACPIStatus.unimplemented
-}
-
-@[export: 'uacpi_kernel_install_interrupt_handler']
-pub fn uacpi_kernel_install_interrupt_handler(irq u32, interrupt_handler voidptr,
-	ctx voidptr, out_irq_handle &voidptr) UACPIStatus {
-	return UACPIStatus.ok
-}
-
-@[export: 'uacpi_kernel_uninstall_interrupt_handler']
-pub fn uacpi_kernel_uninstall_interrupt_handler(interrupt_handler voidptr, irq_handle voidptr) UACPIStatus {
-	return UACPIStatus.ok
-}
-
-@[export: 'uacpi_kernel_handle_firmware_request']
-pub fn uacpi_kernel_handle_firmware_request(req voidptr) UACPIStatus {
-	return UACPIStatus.unimplemented
-}
-
-@[export: 'uacpi_kernel_map']
-pub fn uacpi_kernel_map(phys u64, len u64) voidptr {
-	aligned_len := lib.align_up(len, page_size)
-
-	for i := u64(0); i < aligned_len; i += page_size {
-		kernel_pagemap.map_page(higher_half + phys + i, phys + i, memory.pte_present | memory.pte_noexec | memory.pte_writable) or {
-			panic('uacpi_kernel_map() failure')
-		}
-	}
-
-	return voidptr(higher_half + phys)
-}
-
-@[export: 'uacpi_kernel_unmap']
-pub fn uacpi_kernel_unmap(addr voidptr, len u64) {
-}
-
-@[export: 'uacpi_kernel_get_nanoseconds_since_boot']
-pub fn uacpi_kernel_get_nanoseconds_since_boot() u64 {
-	return hpet.read_counter() * (1000000000 / hpet_frequency)
-}
-
-@[export: 'uacpi_kernel_io_map']
-pub fn uacpi_kernel_io_map(base u64, len u64, out_handle &voidptr) UACPIStatus {
-	unsafe {
-		*out_handle = voidptr(base)
-	}
-	return UACPIStatus.ok
-}
-
-@[export: 'uacpi_kernel_io_unmap']
-pub fn uacpi_kernel_io_unmap(handle voidptr) {
-}
-
-@[export: 'uacpi_kernel_io_read8']
-pub fn uacpi_kernel_io_read8(handle voidptr, offset u64, out_value &u8) UACPIStatus {
-	unsafe {
-		*out_value = kio.port_in[u8](u16(u64(handle) + offset))
-	}
-	return UACPIStatus.ok
-}
-
-@[export: 'uacpi_kernel_io_read16']
-pub fn uacpi_kernel_io_read16(handle voidptr, offset u64, out_value &u16) UACPIStatus {
-	unsafe {
-		*out_value = kio.port_in[u16](u16(u64(handle) + offset))
-	}
-	return UACPIStatus.ok
-}
-
-@[export: 'uacpi_kernel_io_read32']
-pub fn uacpi_kernel_io_read32(handle voidptr, offset u64, out_value &u32) UACPIStatus {
-	unsafe {
-		*out_value = kio.port_in[u32](u16(u64(handle) + offset))
-	}
-	return UACPIStatus.ok
-}
-
-@[export: 'uacpi_kernel_io_write8']
-pub fn uacpi_kernel_io_write8(handle voidptr, offset u64, value u8) UACPIStatus {
-	kio.port_out[u8](u16(u64(handle) + offset), value)
-	return UACPIStatus.ok
-}
-
-@[export: 'uacpi_kernel_io_write16']
-pub fn uacpi_kernel_io_write16(handle voidptr, offset u64, value u16) UACPIStatus {
-	kio.port_out[u16](u16(u64(handle) + offset), value)
-	return UACPIStatus.ok
-}
-
-@[export: 'uacpi_kernel_io_write32']
-pub fn uacpi_kernel_io_write32(handle voidptr, offset u64, value u32) UACPIStatus {
-	kio.port_out[u32](u16(u64(handle) + offset), value)
-	return UACPIStatus.ok
-}
-
-@[export: 'uacpi_kernel_get_thread_id']
-pub fn uacpi_kernel_get_thread_id() voidptr {
-	return unsafe { nil }
-}
-
-struct UACPIPCIAddress {
-	segment  u16
-	bus      u8
-	device   u8
-	function u8
-}
-
-@[export: 'uacpi_kernel_pci_device_open']
-pub fn uacpi_kernel_pci_device_open(addr UACPIPCIAddress, out_handle &voidptr) UACPIStatus {
-	mut pci_device := pci.get_device_by_coordinates(addr.bus, addr.device, addr.function,
-		0) or { return UACPIStatus.not_found }
-	unsafe {
-		*out_handle = voidptr(pci_device)
-	}
-	return UACPIStatus.ok
-}
-
-@[export: 'uacpi_kernel_pci_device_close']
-pub fn uacpi_kernel_pci_device_close(handle voidptr) {
-}
-
-@[export: 'uacpi_kernel_pci_read8']
-pub fn uacpi_kernel_pci_read8(handle voidptr, offset u64, value &u8) UACPIStatus {
-	mut pci_device := unsafe { &pci.PCIDevice(handle) }
-	unsafe {
-		*value = pci_device.read[u8](u32(offset))
-	}
-	return UACPIStatus.ok
-}
-
-@[export: 'uacpi_kernel_pci_read16']
-pub fn uacpi_kernel_pci_read16(handle voidptr, offset u64, value &u16) UACPIStatus {
-	mut pci_device := unsafe { &pci.PCIDevice(handle) }
-	unsafe {
-		*value = pci_device.read[u16](u32(offset))
-	}
-	return UACPIStatus.ok
-}
-
-@[export: 'uacpi_kernel_pci_read32']
-pub fn uacpi_kernel_pci_read32(handle voidptr, offset u64, value &u32) UACPIStatus {
-	mut pci_device := unsafe { &pci.PCIDevice(handle) }
-	unsafe {
-		*value = pci_device.read[u32](u32(offset))
-	}
-	return UACPIStatus.ok
-}
-
-@[export: 'uacpi_kernel_pci_write8']
-pub fn uacpi_kernel_pci_write8(handle voidptr, offset u64, value u8) UACPIStatus {
-	mut pci_device := unsafe { &pci.PCIDevice(handle) }
-	pci_device.write[u8](u32(offset), value)
-	return UACPIStatus.ok
-}
-
-@[export: 'uacpi_kernel_pci_write16']
-pub fn uacpi_kernel_pci_write16(handle voidptr, offset u64, value u16) UACPIStatus {
-	mut pci_device := unsafe { &pci.PCIDevice(handle) }
-	pci_device.write[u16](u32(offset), value)
-	return UACPIStatus.ok
-}
-
-@[export: 'uacpi_kernel_pci_write32']
-pub fn uacpi_kernel_pci_write32(handle voidptr, offset u64, value u32) UACPIStatus {
-	mut pci_device := unsafe { &pci.PCIDevice(handle) }
-	pci_device.write[u32](u32(offset), value)
-	return UACPIStatus.ok
-}
diff --git a/kernel/modules/userland/signalfd.v b/kernel/modules/userland/signalfd.v
deleted file mode 100644
index 93d79c7..0000000
--- a/kernel/modules/userland/signalfd.v
+++ /dev/null
@@ -1,118 +0,0 @@
-module userland
-
-import stat
-import klock
-import event.eventstruct
-import proc
-import file
-import errno
-
-struct SFDSiginfo {
-	ssi_signo    u32
-	ssi_errno    i32
-	ssi_code     i32
-	ssi_pid      u32
-	ssi_uid      u32
-	ssi_fd       i32
-	ssi_tid      u32
-	ssi_band     u32
-	ssi_overrun  u32
-	ssi_trapno   u32
-	ssi_status   i32
-	ssi_int      i32
-	ssi_ptr      u64
-	ssi_utime    u64
-	ssi_stime    u64
-	ssi_addr     u64
-	ssi_addr_lsb u16
-	pad          [46]u8
-}
-
-struct SignalFD {
-pub mut:
-	stat     stat.Stat
-	refcount int
-	l        klock.Lock
-	status   int
-	can_mmap bool
-	event    eventstruct.Event
-
-	mask  u64
-	queue []&SFDSiginfo
-}
-
-fn (mut this SignalFD) mmap(page u64, flags int) voidptr {
-	panic('')
-}
-
-fn (mut this SignalFD) read(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	return none
-}
-
-fn (mut this SignalFD) write(handle voidptr, buf voidptr, loc u64, count u64) ?i64 {
-	return none
-}
-
-fn (mut this SignalFD) ioctl(handle voidptr, request u64, argp voidptr) ?int {
-	return none
-}
-
-fn (mut this SignalFD) unref(handle voidptr) ? {
-	return none
-}
-
-fn (mut this SignalFD) link(handle voidptr) ? {
-	return none
-}
-
-fn (mut this SignalFD) unlink(handle voidptr) ? {
-	return none
-}
-
-fn (mut this SignalFD) grow(handle voidptr, new_size u64) ? {
-	return none
-}
-
-pub fn syscall_signalfd(_ voidptr, fdnum int, mask u64, flags int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: signalfd(%d, 0x%llx, 0x%x)\n', process.name.str, fdnum,
-		mask, flags)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut signalfd := &SignalFD(unsafe { nil })
-	mut newfd := int(0)
-
-	mut t := proc.current_thread()
-
-	t.signalfds_lock.acquire()
-	defer {
-		t.signalfds_lock.release()
-	}
-
-	if fdnum == -1 {
-		signalfd = &SignalFD{
-			refcount: 1
-		}
-
-		newfd = file.fdnum_create_from_resource(unsafe { nil }, mut signalfd, flags, 0,
-			false) or { return errno.err, errno.get() }
-
-		t.signalfds << voidptr(signalfd)
-	} else {
-		mut fd := file.fd_from_fdnum(unsafe { nil }, fdnum) or { return errno.err, errno.get() }
-
-		signalfd = unsafe { &SignalFD(fd.handle.resource) }
-
-		fd.unref()
-
-		newfd = fdnum
-	}
-
-	signalfd.mask = mask
-
-	return u64(newfd), 0
-}
diff --git a/kernel/modules/userland/userland.v b/kernel/modules/userland/userland.v
deleted file mode 100644
index 8cb9c32..0000000
--- a/kernel/modules/userland/userland.v
+++ /dev/null
@@ -1,736 +0,0 @@
-module userland
-
-import fs
-import memory
-import memory.mmap
-import elf
-import sched
-import file
-import proc
-import x86.cpu.local as cpulocal
-import x86.cpu
-import katomic
-import event
-import event.eventstruct
-import errno
-import lib
-import strings
-import resource
-
-pub const wnohang = 1
-
-pub const sig_block = 1
-
-pub const sig_unblock = 2
-
-pub const sig_setmask = 3
-
-pub const sighup = 1
-
-pub const sigint = 2
-
-pub const sigquit = 3
-
-pub const sigill = 4
-
-pub const sigtrap = 5
-
-pub const sigabrt = 6
-
-pub const sigbus = 7
-
-pub const sigfpe = 8
-
-pub const sigkill = 9
-
-pub const sigusr1 = 10
-
-pub const sigsegv = 11
-
-pub const sigusr2 = 12
-
-pub const sigpipe = 13
-
-pub const sigalrm = 14
-
-pub const sigterm = 15
-
-pub const sigstkflt = 16
-
-pub const sigchld = 17
-
-pub const sigcont = 18
-
-pub const sigstop = 19
-
-pub const sigtstp = 20
-
-pub const sigttin = 21
-
-pub const sigttou = 22
-
-pub const sigurg = 23
-
-pub const sigxcpu = 24
-
-pub const sigxfsz = 25
-
-pub const sigvtalrm = 26
-
-pub const sigprof = 27
-
-pub const sigwinch = 28
-
-pub const sigio = 29
-
-pub const sigpoll = sigio
-
-pub const sigpwr = 30
-
-pub const sigsys = 31
-
-pub const sigrtmin = 32
-
-pub const sigrtmax = 33
-
-pub const sigcancel = 34
-
-pub const sig_err = voidptr(-1)
-
-pub const sig_dfl = voidptr(-2)
-
-pub const sig_ign = voidptr(-3)
-
-pub const sa_nocldstop = 1 << 0
-
-pub const sa_onstack = 1 << 1
-
-pub const sa_resethand = 1 << 2
-
-pub const sa_restart = 1 << 3
-
-pub const sa_siginfo = 1 << 4
-
-pub const sa_nocldwait = 1 << 5
-
-pub const sa_nodefer = 1 << 6
-
-union SigVal {
-	sival_int int
-	sival_ptr voidptr
-}
-
-pub struct SigInfo {
-pub mut:
-	si_signo  int
-	si_code   int
-	si_errno  int
-	si_pid    int
-	si_uid    int
-	si_addr   voidptr
-	si_status int
-	si_value  SigVal
-}
-
-pub fn syscall_getpid(_ voidptr) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: getpid()\n', process.name.str)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut t := unsafe { proc.current_thread() }
-
-	return u64(t.process.pid), 0
-}
-
-pub fn syscall_getppid(_ voidptr) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: getppid()\n', process.name.str)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut t := unsafe { proc.current_thread() }
-
-	return u64(t.process.ppid), 0
-}
-
-pub fn syscall_getgroups(_ voidptr, size int, list &u32) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: getgroups(%d, 0x%llx)\n', process.name.str, size, voidptr(list))
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	return 0, 0
-}
-
-pub fn syscall_sigentry(_ voidptr, sigentry u64) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: sigentry(0x%llx)\n', process.name.str, sigentry)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut t := proc.current_thread()
-
-	t.sigentry = sigentry
-
-	return 0, 0
-}
-
-@[noreturn]
-pub fn syscall_sigreturn(_ voidptr, context &cpulocal.GPRState, old_mask u64) {
-	mut t := unsafe { proc.current_thread() }
-
-	asm volatile amd64 {
-		cli
-	}
-
-	t.gpr_state = *context
-	t.masked_signals = old_mask
-
-	sched.yield(false)
-
-	for {}
-}
-
-pub fn syscall_sigaction(_ voidptr, signum int, act &proc.SigAction, oldact &proc.SigAction) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: sigaction(%d, 0x%llx, 0x%llx)\n', process.name.str, signum,
-		voidptr(act), voidptr(oldact))
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	if signum < 0 || signum > 34 || signum == sigkill || signum == sigstop {
-		return errno.err, errno.einval
-	}
-
-	mut t := proc.current_thread()
-
-	if oldact != unsafe { nil } {
-		unsafe {
-			*oldact = t.sigactions[signum]
-		}
-	}
-
-	if act != unsafe { nil } {
-		t.sigactions[signum] = *act
-	}
-
-	return 0, 0
-}
-
-pub fn syscall_sigprocmask(_ voidptr, how int, set &u64, oldset &u64) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: sigprocmask(%d, 0x%llx, 0x%llx)\n', process.name.str, how,
-		voidptr(set), voidptr(oldset))
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	mut t := proc.current_thread()
-
-	if oldset != unsafe { nil } {
-		unsafe {
-			*oldset = t.masked_signals
-		}
-	}
-
-	if set != unsafe { nil } {
-		match how {
-			sig_block {
-				t.masked_signals |= *set
-			}
-			sig_unblock {
-				t.masked_signals &= ~*set
-			}
-			sig_setmask {
-				t.masked_signals = *set
-			}
-			else {}
-		}
-	}
-
-	return 0, 0
-}
-
-// Dispatch a signal to _self_, this is called from the scheduler, at the
-// end of syscalls, or from exception handlers.
-pub fn dispatch_a_signal(context &cpulocal.GPRState) {
-	mut t := unsafe { proc.current_thread() }
-
-	if t.sigentry == 0 {
-		return
-	}
-
-	mut which := -1
-
-	for i := u8(0); i < 64; i++ {
-		if t.masked_signals & (u64(1) << i) != 0 {
-			continue
-		}
-		if katomic.btr(mut &t.pending_signals, i) == true {
-			which = i
-			break
-		}
-	}
-
-	if which == -1 {
-		return
-	}
-
-	sigaction := t.sigactions[which]
-
-	previous_mask := t.masked_signals
-
-	t.masked_signals |= sigaction.sa_mask
-	if sigaction.sa_flags & sa_nodefer == 0 {
-		t.masked_signals |= u64(1) << which
-	}
-
-	// Respect the redzone
-	t.gpr_state.rsp -= 128
-	t.gpr_state.rsp = lib.align_down(t.gpr_state.rsp, 16)
-
-	// Return context
-	t.gpr_state.rsp -= sizeof(cpulocal.GPRState)
-	t.gpr_state.rsp = lib.align_down(t.gpr_state.rsp, 16)
-	mut return_context := unsafe { &cpulocal.GPRState(t.gpr_state.rsp) }
-
-	unsafe {
-		*return_context = *context
-	}
-	t.gpr_state = *context
-	// Siginfo
-	t.gpr_state.rsp -= sizeof(SigInfo)
-	t.gpr_state.rsp = lib.align_down(t.gpr_state.rsp, 16)
-	mut siginfo := unsafe { &SigInfo(t.gpr_state.rsp) }
-
-	unsafe { C.memset(voidptr(siginfo), 0, sizeof(SigInfo)) }
-	siginfo.si_signo = which
-
-	// Alignment
-	t.gpr_state.rsp -= 8
-
-	// Common handler will take (which, siginfo, sigaction, ret_context, prev_mask)
-	t.gpr_state.rip = t.sigentry
-
-	t.gpr_state.rdi = u64(which)
-	t.gpr_state.rsi = u64(siginfo)
-	t.gpr_state.rdx = u64(sigaction.sa_sigaction)
-	t.gpr_state.rcx = u64(return_context)
-	t.gpr_state.r8 = previous_mask
-
-	sched.yield(false)
-}
-
-pub fn sendsig(_thread &proc.Thread, signal u8) {
-	mut t := unsafe { _thread }
-
-	katomic.bts(mut &t.pending_signals, signal)
-
-	// Try to stop an event_await()
-	sched.enqueue_thread(t, true)
-}
-
-pub fn syscall_kill(_ voidptr, pid int, signal int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: kill(%d, %d)\n', process.name.str, pid, signal)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	if signal > 0 {
-		sendsig(processes[pid].threads[0], u8(signal))
-	} else {
-		panic('sendsig: Values of signal <= 0 not supported')
-	}
-
-	return 0, 0
-}
-
-pub fn syscall_execve(_ voidptr, _path charptr, _argv &charptr, _envp &charptr) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: execve(%s, [omit], [omit])\n', process.name.str, _path)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	path := unsafe { cstring_to_vstring(_path) }
-	mut argv := []string{}
-	for i := 0; true; i++ {
-		unsafe {
-			if _argv[i] == nil {
-				break
-			}
-			argv << cstring_to_vstring(_argv[i])
-		}
-	}
-	mut envp := []string{}
-	for i := 0; true; i++ {
-		unsafe {
-			if _envp[i] == nil {
-				break
-			}
-			envp << cstring_to_vstring(_envp[i])
-		}
-	}
-
-	start_program(true, proc.current_thread().process.current_directory, path, argv, envp,
-		'', '', '') or { return errno.err, errno.get() }
-
-	return errno.err, errno.get()
-}
-
-pub fn syscall_waitpid(_ voidptr, pid int, _status &int, options int) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut current_process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: waitpid(%d, 0x%llx, %d)\n', current_process.name.str, pid,
-		_status, options)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', current_process.name.str)
-	}
-
-	mut status := unsafe { _status }
-
-	mut events := []&eventstruct.Event{}
-	defer {
-		unsafe { events.free() }
-	}
-	mut child := &proc.Process(unsafe { nil })
-
-	if pid == -1 {
-		if current_process.children.len == 0 {
-			return errno.err, errno.echild
-		}
-		for c in current_process.children {
-			events << &c.event
-		}
-	} else if pid < -1 || pid == 0 {
-		print('\nwaitpid: value of pid not supported\n')
-		return errno.err, errno.einval
-	} else {
-		if current_process.children.len == 0 {
-			return errno.err, errno.echild
-		}
-		child = processes[pid]
-		if child == unsafe { nil } || child.ppid != current_process.pid {
-			return errno.err, errno.echild
-		}
-		events << &child.event
-	}
-
-	block := options & wnohang == 0
-	which := event.await(mut events, block) or { return errno.err, errno.eintr }
-
-	if child == unsafe { nil } {
-		child = current_process.children[which]
-	}
-
-	unsafe {
-		*status = child.status
-	}
-	ret := child.pid
-
-	proc.free_pid(ret)
-
-	current_process.children.delete(current_process.children.index(child))
-
-	return u64(ret), 0
-}
-
-@[noreturn]
-pub fn syscall_exit(_ voidptr, status int) {
-	mut current_thread := proc.current_thread()
-	mut current_process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: exit(%d)\n', current_process.name.str, status)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', current_process.name.str)
-	}
-
-	mut old_pagemap := current_process.pagemap
-
-	kernel_pagemap.switch_to()
-	current_thread.process = kernel_process
-
-	// Close all FDs
-	for i := 0; i < proc.max_fds; i++ {
-		if current_process.fds[i] == unsafe { nil } {
-			continue
-		}
-
-		file.fdnum_close(current_process, i, true) or {}
-	}
-
-	// PID 1 inherits children
-	if current_process.pid != 1 {
-		for child in current_process.children {
-			processes[1].children << child
-		}
-	}
-
-	mmap.delete_pagemap(mut old_pagemap) or {}
-
-	katomic.store(mut &current_process.status, int(u32(status) << 8))
-	event.trigger(mut &current_process.event, false)
-
-	sched.dequeue_and_die()
-}
-
-pub fn syscall_fork(gpr_state &cpulocal.GPRState) (u64, u64) {
-	mut current_thread := proc.current_thread()
-	mut process := current_thread.process
-
-	C.printf(c'\n\e[32m%s\e[m: fork()\n', process.name.str)
-	defer {
-		C.printf(c'\e[32m%s\e[m: returning\n', process.name.str)
-	}
-
-	old_thread := proc.current_thread()
-	mut old_process := old_thread.process
-
-	mut new_process := sched.new_process(old_process, unsafe { nil }) or {
-		return errno.err, errno.get()
-	}
-
-	new_process.name = '${old_process.name}[${new_process.pid}]'
-
-	// Dup all FDs
-	for i := 0; i < proc.max_fds; i++ {
-		if old_process.fds[i] == unsafe { nil } {
-			continue
-		}
-
-		file.fdnum_dup(old_process, i, new_process, i, 0, true, false) or { panic('') }
-	}
-
-	stack_size := u64(0x200000)
-
-	mut stacks := []voidptr{}
-
-	kernel_stack_phys := memory.pmm_alloc(stack_size / page_size)
-	stacks << kernel_stack_phys
-	kernel_stack := u64(kernel_stack_phys) + stack_size + higher_half
-
-	pf_stack_phys := memory.pmm_alloc(stack_size / page_size)
-	stacks << pf_stack_phys
-	pf_stack := u64(pf_stack_phys) + stack_size + higher_half
-
-	mut new_thread := &proc.Thread{
-		gpr_state:      gpr_state
-		process:        new_process
-		timeslice:      old_thread.timeslice
-		gs_base:        cpu.get_kernel_gs_base()
-		fs_base:        cpu.get_fs_base()
-		kernel_stack:   kernel_stack
-		pf_stack:       pf_stack
-		running_on:     u64(-1)
-		cr3:            u64(new_process.pagemap.top_level)
-		sigentry:       old_thread.sigentry
-		sigactions:     old_thread.sigactions
-		masked_signals: old_thread.masked_signals
-		stacks:         stacks
-		fpu_storage:    unsafe { malloc(fpu_storage_size) }
-	}
-
-	unsafe { stacks.free() }
-
-	new_thread.self = voidptr(new_thread)
-
-	unsafe { C.memcpy(new_thread.fpu_storage, old_thread.fpu_storage, fpu_storage_size) }
-
-	new_thread.gpr_state.rax = u64(0)
-	new_thread.gpr_state.rdx = u64(0)
-
-	old_process.children << new_process
-	new_process.threads << new_thread
-
-	sched.enqueue_thread(new_thread, false)
-
-	return u64(new_process.pid), u64(0)
-}
-
-pub fn start_program(execve bool, dir &fs.VFSNode, path string, argv []string, envp []string, stdin string, stdout string, stderr string) ?&proc.Process {
-	prog_node := fs.get_node(dir, path, true)?
-	mut prog := prog_node.resource
-
-	mut new_pagemap := memory.new_pagemap()
-
-	// Check for shebang before proceeding as if it was an ELF.
-	mut shebang := [2]char{}
-	prog.read(0, &shebang[0], 0, 2)?
-	if shebang[0] == char(`#`) && shebang[1] == char(`!`) {
-		real_path, arg := parse_shebang(mut prog)?
-		mut final_argv := [real_path]
-		if arg != '' {
-			final_argv << arg
-		}
-		final_argv << path
-		final_argv << argv[1..]
-
-		return start_program(execve, dir, real_path, final_argv, envp, stdin, stdout,
-			stderr)
-	}
-
-	auxval, ld_path := elf.load(new_pagemap, prog, 0) or { return none }
-
-	mut entry_point := unsafe { nil }
-
-	if ld_path == '' {
-		entry_point = voidptr(auxval.at_entry)
-	} else {
-		ld_node := fs.get_node(vfs_root, ld_path, true)?
-		ld := ld_node.resource
-
-		ld_auxval, interp := elf.load(new_pagemap, ld, 0x40000000) or { return none }
-
-		if interp != '' {
-			unsafe { interp.free() }
-		}
-
-		entry_point = voidptr(ld_auxval.at_entry)
-
-		unsafe { ld_path.free() }
-	}
-
-	if execve == false {
-		mut new_process := sched.new_process(unsafe { nil }, new_pagemap)?
-
-		new_process.name = '${path}[${new_process.pid}]'
-
-		stdin_node := fs.get_node(vfs_root, stdin, true)?
-		stdin_handle := &file.Handle{
-			resource: stdin_node.resource
-			node:     stdin_node
-			refcount: 1
-		}
-		stdin_fd := &file.FD{
-			handle: stdin_handle
-		}
-		new_process.fds[0] = voidptr(stdin_fd)
-
-		stdout_node := fs.get_node(vfs_root, stdout, true)?
-		stdout_handle := &file.Handle{
-			resource: stdout_node.resource
-			node:     stdout_node
-			refcount: 1
-		}
-		stdout_fd := &file.FD{
-			handle: stdout_handle
-		}
-		new_process.fds[1] = voidptr(stdout_fd)
-
-		stderr_node := fs.get_node(vfs_root, stderr, true)?
-		stderr_handle := &file.Handle{
-			resource: stderr_node.resource
-			node:     stderr_node
-			refcount: 1
-		}
-		stderr_fd := &file.FD{
-			handle: stderr_handle
-		}
-		new_process.fds[2] = voidptr(stderr_fd)
-
-		sched.new_user_thread(new_process, true, entry_point, unsafe { nil }, 0, argv,
-			envp, auxval, true)?
-
-		return new_process
-	} else {
-		mut t := proc.current_thread()
-		mut process := t.process
-
-		mut old_pagemap := process.pagemap
-
-		process.pagemap = new_pagemap
-
-		process.name = '${path}[${process.pid}]'
-
-		kernel_pagemap.switch_to()
-		t.process = kernel_process
-
-		mmap.delete_pagemap(mut old_pagemap)?
-
-		process.thread_stack_top = u64(0x70000000000)
-		process.mmap_anon_non_fixed_base = u64(0x80000000000)
-
-		// TODO: Kill old threads
-		// old_threads := process.threads
-		process.threads = []&proc.Thread{}
-
-		sched.new_user_thread(process, true, entry_point, unsafe { nil }, 0, argv, envp,
-			auxval, true)?
-
-		unsafe {
-			argv.free()
-			envp.free()
-		}
-		sched.dequeue_and_die()
-	}
-}
-
-pub fn parse_shebang(mut res resource.Resource) ?(string, string) {
-	// Parse the shebang that we already know is there.
-	// Syntax: #![whitespace]interpreter [single arg]new line
-	mut index := u64(2)
-	mut build_path := strings.new_builder(512)
-	mut build_arg := strings.new_builder(512)
-
-	mut c := char(0)
-	res.read(0, &c, index, 1)?
-	if c == char(` `) {
-		index++
-	}
-
-	for {
-		res.read(0, &c, index, 1)?
-		index++
-		if c == char(` `) {
-			break
-		}
-		if c == char(`\n`) {
-			unsafe {
-				goto ret
-			}
-		}
-		build_path.write_rune(rune(c))
-	}
-
-	for {
-		res.read(0, &c, index, 1)?
-		index++
-		if c == char(` `) || c == char(`\n`) {
-			break
-		}
-		build_arg.write_rune(rune(c))
-	}
-
-	ret:
-	final_path := build_path.str()
-	final_arg := build_arg.str()
-	unsafe {
-		build_path.free()
-		build_arg.free()
-	}
-	return final_path, final_arg
-}
diff --git a/kernel/modules/x86/apic/apic.v b/kernel/modules/x86/apic/apic.v
deleted file mode 100644
index c721eca..0000000
--- a/kernel/modules/x86/apic/apic.v
+++ /dev/null
@@ -1,196 +0,0 @@
-@[has_globals]
-module apic
-
-import x86.kio
-import x86.msr
-import x86.cpu.local as cpulocal
-import x86.cpu
-import time
-
-const lapic_reg_icr0 = 0x300
-const lapic_reg_icr1 = 0x310
-const lapic_reg_spurious = 0x0f0
-const lapic_reg_eoi = 0x0b0
-const lapic_reg_timer = 0x320
-const lapic_reg_timer_initcnt = 0x380
-const lapic_reg_timer_curcnt = 0x390
-const lapic_reg_timer_div = 0x3e0
-
-__global (
-	lapic_base  = u64(0)
-	x2apic_mode = bool(false)
-)
-
-fn xapic_read(reg u32) u32 {
-	if lapic_base == u64(0) {
-		lapic_base = u64(msr.rdmsr(0x1b) & 0xfffff000) + higher_half
-	}
-	return kio.mmin(unsafe { &u32(lapic_base + reg) })
-}
-
-fn x2apic_read(reg u32) u64 {
-	return msr.rdmsr(0x800 + (reg >> 4))
-}
-
-fn xapic_write(reg u32, val u32) {
-	if lapic_base == u64(0) {
-		lapic_base = u64(msr.rdmsr(0x1b) & 0xfffff000) + higher_half
-	}
-	kio.mmout(unsafe { &u32(lapic_base + reg) }, val)
-}
-
-fn x2apic_write(reg u32, val u64) {
-	msr.wrmsr(0x800 + (reg >> 4), val)
-}
-
-fn lapic_read(reg u32) u64 {
-	if x2apic_mode {
-		return x2apic_read(reg)
-	} else {
-		return xapic_read(reg)
-	}
-}
-
-fn lapic_write(reg u32, val u64) {
-	if x2apic_mode {
-		x2apic_write(reg, val)
-	} else {
-		xapic_write(reg, u32(val))
-	}
-}
-
-pub fn lapic_timer_stop() {
-	lapic_write(lapic_reg_timer_initcnt, 0)
-	lapic_write(lapic_reg_timer, (1 << 16))
-}
-
-pub fn lapic_timer_calibrate(mut cpu_local cpulocal.Local) {
-	lapic_timer_stop()
-
-	lapic_write(lapic_reg_timer, (1 << 16) | 0xff) // Vector 0xff, masked
-	lapic_write(lapic_reg_timer_div, 0b1011) // Timer divisor = 1
-
-	cpuid_success, _, _, ecx, _ := cpu.cpuid(0x15, 0)
-	if cpuid_success == true && ecx != 0 {
-		cpu_local.lapic_timer_freq = ecx
-		return
-	}
-
-	mut samples := u64(16)
-	for {
-		time.pit_set_reload_value(0xfff0)
-
-		initial_pit_tick := u64(time.pit_get_current_count())
-
-		lapic_write(lapic_reg_timer_initcnt, u32(samples))
-
-		for lapic_read(lapic_reg_timer_curcnt) != 0 {}
-
-		final_pit_tick := u64(time.pit_get_current_count())
-
-		pit_ticks := initial_pit_tick - final_pit_tick
-
-		if pit_ticks < 0x4000 {
-			samples *= 2
-			continue
-		}
-
-		cpu_local.lapic_timer_freq = (samples / pit_ticks) * time.pit_dividend
-
-		break
-	}
-
-	lapic_timer_stop()
-}
-
-pub fn lapic_timer_oneshot(mut cpu_local cpulocal.Local, vec u8, us u64) {
-	lapic_timer_stop()
-
-	ticks := us * (cpu_local.lapic_timer_freq / 1000000)
-
-	lapic_write(lapic_reg_timer, vec)
-	lapic_write(lapic_reg_timer_div, 0b1011)
-	lapic_write(lapic_reg_timer_initcnt, u32(ticks))
-}
-
-pub fn lapic_enable(spurious_vect u8) {
-	lapic_write(lapic_reg_spurious, lapic_read(lapic_reg_spurious) | (1 << 8) | spurious_vect)
-}
-
-pub fn lapic_eoi() {
-	lapic_write(lapic_reg_eoi, 0)
-}
-
-pub fn lapic_send_ipi(lapic_id u32, vector u8) {
-	if x2apic_mode {
-		x2apic_write(lapic_reg_icr0, (u64(lapic_id) << 32) | vector)
-	} else {
-		xapic_write(lapic_reg_icr1, u32(lapic_id) << 24)
-		xapic_write(lapic_reg_icr0, vector)
-	}
-}
-
-fn io_apic_read(io_apic int, reg u32) u32 {
-	base := u64(madt_io_apics[io_apic].address) + higher_half
-	kio.mmout(unsafe { &u32(base) }, reg)
-	return kio.mmin(unsafe { &u32(base + 16) })
-}
-
-fn io_apic_write(io_apic int, reg u32, value u32) {
-	base := u64(madt_io_apics[io_apic].address) + higher_half
-	kio.mmout(unsafe { &u32(base) }, reg)
-	kio.mmout(unsafe { &u32(base + 16) }, value)
-}
-
-fn io_apic_gsi_count(io_apic int) u32 {
-	return (io_apic_read(io_apic, 1) & 0xff0000) >> 16
-}
-
-fn io_apic_from_gsi(gsi u32) int {
-	for i := 0; i < madt_io_apics.len; i++ {
-		if madt_io_apics[i].gsib <= gsi && madt_io_apics[i].gsib + io_apic_gsi_count(i) > gsi {
-			return i
-		}
-	}
-
-	panic('Cannot determine IO APIC from GSI')
-}
-
-pub fn io_apic_set_gsi_redirect(lapic_id u32, vector u8, gsi u32, flags u16, status bool) {
-	io_apic := io_apic_from_gsi(gsi)
-
-	mut redirect := u64(vector)
-
-	if flags & (1 << 1) != 0 {
-		redirect |= (1 << 13)
-	}
-
-	if flags & (1 << 3) != 0 {
-		redirect |= (1 << 15)
-	}
-
-	if status == false {
-		redirect |= (1 << 16)
-	}
-
-	redirect |= u64(lapic_id) << 56
-
-	ioredtbl := (gsi - madt_io_apics[io_apic].gsib) * 2 + 16
-
-	io_apic_write(io_apic, ioredtbl, u32(redirect))
-	io_apic_write(io_apic, ioredtbl + 1, u32(redirect >> 32))
-}
-
-pub fn io_apic_set_irq_redirect(lapic_id u32, vector u8, irq u8, status bool) {
-	for i := 0; i < madt_isos.len; i++ {
-		if madt_isos[i].irq_source == irq {
-			if status {
-				print('apic: IRQ ${irq} using override\n')
-			}
-			io_apic_set_gsi_redirect(lapic_id, vector, madt_isos[i].gsi, madt_isos[i].flags,
-				status)
-			return
-		}
-	}
-	io_apic_set_gsi_redirect(lapic_id, vector, irq, 0, status)
-}
diff --git a/kernel/modules/x86/cpu/cpu.v b/kernel/modules/x86/cpu/cpu.v
deleted file mode 100644
index a84a303..0000000
--- a/kernel/modules/x86/cpu/cpu.v
+++ /dev/null
@@ -1,285 +0,0 @@
-@[has_globals]
-module cpu
-
-import x86.msr
-
-pub fn invlpg(addr u64) {
-	asm volatile amd64 {
-		invlpg [addr]
-		; ; r (addr)
-		; memory
-	}
-}
-
-pub fn interrupt_state() bool {
-	mut f := u64(0)
-	asm volatile amd64 {
-		pushfq
-		pop f
-		; =rm (f)
-	}
-	return f & (1 << 9) != 0
-}
-
-pub fn interrupt_toggle(state bool) bool {
-	ret := interrupt_state()
-	if state == false {
-		asm volatile amd64 {
-			cli
-			; ; ; memory
-		}
-	} else {
-		asm volatile amd64 {
-			sti
-			; ; ; memory
-		}
-	}
-	return ret
-}
-
-pub fn set_kernel_gs_base(ptr u64) {
-	msr.wrmsr(0xc0000102, ptr)
-}
-
-pub fn set_gs_base(ptr u64) {
-	msr.wrmsr(0xc0000101, ptr)
-}
-
-pub fn set_fs_base(ptr u64) {
-	msr.wrmsr(0xc0000100, ptr)
-}
-
-pub fn get_kernel_gs_base() u64 {
-	return msr.rdmsr(0xc0000102)
-}
-
-pub fn get_gs_base() u64 {
-	return msr.rdmsr(0xc0000101)
-}
-
-pub fn get_fs_base() u64 {
-	return msr.rdmsr(0xc0000100)
-}
-
-pub fn syscall_set_fs_base(_ voidptr, base voidptr) (u64, u64) {
-	C.printf(c'\n\e[32m[]\e[m: set_fs_base(0x%llx)\n', base)
-	defer {
-		C.printf(c'\e[32m[]\e[m: returning\n')
-	}
-
-	set_fs_base(u64(base))
-	return 0, 0
-}
-
-pub fn syscall_set_gs_base(_ voidptr, base voidptr) (u64, u64) {
-	C.printf(c'\n\e[32m[]\e[m: set_gs_base(0x%llx)\n', base)
-	defer {
-		C.printf(c'\e[32m[]\e[m: returning\n')
-	}
-
-	set_kernel_gs_base(u64(base))
-	return 0, 0
-}
-
-pub fn read_cr0() u64 {
-	mut ret := u64(0)
-	asm volatile amd64 {
-		mov ret, cr0
-		; =r (ret)
-		; ; memory
-	}
-	return ret
-}
-
-pub fn write_cr0(value u64) {
-	asm volatile amd64 {
-		mov cr0, value
-		; ; r (value)
-		; memory
-	}
-}
-
-pub fn read_cr2() u64 {
-	mut ret := u64(0)
-	asm volatile amd64 {
-		mov ret, cr2
-		; =r (ret)
-		; ; memory
-	}
-	return ret
-}
-
-pub fn write_cr2(value u64) {
-	asm volatile amd64 {
-		mov cr2, value
-		; ; r (value)
-		; memory
-	}
-}
-
-pub fn read_cr3() u64 {
-	mut ret := u64(0)
-	asm volatile amd64 {
-		mov ret, cr3
-		; =r (ret)
-		; ; memory
-	}
-	return ret
-}
-
-pub fn write_cr3(value u64) {
-	asm volatile amd64 {
-		mov cr3, value
-		; ; r (value)
-		; memory
-	}
-}
-
-pub fn read_cr4() u64 {
-	mut ret := u64(0)
-	asm volatile amd64 {
-		mov ret, cr4
-		; =r (ret)
-		; ; memory
-	}
-	return ret
-}
-
-pub fn write_cr4(value u64) {
-	asm volatile amd64 {
-		mov cr4, value
-		; ; r (value)
-		; memory
-	}
-}
-
-pub fn wrxcr(reg u32, value u64) {
-	a := u32(value)
-	d := u32(value >> 32)
-	asm volatile amd64 {
-		xsetbv
-		; ; a (a)
-		  d (d)
-		  c (reg)
-		; memory
-	}
-}
-
-pub fn rdtsc() u64 {
-	mut a := u32(0)
-	mut d := u32(0)
-	asm volatile amd64 {
-		rdtsc
-		; =a (a)
-		  =d (d)
-	}
-
-	return u64(a) | (u64(d) << 32)
-}
-
-pub fn rdrand64() u64 {
-	mut a := u64(0)
-	asm volatile amd64 {
-		rdrand rax
-		; =a (a)
-	}
-
-	return a
-}
-
-pub fn rdrand32() u32 {
-	mut a := u32(0)
-	asm volatile amd64 {
-		rdrand eax
-		; =a (a)
-	}
-
-	return a
-}
-
-pub fn rdseed32() u32 {
-	mut a := u32(0)
-	asm volatile amd64 {
-		rdseed eax
-		; =a (a)
-	}
-
-	return a
-}
-
-fn xsave(region voidptr) {
-	asm volatile amd64 {
-		xsave [region]
-		; ; r (region)
-		  a (0xffffffff)
-		  d (0xffffffff)
-		; memory
-	}
-}
-
-fn xrstor(region voidptr) {
-	asm volatile amd64 {
-		xrstor [region]
-		; ; r (region)
-		  a (0xffffffff)
-		  d (0xffffffff)
-		; memory
-	}
-}
-
-fn fxsave(region voidptr) {
-	asm volatile amd64 {
-		fxsave [region]
-		; ; r (region)
-		; memory
-	}
-}
-
-fn fxrstor(region voidptr) {
-	asm volatile amd64 {
-		fxrstor [region]
-		; ; r (region)
-		; memory
-	}
-}
-
-pub const cpuid_xsave = u32(1 << 26)
-
-pub const cpuid_avx = u32(1 << 28)
-
-pub const cpuid_avx512 = u32(1 << 16)
-
-pub fn cpuid(leaf u32, subleaf u32) (bool, u32, u32, u32, u32) {
-	mut cpuid_max := u32(0)
-	asm volatile amd64 {
-		cpuid
-		; =a (cpuid_max)
-		; a (leaf & 0x80000000)
-		; rbx
-		  rcx
-		  rdx
-	}
-	if leaf > cpuid_max {
-		return false, 0, 0, 0, 0
-	}
-	mut a := u32(0)
-	mut b := u32(0)
-	mut c := u32(0)
-	mut d := u32(0)
-	asm volatile amd64 {
-		cpuid
-		; =a (a)
-		  =b (b)
-		  =c (c)
-		  =d (d)
-		; a (leaf)
-		  c (subleaf)
-	}
-	return true, a, b, c, d
-}
-
-__global (
-	fpu_storage_size u64
-	fpu_save         fn (voidptr)
-	fpu_restore      fn (voidptr)
-)
diff --git a/kernel/modules/x86/cpu/initialisation/initialisation.v b/kernel/modules/x86/cpu/initialisation/initialisation.v
deleted file mode 100644
index 86b3ed6..0000000
--- a/kernel/modules/x86/cpu/initialisation/initialisation.v
+++ /dev/null
@@ -1,141 +0,0 @@
-module initialisation
-
-import x86.gdt
-import x86.idt
-import x86.cpu
-import x86.msr
-import syscall
-import x86.cpu.local as cpulocal
-import limine
-import x86.apic
-import katomic
-import sched
-import memory
-
-pub fn initialise(smp_info &limine.LimineSMPInfo) {
-	mut cpu_local := unsafe { &cpulocal.Local(smp_info.extra_argument) }
-	cpu_number := cpu_local.cpu_number
-
-	cpu_local.lapic_id = smp_info.lapic_id
-
-	gdt.reload()
-	idt.reload()
-
-	gdt.load_tss(voidptr(&cpu_local.tss))
-
-	cpu_local.tss.ist4 = u64(&cpu_local.abort_stack[cpulocal.abort_stack_size - 1])
-
-	kernel_pagemap.switch_to()
-
-	unsafe {
-		stack_size := u64(0x200000)
-
-		common_int_stack_phys := memory.pmm_alloc(stack_size / page_size)
-		mut common_int_stack := &u64(u64(common_int_stack_phys) + stack_size + higher_half)
-		cpu_local.tss.rsp0 = u64(common_int_stack)
-
-		sched_stack_phys := memory.pmm_alloc(stack_size / page_size)
-		mut sched_stack := &u64(u64(sched_stack_phys) + stack_size + higher_half)
-		cpu_local.tss.ist1 = u64(sched_stack)
-	}
-	// Enable syscall
-	mut efer := msr.rdmsr(0xc0000080)
-	efer |= 1
-	msr.wrmsr(0xc0000080, efer)
-	msr.wrmsr(0xc0000081, 0x0033002800000000)
-
-	// Entry address
-	msr.wrmsr(0xc0000082, u64(voidptr(syscall.syscall_entry)))
-
-	// Flags mask
-	msr.wrmsr(0xc0000084, u64(~u32(0x002)))
-
-	// Enable PAT (write-combining/write-protect)
-	mut pat_msr := msr.rdmsr(0x277)
-	pat_msr &= 0xffffffff
-	pat_msr |= u64(0x0105) << 32
-	msr.wrmsr(0x277, pat_msr)
-
-	cpu.set_gs_base(u64(&cpu_local.cpu_number))
-	cpu.set_kernel_gs_base(u64(&cpu_local.cpu_number))
-
-	// Enable SSE/SSE2
-	mut cr0 := cpu.read_cr0()
-	cr0 &= ~(1 << 2)
-	cr0 |= (1 << 1)
-	cpu.write_cr0(cr0)
-
-	mut cr4 := cpu.read_cr4()
-	cr4 |= (3 << 9)
-	cpu.write_cr4(cr4)
-
-	mut success, _, mut b, mut c, _ := cpu.cpuid(1, 0)
-	if success == true && c & cpu.cpuid_xsave != 0 {
-		if cpu_number == 0 {
-			println('fpu: xsave supported')
-		}
-
-		// Enable XSAVE and x{get, set}bv
-		cr4 = cpu.read_cr4()
-		cr4 |= (1 << 18)
-		cpu.write_cr4(cr4)
-
-		mut xcr0 := u64(0)
-		if cpu_number == 0 {
-			println('fpu: Saving x87 state using xsave')
-		}
-		xcr0 |= (1 << 0)
-		if cpu_number == 0 {
-			println('fpu: Saving SSE state using xsave')
-		}
-		xcr0 |= (1 << 1)
-
-		if c & cpu.cpuid_avx != 0 {
-			if cpu_number == 0 {
-				println('fpu: Saving AVX state using xsave')
-			}
-			xcr0 |= (1 << 2)
-		}
-
-		success, _, b, c, _ = cpu.cpuid(7, 0)
-		if success == true && b & cpu.cpuid_avx512 != 0 {
-			if cpu_number == 0 {
-				println('fpu: Saving AVX-512 state using xsave')
-			}
-			xcr0 |= (1 << 5)
-			xcr0 |= (1 << 6)
-			xcr0 |= (1 << 7)
-		}
-
-		cpu.wrxcr(0, xcr0)
-
-		success, _, _, c, _ = cpu.cpuid(0xd, 0)
-		if success == false {
-			panic('CPUID failure')
-		}
-
-		fpu_storage_size = u64(c)
-		fpu_save = cpu.xsave
-		fpu_restore = cpu.xrstor
-	} else {
-		if cpu_number == 0 {
-			println('fpu: Using legacy fxsave')
-		}
-		fpu_storage_size = u64(512)
-		fpu_save = cpu.fxsave
-		fpu_restore = cpu.fxrstor
-	}
-
-	apic.lapic_enable(0xff)
-
-	apic.lapic_timer_calibrate(mut cpu_local)
-
-	print('smp: CPU ${cpu_local.cpu_number} online!\n')
-
-	katomic.inc(mut &cpu_local.online)
-
-	if cpu_number != 0 {
-		for katomic.load(&scheduler_vector) == 0 {}
-		sched.await()
-	}
-}
diff --git a/kernel/modules/x86/cpu/local/local.v b/kernel/modules/x86/cpu/local/local.v
deleted file mode 100644
index 8a8dadd..0000000
--- a/kernel/modules/x86/cpu/local/local.v
+++ /dev/null
@@ -1,84 +0,0 @@
-@[has_globals]
-module local
-
-import x86.cpu
-
-@[packed]
-pub struct TSS {
-pub mut:
-	unused0 u32
-	rsp0    u64
-	rsp1    u64
-	rsp2    u64
-	unused1 u64
-	ist1    u64
-	ist2    u64
-	ist3    u64
-	ist4    u64
-	ist5    u64
-	ist6    u64
-	ist7    u64
-	unused2 u64
-	iopb    u32
-}
-
-pub struct GPRState {
-pub mut:
-	ds     u64
-	es     u64
-	rax    u64
-	rbx    u64
-	rcx    u64
-	rdx    u64
-	rsi    u64
-	rdi    u64
-	rbp    u64
-	r8     u64
-	r9     u64
-	r10    u64
-	r11    u64
-	r12    u64
-	r13    u64
-	r14    u64
-	r15    u64
-	err    u64
-	rip    u64
-	cs     u64
-	rflags u64
-	rsp    u64
-	ss     u64
-}
-
-pub const abort_stack_size = 128
-
-pub struct Local {
-pub mut:
-	cpu_number           u64
-	zero                 u64
-	tss                  TSS
-	lapic_id             u32
-	lapic_timer_freq     u64
-	online               u64
-	is_idle              bool
-	last_run_queue_index int
-	abort_stack          [abort_stack_size]u64
-	aborted              bool
-}
-
-__global (
-	cpu_locals []&Local
-)
-
-pub fn current() &Local {
-	ints := cpu.interrupt_state()
-	if ints != false {
-		panic('Attempted to get current CPU struct without disabling ints')
-	}
-
-	mut cpu_number := u64(0)
-	asm volatile amd64 {
-		mov cpu_number, gs:[0]
-		; =r (cpu_number)
-	}
-	return cpu_locals[cpu_number]
-}
diff --git a/kernel/modules/x86/gdt/gdt.v b/kernel/modules/x86/gdt/gdt.v
deleted file mode 100644
index 23cc243..0000000
--- a/kernel/modules/x86/gdt/gdt.v
+++ /dev/null
@@ -1,182 +0,0 @@
-@[has_globals]
-module gdt
-
-import klock
-
-@[packed]
-struct GDTPointer {
-	size    u16
-	address voidptr
-}
-
-@[packed]
-struct GDTEntry {
-	limit       u16
-	base_low16  u16
-	base_mid8   u8
-	access      u8
-	granularity u8
-	base_high8  u8
-}
-
-__global (
-	kernel_code_seg = u16(0x28)
-	kernel_data_seg = u16(0x30)
-	user_code_seg   = u16(0x43)
-	user_data_seg   = u16(0x3b)
-	tss_segment     = u16(0x48)
-	gdt_pointer     GDTPointer
-	gdt_entries     [11]GDTEntry
-	gdt_lock        klock.Lock
-)
-
-pub fn initialise() {
-	// Initialize all the GDT entries.
-	// Null descriptor.
-	gdt_entries[0] = GDTEntry{
-		limit:       0
-		base_low16:  0
-		base_mid8:   0
-		access:      0
-		granularity: 0
-		base_high8:  0
-	}
-
-	// The following entries allow us to use the Limine terminal
-
-	// Ring 0 16 bit code.
-	gdt_entries[1] = GDTEntry{
-		limit:       0xffff
-		base_low16:  0
-		base_mid8:   0
-		access:      0b10011010
-		granularity: 0b00000000
-		base_high8:  0
-	}
-
-	// Ring 0 16 bit data.
-	gdt_entries[2] = GDTEntry{
-		limit:       0xffff
-		base_low16:  0
-		base_mid8:   0
-		access:      0b10010010
-		granularity: 0b00000000
-		base_high8:  0
-	}
-
-	// Ring 0 32 bit code.
-	gdt_entries[3] = GDTEntry{
-		limit:       0xffff
-		base_low16:  0
-		base_mid8:   0
-		access:      0b10011010
-		granularity: 0b11001111
-		base_high8:  0
-	}
-
-	// Ring 0 32 bit data.
-	gdt_entries[4] = GDTEntry{
-		limit:       0xffff
-		base_low16:  0
-		base_mid8:   0
-		access:      0b10010010
-		granularity: 0b11001111
-		base_high8:  0
-	}
-
-	// Kernel 64 bit code.
-	gdt_entries[5] = GDTEntry{
-		limit:       0
-		base_low16:  0
-		base_mid8:   0
-		access:      0b10011010
-		granularity: 0b00100000
-		base_high8:  0
-	}
-
-	// Kernel 64 bit data.
-	gdt_entries[6] = GDTEntry{
-		limit:       0
-		base_low16:  0
-		base_mid8:   0
-		access:      0b10010010
-		granularity: 0b00000000
-		base_high8:  0
-	}
-
-	// User 64 bit data.
-	gdt_entries[7] = GDTEntry{
-		limit:       0
-		base_low16:  0
-		base_mid8:   0
-		access:      0b11110010
-		granularity: 0
-		base_high8:  0
-	}
-
-	// User 64 bit code.
-	gdt_entries[8] = GDTEntry{
-		limit:       0
-		base_low16:  0
-		base_mid8:   0
-		access:      0b11111010
-		granularity: 0b00100000
-		base_high8:  0
-	}
-
-	reload()
-}
-
-pub fn reload() {
-	gdt_pointer = GDTPointer{
-		size:    u16(sizeof(GDTEntry) * 13 - 1)
-		address: &gdt_entries
-	}
-
-	asm volatile amd64 {
-		lgdt ptr
-		push rax
-		push cseg
-		lea rax, [rip + 0x03]
-		push rax
-		lretq
-		pop rax
-		mov ds, dseg
-		mov es, dseg
-		mov ss, dseg
-		mov fs, udseg
-		mov gs, udseg
-		; ; m (gdt_pointer) as ptr
-		  rm (u64(kernel_code_seg)) as cseg
-		  rm (u32(kernel_data_seg)) as dseg
-		  rm (u32(user_data_seg)) as udseg
-		; memory
-	}
-}
-
-pub fn load_tss(addr voidptr) {
-	gdt_lock.acquire()
-
-	gdt_entries[9] = GDTEntry{
-		limit:       u16(103)
-		base_low16:  u16(u64(addr))
-		base_mid8:   u8(u64(addr) >> 16)
-		base_high8:  u8(u64(addr) >> 24)
-		access:      0b10001001
-		granularity: 0b00000000
-	}
-
-	// High part of the GDT TSS entry, high 32 bits of base
-	gdt_entries[10] = GDTEntry{
-		limit:      u16(u64(addr) >> 32)
-		base_low16: u16(u64(addr) >> 48)
-	}
-
-	asm volatile amd64 {
-		ltr offset
-		; ; rm (tss_segment) as offset
-		; memory
-	}
-
-	gdt_lock.release()
-}
diff --git a/kernel/modules/x86/hpet/hpet.v b/kernel/modules/x86/hpet/hpet.v
deleted file mode 100644
index 19bd30b..0000000
--- a/kernel/modules/x86/hpet/hpet.v
+++ /dev/null
@@ -1,67 +0,0 @@
-@[has_globals]
-module hpet
-
-import acpi
-import x86.kio
-
-@[packed]
-pub struct HPETTable {
-pub mut:
-	header acpi.SDT
-
-	hardware_rev_id     u8
-	misc_bits           u8
-	pci_vendor_id       u16
-	address_space_id    u8
-	register_bit_width  u8
-	register_bit_offset u8
-	reserved1           u8
-	address             u64
-	hpet_number         u8
-	minimum_tick        u16
-	page_protection     u8
-}
-
-pub struct HPET {
-pub mut:
-	general_capabilities  u64
-	unused0               u64
-	general_configuration u64
-	unused1               u64
-	general_int_status    u64
-	unused2               u64
-	unused3               [24]u64
-	main_counter_value    u64
-	unused4               u64
-}
-
-__global (
-	hpet           &HPET
-	hpet_frequency u64
-)
-
-pub fn read_counter() u64 {
-	return kio.mmin(&hpet.main_counter_value)
-}
-
-pub fn initialise() {
-	hpet_table := unsafe {
-		&HPETTable(acpi.find_sdt('HPET', 0) or { panic('HPET ACPI table not found') })
-	}
-
-	hpet = unsafe { &HPET(hpet_table.address + higher_half) }
-
-	mut tmp := kio.mmin(&hpet.general_capabilities)
-
-	counter_clk_period := tmp >> 32
-	hpet_frequency = u64(1000000000000000) / counter_clk_period
-
-	println('hpet: Detected frequency of ${hpet_frequency} Hz')
-
-	kio.mmout(&hpet.main_counter_value, 0)
-
-	println('hpet: Enabling')
-	tmp = kio.mmin(&hpet.general_configuration)
-	tmp |= 0b01
-	kio.mmout(&hpet.general_configuration, tmp)
-}
diff --git a/kernel/modules/x86/idt/idt.v b/kernel/modules/x86/idt/idt.v
deleted file mode 100644
index f606634..0000000
--- a/kernel/modules/x86/idt/idt.v
+++ /dev/null
@@ -1,78 +0,0 @@
-@[has_globals]
-module idt
-
-import klock
-
-@[packed]
-struct IDTPointer {
-	size    u16
-	address voidptr
-}
-
-@[packed]
-struct IDTEntry {
-pub mut:
-	offset_low u16
-	selector   u16
-	ist        u8
-	flags      u8
-	offset_mid u16
-	offset_hi  u32
-	reserved   u32
-}
-
-__global (
-	idt_pointer     IDTPointer
-	idt_entries     [256]IDTEntry
-	idt_free_vector = u8(32)
-	idt_lock        klock.Lock
-)
-
-pub fn allocate_vector() u8 {
-	idt_lock.acquire()
-	if idt_free_vector == 0xf0 {
-		panic('IDT exhausted')
-	}
-	ret := idt_free_vector++
-	idt_lock.release()
-	return ret
-}
-
-__global (
-	interrupt_table [256]voidptr
-)
-
-pub fn initialise() {
-	reload()
-}
-
-pub fn reload() {
-	idt_pointer = IDTPointer{
-		size:    u16((sizeof(IDTEntry) * 256) - 1)
-		address: &idt_entries
-	}
-
-	asm volatile amd64 {
-		lidt ptr
-		; ; m (idt_pointer) as ptr
-		; memory
-	}
-}
-
-pub fn set_ist(vector u16, ist u8) {
-	idt_entries[vector].ist = ist
-}
-
-pub fn register_handler(vector u16, handler voidptr, ist u8, flags u8) {
-	address := u64(handler)
-
-	idt_entries[vector] = IDTEntry{
-		offset_low: u16(address)
-		selector:   kernel_code_seg
-		ist:        ist
-		flags:      flags
-		offset_mid: u16(address >> 16)
-		offset_hi:  u32(address >> 32)
-		reserved:   0
-	}
-}
diff --git a/kernel/modules/x86/isr/isr.v b/kernel/modules/x86/isr/isr.v
deleted file mode 100644
index ed9c7e4..0000000
--- a/kernel/modules/x86/isr/isr.v
+++ /dev/null
@@ -1,123 +0,0 @@
-@[has_globals]
-module isr
-
-import x86.idt
-import event
-import event.eventstruct
-import x86.apic
-import x86.cpu.local as cpulocal
-import memory.mmap
-import katomic
-import lib
-import userland
-import proc
-
-__global (
-	int_events [256]eventstruct.Event
-)
-
-fn generic_isr(num u32, _ voidptr) {
-	apic.lapic_eoi()
-	event.trigger(mut int_events[num], false)
-}
-
-const exception_names = [
-	c'Division by 0',
-	c'Debug',
-	c'NMI',
-	c'Breakpoint',
-	c'Overflow',
-	c'Bound range exceeded',
-	c'Invalid opcode',
-	c'Device not available',
-	c'Double fault',
-	c'???',
-	c'Invalid TSS',
-	c'Segment not present',
-	c'Stack-segment fault',
-	c'General protection fault',
-	c'Page fault',
-	c'???',
-	c'x87 exception',
-	c'Alignment check',
-	c'Machine check',
-	c'SIMD exception',
-	c'Virtualisation',
-	c'???',
-	c'???',
-	c'???',
-	c'???',
-	c'???',
-	c'???',
-	c'???',
-	c'???',
-	c'???',
-	c'Security',
-]
-
-fn pf_handler(num u32, gpr_state &cpulocal.GPRState) {
-	mmap.pf_handler(gpr_state) or { exception_handler(num, gpr_state) }
-}
-
-fn abort_handler(num u32, gpr_state &cpulocal.GPRState) {
-	mut aborted := &cpulocal.current().aborted
-	katomic.store(mut aborted, true)
-	for {
-		asm volatile amd64 {
-			hlt
-		}
-	}
-}
-
-fn exception_handler(num u32, gpr_state &cpulocal.GPRState) {
-	if gpr_state.cs == user_code_seg {
-		mut signal := u8(0)
-
-		match num {
-			13, 14 {
-				signal = userland.sigsegv
-			}
-			else {
-				lib.kpanic(gpr_state, exception_names[num])
-			}
-		}
-
-		userland.sendsig(proc.current_thread(), signal)
-		// userland.dispatch_a_signal(gpr_state)
-		userland.syscall_exit(unsafe { nil }, 128 + signal)
-	} else {
-		lib.kpanic(gpr_state, exception_names[num])
-	}
-}
-
-__global (
-	abort_vector = u8(0)
-)
-
-fn C.interrupt_thunks()
-
-pub fn initialise() {
-	thunks := &u64(voidptr(C.interrupt_thunks))
-
-	for i := u16(0); i < 32; i++ {
-		match i {
-			14 { // Page fault
-				unsafe { idt.register_handler(i, voidptr(thunks[i]), 3, 0x8e) }
-				interrupt_table[i] = voidptr(pf_handler)
-			}
-			else {
-				unsafe { idt.register_handler(i, voidptr(thunks[i]), 0, 0x8e) }
-				interrupt_table[i] = voidptr(exception_handler)
-			}
-		}
-	}
-
-	for i := u16(32); i < 256; i++ {
-		unsafe { idt.register_handler(i, voidptr(thunks[i]), 0, 0x8e) }
-		interrupt_table[i] = voidptr(generic_isr)
-	}
-
-	abort_vector = idt.allocate_vector()
-	unsafe { idt.register_handler(abort_vector, voidptr(thunks[abort_vector]), 4, 0x8e) }
-	interrupt_table[abort_vector] = voidptr(abort_handler)
-}
diff --git a/kernel/modules/x86/kio/kio.v b/kernel/modules/x86/kio/kio.v
deleted file mode 100644
index 83aa195..0000000
--- a/kernel/modules/x86/kio/kio.v
+++ /dev/null
@@ -1,41 +0,0 @@
-module kio
-
-pub fn port_in[T](port u16) T {
-	mut ret := T(0)
-	asm volatile amd64 {
-		in ret, port
-		; =a (ret)
-		; Nd (port)
-		; memory
-	}
-	return ret
-}
-
-pub fn port_out[T](port u16, value T) {
-	asm volatile amd64 {
-		out port, value
-		; ; a (value)
-		  Nd (port)
-		; memory
-	}
-}
-
-pub fn mmin[T](addr &T) T {
-	mut ret := T(0)
-	asm volatile amd64 {
-		mov ret, [addr]
-		; =r (ret)
-		; r (addr)
-		; memory
-	}
-	return ret
-}
-
-pub fn mmout[T](addr &T, value T) {
-	asm volatile amd64 {
-		mov [addr], value
-		; ; r (addr)
-		  r (value)
-		; memory
-	}
-}
diff --git a/kernel/modules/x86/msr/msr.v b/kernel/modules/x86/msr/msr.v
deleted file mode 100644
index aad6f3a..0000000
--- a/kernel/modules/x86/msr/msr.v
+++ /dev/null
@@ -1,26 +0,0 @@
-module msr
-
-pub fn rdmsr(msr u32) u64 {
-	mut eax := u32(0)
-	mut edx := u32(0)
-	asm volatile amd64 {
-		rdmsr
-		; =a (eax)
-		  =d (edx)
-		; c (msr)
-		; memory
-	}
-	return (u64(edx) << 32) | eax
-}
-
-pub fn wrmsr(msr u32, value u64) {
-	eax := u32(value)
-	edx := value >> 32
-	asm volatile amd64 {
-		wrmsr
-		; ; a (eax)
-		  d (edx)
-		  c (msr)
-		; memory
-	}
-}
diff --git a/kernel/modules/x86/smp/smp.v b/kernel/modules/x86/smp/smp.v
deleted file mode 100644
index 4822c0b..0000000
--- a/kernel/modules/x86/smp/smp.v
+++ /dev/null
@@ -1,61 +0,0 @@
-@[has_globals]
-module smp
-
-import limine
-import memory
-import katomic
-import x86.cpu.local as cpulocal
-import x86.cpu.initialisation as cpuinit
-
-__global (
-	bsp_lapic_id = u32(0)
-	smp_ready    = false
-)
-
-@[_linker_section: '.requests']
-@[cinit]
-__global (
-	volatile smp_req = limine.LimineSMPRequest{
-		flags:    1 // x2apic allowed
-		response: unsafe { nil }
-	}
-)
-
-pub fn initialise() {
-	if smp_req.response == unsafe { nil } {
-		panic('SMP bootloader response missing')
-	}
-	smp_tag := smp_req.response
-
-	println('smp: BSP LAPIC ID:    ${smp_tag.bsp_lapic_id:x}')
-	println('smp: Total CPU count: ${smp_tag.cpu_count}')
-	println('smp: Using x2APIC:    ${x2apic_mode}')
-
-	smp_info_array := smp_tag.cpus
-
-	bsp_lapic_id = smp_tag.bsp_lapic_id
-
-	for i := u64(0); i < smp_tag.cpu_count; i++ {
-		mut cpu_local := unsafe { &cpulocal.Local(memory.malloc(sizeof(cpulocal.Local))) }
-		cpu_locals << cpu_local
-
-		mut smp_info := unsafe { smp_info_array[i] }
-
-		smp_info.extra_argument = u64(cpu_local)
-
-		cpu_local.cpu_number = i
-
-		if smp_info.lapic_id == smp_tag.bsp_lapic_id {
-			cpuinit.initialise(smp_info)
-			continue
-		}
-
-		smp_info.goto_address = cpuinit.initialise
-
-		for katomic.load(&cpu_local.online) == 0 {}
-	}
-
-	smp_ready = true
-
-	print('smp: All CPUs online!\n')
-}
diff --git a/kernel/v.mod b/kernel/v.mod
deleted file mode 100644
index 88b910e..0000000
--- a/kernel/v.mod
+++ /dev/null
@@ -1,7 +0,0 @@
-Module {
-	name: 'Vinix'
-	description: 'An operating system written in the V programming language'
-	version: '0.0.0'
-	license: 'GPL-2.0'
-	dependencies: []
-}
diff --git a/patches/binutils/jinx-working-patch.patch b/patches/binutils/jinx-working-patch.patch
index fab402f..5ab5bf8 100644
--- a/patches/binutils/jinx-working-patch.patch
+++ b/patches/binutils/jinx-working-patch.patch
@@ -5,7 +5,7 @@ diff -urN --no-dereference binutils-clean/bfd/config.bfd binutils-workdir/bfd/co
      targ_selvecs=
      targ64_selvecs=x86_64_elf64_vec
      ;;
-+  i[3-7]86-*-vinix*)
++  i[3-7]86-*-willowos*)
 +    targ_defvec=i386_elf32_vec
 +    targ_selvecs=
 +    targ64_selvecs=x86_64_elf64_vec
@@ -17,7 +17,7 @@ diff -urN --no-dereference binutils-clean/bfd/config.bfd binutils-workdir/bfd/co
      targ_selvecs="i386_elf32_vec iamcu_elf32_vec x86_64_elf32_vec"
      want64=true
      ;;
-+  x86_64-*-vinix*)
++  x86_64-*-willowos*)
 +    targ_defvec=x86_64_elf64_vec
 +    targ_selvecs=i386_elf32_vec
 +    want64=true
@@ -44,7 +44,7 @@ diff -urN --no-dereference binutils-clean/gas/configure.tgt binutils-workdir/gas
    i386-*-beos*)				fmt=elf ;;
    i386-*-elfiamcu)			fmt=elf arch=iamcu ;;
    i386-*-elf*)				fmt=elf ;;
-+  i386-*-vinix*)				fmt=elf em=gnu ;;
++  i386-*-willowos*)				fmt=elf em=gnu ;;
    i386-*-fuchsia*)			fmt=elf ;;
    i386-*-haiku*)			fmt=elf em=haiku ;;
    i386-*-genode*)			fmt=elf ;;
@@ -55,7 +55,7 @@ diff -urN --no-dereference binutils-clean/ld/configure.tgt binutils-workdir/ld/c
  i[3-7]86-*-redox*)	targ_emul=elf_i386
  			targ_extra_emuls=elf_x86_64
  			;;
-+i[3-7]86-*-vinix*)	targ_emul=elf_i386
++i[3-7]86-*-willowos*)	targ_emul=elf_i386
 +			targ_extra_emuls=elf_x86_64
 +			;;
  i[3-7]86-*-solaris2*)	targ_emul=elf_i386_sol2
@@ -65,7 +65,7 @@ diff -urN --no-dereference binutils-clean/ld/configure.tgt binutils-workdir/ld/c
  x86_64-*-redox*)	targ_emul=elf_x86_64
  			targ_extra_emuls=elf_i386
  			;;
-+x86_64-*-vinix*)	targ_emul=elf_x86_64
++x86_64-*-willowos*)	targ_emul=elf_x86_64
 +			targ_extra_emuls=elf_i386
 +			;;
  x86_64-*-solaris2*)	targ_emul=elf_x86_64_sol2
diff --git a/patches/gcc-host/jinx-working-patch.patch b/patches/gcc-host/jinx-working-patch.patch
index 57e01ee..c46bd25 100644
--- a/patches/gcc-host/jinx-working-patch.patch
+++ b/patches/gcc-host/jinx-working-patch.patch
@@ -9,12 +9,12 @@ diff -urN --no-dereference gcc-host-clean/fixincludes/mkfixinc.sh gcc-host-workd
      *-mingw32* | \
      powerpc-*-eabisim* | \
      powerpc-*-eabi*    | \
-diff -urN --no-dereference gcc-host-clean/gcc/config/vinix.h gcc-host-workdir/gcc/config/vinix.h
---- gcc-host-clean/gcc/config/vinix.h	1970-01-01 01:00:00.000000000 +0100
-+++ gcc-host-workdir/gcc/config/vinix.h
+diff -urN --no-dereference gcc-host-clean/gcc/config/willowos.h gcc-host-workdir/gcc/config/willowos.h
+--- gcc-host-clean/gcc/config/willowos.h	1970-01-01 01:00:00.000000000 +0100
++++ gcc-host-workdir/gcc/config/willowos.h
 @@ -0,0 +1,30 @@
-+#undef TARGET_VINIX
-+#define TARGET_VINIX 1
++#undef TARGET_willowos
++#define TARGET_willowos 1
 +
 +#undef LIB_SPEC
 +#define LIB_SPEC "-lc"
@@ -36,10 +36,10 @@ diff -urN --no-dereference gcc-host-clean/gcc/config/vinix.h gcc-host-workdir/gc
 +#undef TARGET_OS_CPP_BUILTINS
 +#define TARGET_OS_CPP_BUILTINS()         \
 +  do {                                   \
-+    builtin_define ("__vinix__");    \
++    builtin_define ("__willowos__");    \
 +    builtin_define ("__mlibc__");         \
 +    builtin_define ("__unix__");         \
-+    builtin_assert ("system=vinix"); \
++    builtin_assert ("system=willowos"); \
 +    builtin_assert ("system=unix");      \
 +    builtin_assert ("system=posix");     \
 +  } while (0);
@@ -78,8 +78,8 @@ diff -urN --no-dereference gcc-host-clean/gcc/config.gcc gcc-host-workdir/gcc/co
  			;;
  	esac
  	;;
-+x86_64-*-vinix*)
-+	tm_file="${tm_file} i386/unix.h i386/att.h elfos.h gnu-user.h glibc-stdint.h i386/x86-64.h i386/gnu-user-common.h i386/gnu-user64.h vinix.h"
++x86_64-*-willowos*)
++	tm_file="${tm_file} i386/unix.h i386/att.h elfos.h gnu-user.h glibc-stdint.h i386/x86-64.h i386/gnu-user-common.h i386/gnu-user64.h willowos.h"
 +	;;
  x86_64-*-fuchsia*)
  	tmake_file="${tmake_file} i386/t-x86_64-elf"
@@ -91,7 +91,7 @@ diff -urN --no-dereference gcc-host-clean/gcc/cp/module.cc gcc-host-workdir/gcc/
  	      set_error (errno);
  	  else
  	    {
-+#ifndef __vinix__
++#ifndef __willowos__
  	      if (madvise (mapping, hdr.pos, MADV_RANDOM))
  		goto fail;
 +#endif
@@ -102,7 +102,7 @@ diff -urN --no-dereference gcc-host-clean/gcc/cp/module.cc gcc-host-workdir/gcc/
      }
    /* We'll be hopping over this randomly.  Some systems declare the
       first parm as char *, and other declare it as void *.  */
-+#ifndef __vinix__
++#ifndef __willowos__
    if (madvise (reinterpret_cast <char *> (mapping), size, MADV_RANDOM))
      goto fail;
 +#endif
diff --git a/patches/git/jinx-working-patch.patch b/patches/git/jinx-working-patch.patch
index 9908372..9d7abe8 100644
--- a/patches/git/jinx-working-patch.patch
+++ b/patches/git/jinx-working-patch.patch
@@ -11,9 +11,9 @@ diff -urN --no-dereference git-clean/config.mak.uname git-workdir/config.mak.una
 -uname_R := $(shell sh -c 'uname -r 2>/dev/null || echo not')
 -uname_P := $(shell sh -c 'uname -p 2>/dev/null || echo not')
 -uname_V := $(shell sh -c 'uname -v 2>/dev/null || echo not')
-+uname_S := Vinix
++uname_S := willowos
 +uname_M := x86_64
-+uname_O := Vinix
++uname_O := willowos
 +uname_R := 0.0.0
 +uname_P := unknown
 +uname_V := 0.0.0
diff --git a/patches/glib/jinx-working-patch.patch b/patches/glib/jinx-working-patch.patch
index 63f439b..e9b4014 100644
--- a/patches/glib/jinx-working-patch.patch
+++ b/patches/glib/jinx-working-patch.patch
@@ -6,7 +6,7 @@ diff -urN --no-dereference glib-clean/gio/gcredentialsprivate.h glib-workdir/gio
  #undef G_CREDENTIALS_HAS_PID
  
 -#ifdef __linux__
-+#if defined(__linux__) || defined(__vinix__)
++#if defined(__linux__) || defined(__willowos__)
  #define G_CREDENTIALS_SUPPORTED 1
  #define G_CREDENTIALS_USE_LINUX_UCRED 1
  #define G_CREDENTIALS_NATIVE_TYPE G_CREDENTIALS_TYPE_LINUX_UCRED
diff --git a/patches/llvm/jinx-working-patch.patch b/patches/llvm/jinx-working-patch.patch
index 794329b..1a3cb2d 100644
--- a/patches/llvm/jinx-working-patch.patch
+++ b/patches/llvm/jinx-working-patch.patch
@@ -5,14 +5,14 @@ diff -urN --no-dereference llvm-clean/clang/lib/Basic/Targets/OSTargets.h llvm-w
    }
  };
  
-+// Vinix Target
++// willowos Target
 +template <typename Target>
-+class LLVM_LIBRARY_VISIBILITY VinixTargetInfo : public OSTargetInfo<Target> {
++class LLVM_LIBRARY_VISIBILITY willowosTargetInfo : public OSTargetInfo<Target> {
 +protected:
 +  void getOSDefines(const LangOptions &Opts, const llvm::Triple &Triple,
 +                    MacroBuilder &Builder) const override {
 +    DefineStd(Builder, "unix", Opts);
-+    Builder.defineMacro("__vinix__");
++    Builder.defineMacro("__willowos__");
 +    if (Opts.POSIXThreads)
 +      Builder.defineMacro("_REENTRANT");
 +    if (Opts.CPlusPlus)
@@ -22,7 +22,7 @@ diff -urN --no-dereference llvm-clean/clang/lib/Basic/Targets/OSTargets.h llvm-w
 +  }
 +
 +public:
-+  VinixTargetInfo(const llvm::Triple &Triple, const TargetOptions &Opts)
++  willowosTargetInfo(const llvm::Triple &Triple, const TargetOptions &Opts)
 +      : OSTargetInfo<Target>(Triple, Opts) {
 +    switch (Triple.getArch()) {
 +    default:
@@ -45,8 +45,8 @@ diff -urN --no-dereference llvm-clean/clang/lib/Basic/Targets.cpp llvm-workdir/c
          return std::make_unique<OHOSTargetInfo<AArch64leTargetInfo>>(Triple,
                                                                       Opts);
        }
-+    case llvm::Triple::Vinix:
-+      return std::make_unique<VinixTargetInfo<AArch64leTargetInfo>>(Triple,
++    case llvm::Triple::willowos:
++      return std::make_unique<willowosTargetInfo<AArch64leTargetInfo>>(Triple,
 +                                                                       Opts);
      case llvm::Triple::NetBSD:
        return std::make_unique<NetBSDTargetInfo<AArch64leTargetInfo>>(Triple,
@@ -55,8 +55,8 @@ diff -urN --no-dereference llvm-clean/clang/lib/Basic/Targets.cpp llvm-workdir/c
          return std::make_unique<OHOSTargetInfo<RISCV64TargetInfo>>(Triple,
                                                                     Opts);
        }
-+    case llvm::Triple::Vinix:
-+      return std::make_unique<VinixTargetInfo<RISCV64TargetInfo>>(Triple,
++    case llvm::Triple::willowos:
++      return std::make_unique<willowosTargetInfo<RISCV64TargetInfo>>(Triple,
 +                                                                     Opts);
      default:
        return std::make_unique<RISCV64TargetInfo>(Triple, Opts);
@@ -65,8 +65,8 @@ diff -urN --no-dereference llvm-clean/clang/lib/Basic/Targets.cpp llvm-workdir/c
        return std::make_unique<PS5OSTargetInfo<X86_64TargetInfo>>(Triple, Opts);
      case llvm::Triple::Hurd:
        return std::make_unique<HurdTargetInfo<X86_64TargetInfo>>(Triple, Opts);
-+    case llvm::Triple::Vinix:
-+      return std::make_unique<VinixTargetInfo<X86_64TargetInfo>>(Triple,
++    case llvm::Triple::willowos:
++      return std::make_unique<willowosTargetInfo<X86_64TargetInfo>>(Triple,
 +                                                                    Opts);
      default:
        return std::make_unique<X86_64TargetInfo>(Triple, Opts);
@@ -78,7 +78,7 @@ diff -urN --no-dereference llvm-clean/clang/lib/Driver/CMakeLists.txt llvm-workd
    ToolChains/HLSL.cpp
    ToolChains/Hurd.cpp
    ToolChains/Linux.cpp
-+  ToolChains/Vinix.cpp
++  ToolChains/willowos.cpp
    ToolChains/MipsLinux.cpp
    ToolChains/MinGW.cpp
    ToolChains/MSP430.cpp
@@ -89,7 +89,7 @@ diff -urN --no-dereference llvm-clean/clang/lib/Driver/Driver.cpp llvm-workdir/c
  #include "ToolChains/Linux.h"
  #include "ToolChains/MSP430.h"
  #include "ToolChains/MSVC.h"
-+#include "ToolChains/Vinix.h"
++#include "ToolChains/willowos.h"
  #include "ToolChains/MinGW.h"
  #include "ToolChains/MipsLinux.h"
  #include "ToolChains/NaCl.h"
@@ -97,8 +97,8 @@ diff -urN --no-dereference llvm-clean/clang/lib/Driver/Driver.cpp llvm-workdir/c
      case llvm::Triple::Fuchsia:
        TC = std::make_unique<toolchains::Fuchsia>(*this, Target, Args);
        break;
-+    case llvm::Triple::Vinix:
-+      TC = std::make_unique<toolchains::Vinix>(*this, Target, Args);
++    case llvm::Triple::willowos:
++      TC = std::make_unique<toolchains::willowos>(*this, Target, Args);
 +      break;
      case llvm::Triple::Solaris:
        TC = std::make_unique<toolchains::Solaris>(*this, Target, Args);
@@ -110,16 +110,16 @@ diff -urN --no-dereference llvm-clean/clang/lib/Driver/ToolChains/Gnu.cpp llvm-w
        return "elf_iamcu";
      return "elf_i386";
    case llvm::Triple::aarch64:
-+    if (T.isOSVinix())
-+      return "aarch64vinix";
++    if (T.isOSwillowos())
++      return "aarch64willowos";
      return "aarch64linux";
    case llvm::Triple::aarch64_be:
      return "aarch64linuxb";
-diff -urN --no-dereference llvm-clean/clang/lib/Driver/ToolChains/Vinix.cpp llvm-workdir/clang/lib/Driver/ToolChains/Vinix.cpp
---- llvm-clean/clang/lib/Driver/ToolChains/Vinix.cpp	1970-01-01 01:00:00.000000000 +0100
-+++ llvm-workdir/clang/lib/Driver/ToolChains/Vinix.cpp
+diff -urN --no-dereference llvm-clean/clang/lib/Driver/ToolChains/willowos.cpp llvm-workdir/clang/lib/Driver/ToolChains/willowos.cpp
+--- llvm-clean/clang/lib/Driver/ToolChains/willowos.cpp	1970-01-01 01:00:00.000000000 +0100
++++ llvm-workdir/clang/lib/Driver/ToolChains/willowos.cpp
 @@ -0,0 +1,227 @@
-+//===--- Vinix.h - Vinix ToolChain Implementations --------*- C++ -*-===//
++//===--- willowos.h - willowos ToolChain Implementations --------*- C++ -*-===//
 +//
 +//                     The LLVM Compiler Infrastructure
 +//
@@ -128,7 +128,7 @@ diff -urN --no-dereference llvm-clean/clang/lib/Driver/ToolChains/Vinix.cpp llvm
 +//
 +//===----------------------------------------------------------------------===//
 +
-+#include "Vinix.h"
++#include "willowos.h"
 +#include "Arch/ARM.h"
 +#include "Arch/RISCV.h"
 +#include "CommonArgs.h"
@@ -146,7 +146,7 @@ diff -urN --no-dereference llvm-clean/clang/lib/Driver/ToolChains/Vinix.cpp llvm
 +
 +using tools::addPathIfExists;
 +
-+std::string Vinix::getMultiarchTriple(const Driver &D,
++std::string willowos::getMultiarchTriple(const Driver &D,
 +                                         const llvm::Triple &TargetTriple,
 +                                         StringRef SysRoot) const {
 +  // For most architectures, just use whatever we have rather than trying to be
@@ -157,11 +157,11 @@ diff -urN --no-dereference llvm-clean/clang/lib/Driver/ToolChains/Vinix.cpp llvm
 +
 +  case llvm::Triple::x86_64:
 +    // We don't want this for x32, otherwise it will match x86_64 libs
-+    return "x86_64-vinix-" + TargetTriple.getEnvironmentName().str();
++    return "x86_64-willowos-" + TargetTriple.getEnvironmentName().str();
 +  case llvm::Triple::aarch64:
-+    return "aarch64-vinix-" + TargetTriple.getEnvironmentName().str();
++    return "aarch64-willowos-" + TargetTriple.getEnvironmentName().str();
 +  case llvm::Triple::riscv64:
-+    return "riscv64-vinix-" + TargetTriple.getEnvironmentName().str();
++    return "riscv64-willowos-" + TargetTriple.getEnvironmentName().str();
 +  }
 +  return TargetTriple.str();
 +}
@@ -189,7 +189,7 @@ diff -urN --no-dereference llvm-clean/clang/lib/Driver/ToolChains/Vinix.cpp llvm
 +  return Triple.isArch32Bit() ? "lib" : "lib64";
 +}
 +
-+Vinix::Vinix(const Driver &D, const llvm::Triple &Triple,
++willowos::willowos(const Driver &D, const llvm::Triple &Triple,
 +                   const ArgList &Args)
 +    : Generic_ELF(D, Triple, Args) {
 +  GCCInstallation.init(Triple, Args);
@@ -228,23 +228,23 @@ diff -urN --no-dereference llvm-clean/clang/lib/Driver/ToolChains/Vinix.cpp llvm
 +  addPathIfExists(D, SysRoot + "/usr/lib", Paths);
 +}
 +
-+bool Vinix::HasNativeLLVMSupport() const { return true; }
++bool willowos::HasNativeLLVMSupport() const { return true; }
 +
-+Tool *Vinix::buildLinker() const {
++Tool *willowos::buildLinker() const {
 +  return new tools::gnutools::Linker(*this);
 +}
 +
-+Tool *Vinix::buildAssembler() const {
++Tool *willowos::buildAssembler() const {
 +  return new tools::gnutools::Assembler(*this);
 +}
 +
-+std::string Vinix::computeSysRoot() const {
++std::string willowos::computeSysRoot() const {
 +  if (!getDriver().SysRoot.empty())
 +    return getDriver().SysRoot;
 +  return std::string();
 +}
 +
-+std::string Vinix::getDynamicLinker(const ArgList &Args) const {
++std::string willowos::getDynamicLinker(const ArgList &Args) const {
 +  switch (getTriple().getArch()) {
 +  case llvm::Triple::aarch64:
 +    return "/usr/lib/ld.so";
@@ -259,7 +259,7 @@ diff -urN --no-dereference llvm-clean/clang/lib/Driver/ToolChains/Vinix.cpp llvm
 +  }
 +}
 +
-+void Vinix::AddClangSystemIncludeArgs(const ArgList &DriverArgs,
++void willowos::AddClangSystemIncludeArgs(const ArgList &DriverArgs,
 +                                         ArgStringList &CC1Args) const {
 +  const Driver &D = getDriver();
 +  std::string SysRoot = computeSysRoot();
@@ -313,10 +313,10 @@ diff -urN --no-dereference llvm-clean/clang/lib/Driver/ToolChains/Vinix.cpp llvm
 +  addExternCSystemInclude(DriverArgs, CC1Args, concat(SysRoot, "/usr/include"));
 +}
 +
-+void Vinix::addLibStdCxxIncludePaths(
++void willowos::addLibStdCxxIncludePaths(
 +    const llvm::opt::ArgList &DriverArgs,
 +    llvm::opt::ArgStringList &CC1Args) const {
-+  // We need a detected GCC installation on Vinix to provide libstdc++'s
++  // We need a detected GCC installation on willowos to provide libstdc++'s
 +  // headers.
 +  if (!GCCInstallation.isValid())
 +    return;
@@ -327,7 +327,7 @@ diff -urN --no-dereference llvm-clean/clang/lib/Driver/ToolChains/Vinix.cpp llvm
 +  Generic_GCC::addGCCLibStdCxxIncludePaths(DriverArgs, CC1Args, TripleStr);
 +}
 +
-+SanitizerMask Vinix::getSupportedSanitizers() const {
++SanitizerMask willowos::getSupportedSanitizers() const {
 +  const bool IsX86 = getTriple().getArch() == llvm::Triple::x86;
 +  const bool IsX86_64 = getTriple().getArch() == llvm::Triple::x86_64;
 +  SanitizerMask Res = ToolChain::getSupportedSanitizers();
@@ -342,15 +342,15 @@ diff -urN --no-dereference llvm-clean/clang/lib/Driver/ToolChains/Vinix.cpp llvm
 +  return Res;
 +}
 +
-+void Vinix::addExtraOpts(llvm::opt::ArgStringList &CmdArgs) const {
++void willowos::addExtraOpts(llvm::opt::ArgStringList &CmdArgs) const {
 +  for (const auto &Opt : ExtraOpts)
 +    CmdArgs.push_back(Opt.c_str());
 +}
-diff -urN --no-dereference llvm-clean/clang/lib/Driver/ToolChains/Vinix.h llvm-workdir/clang/lib/Driver/ToolChains/Vinix.h
---- llvm-clean/clang/lib/Driver/ToolChains/Vinix.h	1970-01-01 01:00:00.000000000 +0100
-+++ llvm-workdir/clang/lib/Driver/ToolChains/Vinix.h
+diff -urN --no-dereference llvm-clean/clang/lib/Driver/ToolChains/willowos.h llvm-workdir/clang/lib/Driver/ToolChains/willowos.h
+--- llvm-clean/clang/lib/Driver/ToolChains/willowos.h	1970-01-01 01:00:00.000000000 +0100
++++ llvm-workdir/clang/lib/Driver/ToolChains/willowos.h
 @@ -0,0 +1,55 @@
-+//===--- Vinix.h - Vinix ToolChain Implementations --------*- C++ -*-===//
++//===--- willowos.h - willowos ToolChain Implementations --------*- C++ -*-===//
 +//
 +//                     The LLVM Compiler Infrastructure
 +//
@@ -359,8 +359,8 @@ diff -urN --no-dereference llvm-clean/clang/lib/Driver/ToolChains/Vinix.h llvm-w
 +//
 +//===----------------------------------------------------------------------===//
 +
-+#ifndef LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_VINIX_H
-+#define LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_VINIX_H
++#ifndef LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_willowos_H
++#define LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_willowos_H
 +
 +#include "Gnu.h"
 +#include "clang/Driver/ToolChain.h"
@@ -369,9 +369,9 @@ diff -urN --no-dereference llvm-clean/clang/lib/Driver/ToolChains/Vinix.h llvm-w
 +namespace driver {
 +namespace toolchains {
 +
-+class LLVM_LIBRARY_VISIBILITY Vinix : public Generic_ELF {
++class LLVM_LIBRARY_VISIBILITY willowos : public Generic_ELF {
 +public:
-+  Vinix(const Driver &D, const llvm::Triple &Triple,
++  willowos(const Driver &D, const llvm::Triple &Triple,
 +           const llvm::opt::ArgList &Args);
 +
 +  bool HasNativeLLVMSupport() const override;
@@ -404,7 +404,7 @@ diff -urN --no-dereference llvm-clean/clang/lib/Driver/ToolChains/Vinix.h llvm-w
 +} // end namespace driver
 +} // end namespace clang
 +
-+#endif // LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_VINIX_H
++#endif // LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_willowos_H
 diff -urN --no-dereference llvm-clean/llvm/include/llvm/ADT/bit.h llvm-workdir/llvm/include/llvm/ADT/bit.h
 --- llvm-clean/llvm/include/llvm/ADT/bit.h
 +++ llvm-workdir/llvm/include/llvm/ADT/bit.h
@@ -413,7 +413,7 @@ diff -urN --no-dereference llvm-clean/llvm/include/llvm/ADT/bit.h llvm-workdir/l
  #if defined(__linux__) || defined(__GNU__) || defined(__HAIKU__) ||            \
      defined(__Fuchsia__) || defined(__EMSCRIPTEN__) || defined(__NetBSD__) ||  \
 -    defined(__OpenBSD__) || defined(__DragonFly__)
-+    defined(__OpenBSD__) || defined(__DragonFly__) || defined(__vinix__)
++    defined(__OpenBSD__) || defined(__DragonFly__) || defined(__willowos__)
  #include <endian.h>
  #elif defined(_AIX)
  #include <sys/machine.h>
@@ -424,7 +424,7 @@ diff -urN --no-dereference llvm-clean/llvm/include/llvm/TargetParser/Triple.h ll
      Linux,
      Lv2, // PS3
      MacOSX,
-+    Vinix,
++    willowos,
      NetBSD,
      OpenBSD,
      Solaris,
@@ -440,7 +440,7 @@ diff -urN --no-dereference llvm-clean/llvm/include/llvm/TargetParser/Triple.h ll
  
    bool isVulkanOS() const { return getOS() == Triple::Vulkan; }
  
-+  bool isOSVinix() const { return getOS() == Triple::Vinix; }
++  bool isOSwillowos() const { return getOS() == Triple::willowos; }
 +
    bool isShaderStageEnvironment() const {
      EnvironmentType Env = getEnvironment();
@@ -453,7 +453,7 @@ diff -urN --no-dereference llvm-clean/llvm/lib/Support/Unix/Path.inc llvm-workdi
  
  #if defined(__NetBSD__) || defined(__DragonFly__) || defined(__GNU__) ||       \
 -    defined(__MVS__)
-+    defined(__MVS__) || defined(__vinix__)
++    defined(__MVS__) || defined(__willowos__)
  #define STATVFS_F_FLAG(vfs) (vfs).f_flag
  #else
  #define STATVFS_F_FLAG(vfs) (vfs).f_flags
@@ -463,7 +463,7 @@ diff -urN --no-dereference llvm-clean/llvm/lib/Support/Unix/Path.inc llvm-workdi
      defined(__DragonFly__) || defined(_AIX) || defined(__GNU__) ||              \
 -    (defined(__sun__) && defined(__svr4__) || defined(__HAIKU__))
 +    (defined(__sun__) && defined(__svr4__) || defined(__HAIKU__)) ||            \
-+    defined(__vinix__)
++    defined(__willowos__)
  static int test_dir(char ret[PATH_MAX], const char *dir, const char *bin) {
    struct stat sb;
    char fullpath[PATH_MAX];
@@ -473,7 +473,7 @@ diff -urN --no-dereference llvm-clean/llvm/lib/Support/Unix/Path.inc llvm-workdi
      return exe_path;
 -#elif defined(__linux__) || defined(__CYGWIN__) || defined(__gnu_hurd__)
 +#elif defined(__linux__) || defined(__CYGWIN__) || defined(__gnu_hurd__) ||    \
-+    defined(__vinix__)
++    defined(__willowos__)
    char exe_path[PATH_MAX];
    const char *aPath = "/proc/self/exe";
    if (sys::fs::exists(aPath)) {
@@ -482,7 +482,7 @@ diff -urN --no-dereference llvm-clean/llvm/lib/Support/Unix/Path.inc llvm-workdi
    // vmount entry not found; "remote" is the conservative answer.
    return false;
 -#elif defined(__MVS__)
-+#elif defined(__MVS__) || defined(__vinix__)
++#elif defined(__MVS__) || defined(__willowos__)
    // The file system can have an arbitrary structure on z/OS; must go with the
    // conservative answer.
    return false;
@@ -493,8 +493,8 @@ diff -urN --no-dereference llvm-clean/llvm/lib/TargetParser/Triple.cpp llvm-work
    case Linux: return "linux";
    case Lv2: return "lv2";
    case MacOSX: return "macosx";
-+  case Vinix:
-+    return "vinix";
++  case willowos:
++    return "willowos";
    case Mesa3D: return "mesa3d";
    case NVCL: return "nvcl";
    case NaCl: return "nacl";
@@ -511,7 +511,7 @@ diff -urN --no-dereference llvm-clean/llvm/lib/TargetParser/Triple.cpp llvm-work
      .StartsWith("linux", Triple::Linux)
      .StartsWith("lv2", Triple::Lv2)
      .StartsWith("macos", Triple::MacOSX)
-+    .StartsWith("vinix", Triple::Vinix)
++    .StartsWith("willowos", Triple::willowos)
      .StartsWith("netbsd", Triple::NetBSD)
      .StartsWith("openbsd", Triple::OpenBSD)
      .StartsWith("solaris", Triple::Solaris)
diff --git a/patches/mesa-demos/jinx-working-patch.patch b/patches/mesa-demos/jinx-working-patch.patch
index 4394338..0d30601 100644
--- a/patches/mesa-demos/jinx-working-patch.patch
+++ b/patches/mesa-demos/jinx-working-patch.patch
@@ -6,7 +6,7 @@ diff -urN --no-dereference mesa-demos-clean/meson.build mesa-demos-workdir/meson
  
  dep_glx = dependency('glx', required: false, disabler : true)
 -if not dep_glx.found() and host_machine.system() == 'darwin'
-+if not dep_glx.found() and (host_machine.system() == 'darwin' or host_machine.system() == 'vinix')
++if not dep_glx.found() and (host_machine.system() == 'darwin' or host_machine.system() == 'willowos')
    # xquartz doesn't have a glx.pc, but it does have the header. And all the
    # symbols reside in libGL, so let's just use that.
    if cc.check_header('GL/glx.h', dependencies: dep_x11)
diff --git a/patches/mesa/jinx-working-patch.patch b/patches/mesa/jinx-working-patch.patch
index d559832..69ff6f1 100644
--- a/patches/mesa/jinx-working-patch.patch
+++ b/patches/mesa/jinx-working-patch.patch
@@ -18,7 +18,7 @@ diff -urN --no-dereference mesa-clean/meson.build mesa-workdir/meson.build
  
  # TODO: this is very incomplete
 -if ['linux', 'cygwin', 'gnu', 'freebsd', 'gnu/kfreebsd', 'haiku', 'android', 'managarm'].contains(host_machine.system())
-+if ['linux', 'cygwin', 'gnu', 'freebsd', 'gnu/kfreebsd', 'haiku', 'android', 'managarm', 'vinix'].contains(host_machine.system())
++if ['linux', 'cygwin', 'gnu', 'freebsd', 'gnu/kfreebsd', 'haiku', 'android', 'managarm', 'willowos'].contains(host_machine.system())
    pre_args += '-D_GNU_SOURCE'
  elif host_machine.system() == 'sunos'
    pre_args += '-D__EXTENSIONS__'
@@ -63,8 +63,8 @@ diff -urN --no-dereference mesa-clean/src/util/detect_os.h mesa-workdir/src/util
  #define DETECT_OS_ANDROID 1
  #endif
  
-+#if defined(__vinix__)
-+#define DETECT_OS_VINIX 1
++#if defined(__willowos__)
++#define DETECT_OS_willowos 1
 +#define DETECT_OS_UNIX 1
 +#define DETECT_OS_POSIX 1
 +#endif
@@ -76,8 +76,8 @@ diff -urN --no-dereference mesa-clean/src/util/detect_os.h mesa-workdir/src/util
  #define DETECT_OS_MANAGARM 0
  #endif
  
-+#ifndef DETECT_OS_VINIX
-+#define DETECT_OS_VINIX 0
++#ifndef DETECT_OS_willowos
++#define DETECT_OS_willowos 0
 +#endif
 +
  #endif /* DETECT_OS_H */
@@ -89,7 +89,7 @@ diff -urN --no-dereference mesa-clean/src/util/os_misc.c mesa-workdir/src/util/o
  #  include <log/log.h>
  #  include <cutils/properties.h>
 -#elif DETECT_OS_LINUX || DETECT_OS_CYGWIN || DETECT_OS_SOLARIS || DETECT_OS_HURD || DETECT_OS_MANAGARM
-+#elif DETECT_OS_LINUX || DETECT_OS_CYGWIN || DETECT_OS_SOLARIS || DETECT_OS_HURD || DETECT_OS_MANAGARM || DETECT_OS_VINIX
++#elif DETECT_OS_LINUX || DETECT_OS_CYGWIN || DETECT_OS_SOLARIS || DETECT_OS_HURD || DETECT_OS_MANAGARM || DETECT_OS_willowos
  #  include <unistd.h>
  #elif DETECT_OS_OPENBSD || DETECT_OS_FREEBSD
  #  include <sys/resource.h>
@@ -98,7 +98,7 @@ diff -urN --no-dereference mesa-clean/src/util/os_misc.c mesa-workdir/src/util/o
  os_get_total_physical_memory(uint64_t *size)
  {
 -#if DETECT_OS_LINUX || DETECT_OS_CYGWIN || DETECT_OS_SOLARIS || DETECT_OS_HURD || DETECT_OS_MANAGARM
-+#if DETECT_OS_LINUX || DETECT_OS_CYGWIN || DETECT_OS_SOLARIS || DETECT_OS_HURD || DETECT_OS_MANAGARM || DETECT_OS_VINIX
++#if DETECT_OS_LINUX || DETECT_OS_CYGWIN || DETECT_OS_SOLARIS || DETECT_OS_HURD || DETECT_OS_MANAGARM || DETECT_OS_willowos
     const long phys_pages = sysconf(_SC_PHYS_PAGES);
     const long page_size = sysconf(_SC_PAGE_SIZE);
  
@@ -110,7 +110,7 @@ diff -urN --no-dereference mesa-clean/src/util/os_time.c mesa-workdir/src/util/o
  os_time_sleep(int64_t usecs)
  {
 -#if DETECT_OS_LINUX || DETECT_OS_MANAGARM || DETECT_OS_FUCHSIA
-+#if DETECT_OS_LINUX || DETECT_OS_MANAGARM || DETECT_OS_VINIX || DETECT_OS_FUCHSIA
++#if DETECT_OS_LINUX || DETECT_OS_MANAGARM || DETECT_OS_willowos || DETECT_OS_FUCHSIA
     struct timespec time;
     time.tv_sec = usecs / 1000000;
     time.tv_nsec = (usecs % 1000000) * 1000;
@@ -133,7 +133,7 @@ diff -urN --no-dereference mesa-clean/src/util/u_thread.c mesa-workdir/src/util/
  {
  #if defined(HAVE_PTHREAD)
 -#if DETECT_OS_LINUX || DETECT_OS_CYGWIN || DETECT_OS_SOLARIS || defined(__GLIBC__) || DETECT_OS_MANAGARM || DETECT_OS_FUCHSIA
-+#if DETECT_OS_LINUX || DETECT_OS_CYGWIN || DETECT_OS_SOLARIS || defined(__GLIBC__) || DETECT_OS_MANAGARM || DETECT_OS_VINIX || DETECT_OS_FUCHSIA
++#if DETECT_OS_LINUX || DETECT_OS_CYGWIN || DETECT_OS_SOLARIS || defined(__GLIBC__) || DETECT_OS_MANAGARM || DETECT_OS_willowos || DETECT_OS_FUCHSIA
     int ret = pthread_setname_np(pthread_self(), name);
     if (ret == ERANGE) {
        char buf[16];
@@ -142,7 +142,7 @@ diff -urN --no-dereference mesa-clean/src/util/u_thread.c mesa-workdir/src/util/
  util_thread_get_time_nano(thrd_t thread)
  {
 -#if defined(HAVE_PTHREAD) && !defined(__APPLE__) && !defined(__HAIKU__) && !defined(__managarm__)
-+#if defined(HAVE_PTHREAD) && !defined(__APPLE__) && !defined(__HAIKU__) && !defined(__managarm__) && !defined(__vinix__)
++#if defined(HAVE_PTHREAD) && !defined(__APPLE__) && !defined(__HAIKU__) && !defined(__managarm__) && !defined(__willowos__)
     struct timespec ts;
     clockid_t cid;
  
diff --git a/patches/ncurses/jinx-working-patch.patch b/patches/ncurses/jinx-working-patch.patch
index ee062d5..d8afb90 100644
--- a/patches/ncurses/jinx-working-patch.patch
+++ b/patches/ncurses/jinx-working-patch.patch
@@ -78,7 +78,7 @@ diff -urN --no-dereference ncurses-clean/configure ncurses-workdir/configure
  		LINK_PROGS="$SHELL ${rel_builddir}/mk_prog.sh"
  		LINK_TESTS="$SHELL ${rel_builddir}/mk_prog.sh"
  		;;
-+	(vinix*)
++	(willowos*)
 +		CC_SHARED_OPTS='-fPIC'
 +		MK_SHARED_LIB='${CC} -shared -o $@'
 +		;;
diff --git a/patches/openssl/jinx-working-patch.patch b/patches/openssl/jinx-working-patch.patch
index a0c3073..6ad21ff 100644
--- a/patches/openssl/jinx-working-patch.patch
+++ b/patches/openssl/jinx-working-patch.patch
@@ -5,8 +5,8 @@ diff -urN --no-dereference openssl-clean/Configurations/10-main.conf openssl-wor
          ranlib           => "true",
      },
  
-+#### Vinix
-+    "vinix-generic64" => {
++#### willowos
++    "willowos-generic64" => {
 +        inherit_from     => [ "BASE_unix" ],
 +        CFLAGS           => picker(default   => "-Wall",
 +                         debug       => "-O0 -g",
@@ -28,14 +28,14 @@ diff -urN --no-dereference openssl-clean/Configurations/10-main.conf openssl-wor
 +    # This breaks the usual configuration naming convention but it's more
 +    # convenient for us, since it matches the target triples
 +
-+    "x86_64-vinix-mlibc" => {
-+        inherit_from     => [ "vinix-generic64", asm("x86_64_asm") ],
++    "x86_64-willowos-mlibc" => {
++        inherit_from     => [ "willowos-generic64", asm("x86_64_asm") ],
 +        perlasm_scheme   => "elf",
 +
 +        # Configure doesn't want to play nice and passes "--cross-compile-suffix"
 +        # on to the GCC invocation
-+        CC               => "x86_64-vinix-mlibc-gcc",
-+        CXX              => "x86_64-vinix-mlibc-g++",
++        CC               => "x86_64-willowos-mlibc-gcc",
++        CXX              => "x86_64-willowos-mlibc-g++",
 +
 +    },
 +
@@ -109,7 +109,7 @@ diff -urN --no-dereference openssl-clean/test/rsa_complex.c openssl-workdir/test
  #if defined(__STDC_VERSION__)
  # if __STDC_VERSION__ >= 199901L
 -#  include <complex.h>
-+#  if !defined(__vinix__)
++#  if !defined(__willowos__)
 +#   include <complex.h>
 +#  endif
  # endif
diff --git a/patches/python/jinx-working-patch.patch b/patches/python/jinx-working-patch.patch
index cf3fe8a..921c67d 100644
--- a/patches/python/jinx-working-patch.patch
+++ b/patches/python/jinx-working-patch.patch
@@ -19,7 +19,7 @@ diff -urN --no-dereference python-clean/Objects/mimalloc/prim/unix/prim.c python
  #include <unistd.h>    // sysconf
  #include <fcntl.h>     // open, close, read, access
  
-+#if defined(__vinix__)
++#if defined(__willowos__)
 +  #define MADV_DONTNEED 1
 +#endif
 +
@@ -31,7 +31,7 @@ diff -urN --no-dereference python-clean/Objects/mimalloc/prim/unix/prim.c python
  #endif
  
 -#if !defined(__HAIKU__) && !defined(__APPLE__) && !defined(__CYGWIN__) && !defined(_AIX) && !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__sun) && !defined(__NetBSD__)
-+#if !defined(__vinix__) && !defined(__HAIKU__) && !defined(__APPLE__) && !defined(__CYGWIN__) && !defined(_AIX) && !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__sun) && !defined(__NetBSD__)
++#if !defined(__willowos__) && !defined(__HAIKU__) && !defined(__APPLE__) && !defined(__CYGWIN__) && !defined(_AIX) && !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__sun) && !defined(__NetBSD__)
    #define MI_HAS_SYSCALL_H
    #include <sys/syscall.h>
  #endif
@@ -39,7 +39,7 @@ diff -urN --no-dereference python-clean/Objects/mimalloc/prim/unix/prim.c python
  static int unix_madvise(void* addr, size_t size, int advice) {
    #if defined(__sun)
    return madvise((caddr_t)addr, size, advice);  // Solaris needs cast (issue #520)
-+  #elif defined(__vinix__)
++  #elif defined(__willowos__)
 +  (void)addr; (void)size; (void)advice;
 +  return 0;
    #else
diff --git a/patches/readline/jinx-working-patch.patch b/patches/readline/jinx-working-patch.patch
index c8f6ba7..27ade56 100644
--- a/patches/readline/jinx-working-patch.patch
+++ b/patches/readline/jinx-working-patch.patch
@@ -6,7 +6,7 @@ diff -urN --no-dereference readline-clean/support/shlib-install readline-workdir
  # link library (in $libdir)
  case "$host_os" in
 -hpux*|darwin*|macosx*|linux*|solaris2*)
-+hpux*|darwin*|macosx*|linux*|solaris2*|vinix*)
++hpux*|darwin*|macosx*|linux*|solaris2*|willowos*)
  	if [ -z "$uninstall" ]; then
  		chmod 755 ${INSTALLDIR}/${LIBNAME}
  	fi ;;
@@ -15,7 +15,7 @@ diff -urN --no-dereference readline-clean/support/shlib-install readline-workdir
  #
  case "$host_os-$host_vendor" in
 -*linux*|freebsd*|dragonfly*)
-+*linux*|freebsd*|dragonfly*|vinix*)
++*linux*|freebsd*|dragonfly*|willowos*)
  	# libname.so.M -> libname.so.M.N
  	${echo} ${RM} ${INSTALLDIR}/$LINK2
  	if [ -z "$uninstall" ]; then
diff --git a/patches/xbps/jinx-working-patch.patch b/patches/xbps/jinx-working-patch.patch
index f17048d..9f28373 100644
--- a/patches/xbps/jinx-working-patch.patch
+++ b/patches/xbps/jinx-working-patch.patch
@@ -168,7 +168,7 @@ diff -urN --no-dereference xbps-clean/lib/fetch/ftp.c xbps-workdir/lib/fetch/ftp
  	sin4->sin_family = AF_INET;
  	*len = sizeof(struct sockaddr_in);
 -#ifndef __linux__
-+#if !defined(__linux__) && !defined(__vinix__)
++#if !defined(__linux__) && !defined(__willowos__)
  	sin4->sin_len = sizeof(struct sockaddr_in);
  #endif
  }
diff --git a/patches/xf86-input-keyboard/jinx-working-patch.patch b/patches/xf86-input-keyboard/jinx-working-patch.patch
index 6b0343f..6769cb3 100644
--- a/patches/xf86-input-keyboard/jinx-working-patch.patch
+++ b/patches/xf86-input-keyboard/jinx-working-patch.patch
@@ -5,8 +5,8 @@ diff -urN --no-dereference xf86-input-keyboard-clean/configure xf86-input-keyboa
  SOLARIS_TRUE
  BSD_FALSE
  BSD_TRUE
-+VINIX_FALSE
-+VINIX_TRUE
++willowos_FALSE
++willowos_TRUE
  OS_FLAGS
  inputdir
  XORG_LIBS
@@ -14,8 +14,8 @@ diff -urN --no-dereference xf86-input-keyboard-clean/configure xf86-input-keyboa
  
  # The keyboard driver code is O/S specific
  case $host_os in
-+  vinix*)
-+    IS_VINIX="yes"
++  willowos*)
++    IS_willowos="yes"
 +    ;;
 +
    linux*)
@@ -25,12 +25,12 @@ diff -urN --no-dereference xf86-input-keyboard-clean/configure xf86-input-keyboa
  esac
  
  
-+ if test "x$IS_VINIX" = xyes; then
-+  VINIX_TRUE=
-+  VINIX_FALSE='#'
++ if test "x$IS_willowos" = xyes; then
++  willowos_TRUE=
++  willowos_FALSE='#'
 +else
-+  VINIX_TRUE='#'
-+  VINIX_FALSE=
++  willowos_TRUE='#'
++  willowos_FALSE=
 +fi
 +
   if test "x$IS_BSD" = xyes; then
@@ -40,8 +40,8 @@ diff -urN --no-dereference xf86-input-keyboard-clean/configure xf86-input-keyboa
    as_fn_error $? "conditional \"am__fastdepCC\" was never defined.
  Usually this means the macro was only invoked conditionally." "$LINENO" 5
  fi
-+if test -z "${VINIX_TRUE}" && test -z "${VINIX_FALSE}"; then
-+  as_fn_error $? "conditional \"VINIX\" was never defined.
++if test -z "${willowos_TRUE}" && test -z "${willowos_FALSE}"; then
++  as_fn_error $? "conditional \"willowos\" was never defined.
 +Usually this means the macro was only invoked conditionally." "$LINENO" 5
 +fi
  if test -z "${BSD_TRUE}" && test -z "${BSD_FALSE}"; then
@@ -54,7 +54,7 @@ diff -urN --no-dereference xf86-input-keyboard-clean/src/Makefile.in xf86-input-
  @BSD_TRUE@am__append_1 = $(BSD_SRCS)
  @SOLARIS_TRUE@am__append_2 = $(SOLARIS_SRCS)
  @HURD_TRUE@am__append_3 = $(HURD_SRCS)
-+@VINIX_TRUE@am__append_4 = $(VINIX_SRCS)
++@willowos_TRUE@am__append_4 = $(willowos_SRCS)
  subdir = src
  ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
  am__aclocal_m4_deps = $(top_srcdir)/configure.ac
@@ -63,15 +63,15 @@ diff -urN --no-dereference xf86-input-keyboard-clean/src/Makefile.in xf86-input-
  am__kbd_drv_la_SOURCES_DIST = kbd.c xf86OSKbd.h xf86Keymap.h \
  	atKeynames.h bsd_KbdMap.c bsd_kbd.c bsd_kbd.h at_scancode.c \
 -	sun_kbd.c sun_kbd.h sun_kbdMap.c hurd_kbd.c
-+	sun_kbd.c sun_kbd.h sun_kbdMap.c hurd_kbd.c vinix_kbd.c
++	sun_kbd.c sun_kbd.h sun_kbdMap.c hurd_kbd.c willowos_kbd.c
  am__objects_1 = bsd_KbdMap.lo bsd_kbd.lo at_scancode.lo
  @BSD_TRUE@am__objects_2 = $(am__objects_1)
  am__objects_3 = sun_kbd.lo sun_kbdMap.lo
  @SOLARIS_TRUE@am__objects_4 = $(am__objects_3)
  am__objects_5 = hurd_kbd.lo at_scancode.lo
  @HURD_TRUE@am__objects_6 = $(am__objects_5)
-+am__objects_7 = vinix_kbd.lo at_scancode.lo
-+@VINIX_TRUE@am__objects_8 = $(am__objects_7)
++am__objects_7 = willowos_kbd.lo at_scancode.lo
++@willowos_TRUE@am__objects_8 = $(am__objects_7)
  am_kbd_drv_la_OBJECTS = kbd.lo $(am__objects_2) $(am__objects_4) \
 -	$(am__objects_6)
 +	$(am__objects_6) $(am__objects_8)
@@ -83,7 +83,7 @@ diff -urN --no-dereference xf86-input-keyboard-clean/src/Makefile.in xf86-input-
  am__depfiles_remade = ./$(DEPDIR)/at_scancode.Plo \
  	./$(DEPDIR)/bsd_KbdMap.Plo ./$(DEPDIR)/bsd_kbd.Plo \
 -	./$(DEPDIR)/hurd_kbd.Plo ./$(DEPDIR)/kbd.Plo \
-+	./$(DEPDIR)/hurd_kbd.Plo ./$(DEPDIR)/vinix_kbd.Plo ./$(DEPDIR)/kbd.Plo \
++	./$(DEPDIR)/hurd_kbd.Plo ./$(DEPDIR)/willowos_kbd.Plo ./$(DEPDIR)/kbd.Plo \
  	./$(DEPDIR)/sun_kbd.Plo ./$(DEPDIR)/sun_kbdMap.Plo
  am__mv = mv -f
  COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
@@ -95,12 +95,12 @@ diff -urN --no-dereference xf86-input-keyboard-clean/src/Makefile.in xf86-input-
 +	$(am__append_1) $(am__append_2) $(am__append_3) $(am__append_4)
  kbd_drv_la_LIBADD = $(XORG_LIBS)
  kbd_drv_ladir = @inputdir@
-+VINIX_SRCS = vinix_kbd.c at_scancode.c
++willowos_SRCS = willowos_kbd.c at_scancode.c
  BSD_SRCS = bsd_KbdMap.c bsd_kbd.c bsd_kbd.h at_scancode.c
  HURD_SRCS = hurd_kbd.c at_scancode.c
  SOLARIS_SRCS = sun_kbd.c sun_kbd.h sun_kbdMap.c
 -EXTRA_DIST = $(BSD_SRCS) $(HURD_SRCS) $(SOLARIS_SRCS)
-+EXTRA_DIST = $(VINIX_SRCS) $(BSD_SRCS) $(HURD_SRCS) $(SOLARIS_SRCS)
++EXTRA_DIST = $(willowos_SRCS) $(BSD_SRCS) $(HURD_SRCS) $(SOLARIS_SRCS)
  all: all-am
  
  .SUFFIXES:
@@ -108,7 +108,7 @@ diff -urN --no-dereference xf86-input-keyboard-clean/src/Makefile.in xf86-input-
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bsd_KbdMap.Plo@am__quote@ # am--include-marker
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bsd_kbd.Plo@am__quote@ # am--include-marker
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hurd_kbd.Plo@am__quote@ # am--include-marker
-+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vinix_kbd.Plo@am__quote@ # am--include-marker
++@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/willowos_kbd.Plo@am__quote@ # am--include-marker
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/kbd.Plo@am__quote@ # am--include-marker
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sun_kbd.Plo@am__quote@ # am--include-marker
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sun_kbdMap.Plo@am__quote@ # am--include-marker
@@ -116,7 +116,7 @@ diff -urN --no-dereference xf86-input-keyboard-clean/src/Makefile.in xf86-input-
  	-rm -f ./$(DEPDIR)/bsd_KbdMap.Plo
  	-rm -f ./$(DEPDIR)/bsd_kbd.Plo
  	-rm -f ./$(DEPDIR)/hurd_kbd.Plo
-+	-rm -f ./$(DEPDIR)/vinix_kbd.Plo
++	-rm -f ./$(DEPDIR)/willowos_kbd.Plo
  	-rm -f ./$(DEPDIR)/kbd.Plo
  	-rm -f ./$(DEPDIR)/sun_kbd.Plo
  	-rm -f ./$(DEPDIR)/sun_kbdMap.Plo
@@ -124,13 +124,13 @@ diff -urN --no-dereference xf86-input-keyboard-clean/src/Makefile.in xf86-input-
  	-rm -f ./$(DEPDIR)/bsd_KbdMap.Plo
  	-rm -f ./$(DEPDIR)/bsd_kbd.Plo
  	-rm -f ./$(DEPDIR)/hurd_kbd.Plo
-+	-rm -f ./$(DEPDIR)/vinix_kbd.Plo
++	-rm -f ./$(DEPDIR)/willowos_kbd.Plo
  	-rm -f ./$(DEPDIR)/kbd.Plo
  	-rm -f ./$(DEPDIR)/sun_kbd.Plo
  	-rm -f ./$(DEPDIR)/sun_kbdMap.Plo
-diff -urN --no-dereference xf86-input-keyboard-clean/src/vinix_kbd.c xf86-input-keyboard-workdir/src/vinix_kbd.c
---- xf86-input-keyboard-clean/src/vinix_kbd.c	1970-01-01 01:00:00.000000000 +0100
-+++ xf86-input-keyboard-workdir/src/vinix_kbd.c
+diff -urN --no-dereference xf86-input-keyboard-clean/src/willowos_kbd.c xf86-input-keyboard-workdir/src/willowos_kbd.c
+--- xf86-input-keyboard-clean/src/willowos_kbd.c	1970-01-01 01:00:00.000000000 +0100
++++ xf86-input-keyboard-workdir/src/willowos_kbd.c
 @@ -0,0 +1,31 @@
 +
 +#ifdef HAVE_CONFIG_H
diff --git a/patches/xf86-input-mouse/jinx-working-patch.patch b/patches/xf86-input-mouse/jinx-working-patch.patch
index cd82613..7f31603 100644
--- a/patches/xf86-input-mouse/jinx-working-patch.patch
+++ b/patches/xf86-input-mouse/jinx-working-patch.patch
@@ -14,15 +14,15 @@ diff -urN --no-dereference xf86-input-mouse-clean/configure xf86-input-mouse-wor
    gnu*)
      OS_MOUSE_NAME=hurd
      ;;
-+  vinix*)
-+    OS_MOUSE_NAME=vinix
++  willowos*)
++    OS_MOUSE_NAME=willowos
 +    ;;
  esac
  
  
-diff -urN --no-dereference xf86-input-mouse-clean/src/vinix_mouse.c xf86-input-mouse-workdir/src/vinix_mouse.c
---- xf86-input-mouse-clean/src/vinix_mouse.c	1970-01-01 01:00:00.000000000 +0100
-+++ xf86-input-mouse-workdir/src/vinix_mouse.c
+diff -urN --no-dereference xf86-input-mouse-clean/src/willowos_mouse.c xf86-input-mouse-workdir/src/willowos_mouse.c
+--- xf86-input-mouse-clean/src/willowos_mouse.c	1970-01-01 01:00:00.000000000 +0100
++++ xf86-input-mouse-workdir/src/willowos_mouse.c
 @@ -0,0 +1,119 @@
 +#ifdef HAVE_XORG_CONFIG_H
 +#include <xorg-config.h>
@@ -58,7 +58,7 @@ diff -urN --no-dereference xf86-input-mouse-clean/src/vinix_mouse.c xf86-input-m
 +    int32_t y_mov;
 +};
 +
-+static void vinixReadInput(InputInfoPtr pInfo) {
++static void willowosReadInput(InputInfoPtr pInfo) {
 +    MouseDevPtr mouse = pInfo->private;
 +    struct mouse_packet packet;
 +
@@ -74,7 +74,7 @@ diff -urN --no-dereference xf86-input-mouse-clean/src/vinix_mouse.c xf86-input-m
 +    }
 +}
 +
-+static Bool vinixPreInit(InputInfoPtr pInfo, const char *proto, int flag) {
++static Bool willowosPreInit(InputInfoPtr pInfo, const char *proto, int flag) {
 +    MouseDevPtr mouse;
 +
 +    mouse = pInfo->private;
@@ -90,7 +90,7 @@ diff -urN --no-dereference xf86-input-mouse-clean/src/vinix_mouse.c xf86-input-m
 +    }
 +
 +    mouse->CommonOptions(pInfo);
-+    pInfo->read_input = vinixReadInput;
++    pInfo->read_input = willowosReadInput;
 +    return true;
 +}
 +
@@ -112,7 +112,7 @@ diff -urN --no-dereference xf86-input-mouse-clean/src/vinix_mouse.c xf86-input-m
 +}
 +
 +static const char *names[] = {
-+    "VinixMouseDev", NULL
++    "willowosMouseDev", NULL
 +};
 +
 +static const char **protonames() {
@@ -120,7 +120,7 @@ diff -urN --no-dereference xf86-input-mouse-clean/src/vinix_mouse.c xf86-input-m
 +}
 +
 +static const char *defaultproto() {
-+    return "VinixMouseDev";
++    return "willowosMouseDev";
 +}
 +
 +static Bool isdefault(const char *protocol) {
@@ -140,6 +140,6 @@ diff -urN --no-dereference xf86-input-mouse-clean/src/vinix_mouse.c xf86-input-m
 +    p->FindDevice = getdevice;
 +    p->DefaultProtocol = defaultproto;
 +    p->CheckProtocol = isdefault;
-+    p->PreInit = vinixPreInit;
++    p->PreInit = willowosPreInit;
 +    return p;
 +}
diff --git a/patches/xorg-proto/jinx-working-patch.patch b/patches/xorg-proto/jinx-working-patch.patch
index 2d5d622..dbccd5b 100644
--- a/patches/xorg-proto/jinx-working-patch.patch
+++ b/patches/xorg-proto/jinx-working-patch.patch
@@ -6,7 +6,7 @@ diff -urN --no-dereference xorg-proto-clean/include/X11/Xfuncs.h xorg-proto-work
  #   else
  #    include <string.h>
 -#    if defined(__SCO__) || defined(__sun) || defined(__UNIXWARE__) || defined(__CYGWIN__) || defined(_AIX) || defined(__APPLE__)
-+#    if defined(__SCO__) || defined(__sun) || defined(__UNIXWARE__) || defined(__CYGWIN__) || defined(_AIX) || defined(__APPLE__) || defined(__vinix__)
++#    if defined(__SCO__) || defined(__sun) || defined(__UNIXWARE__) || defined(__CYGWIN__) || defined(_AIX) || defined(__APPLE__) || defined(__willowos__)
  #     include <strings.h>
  #    endif
  #    define _XFUNCS_H_INCLUDED_STRING_H
@@ -18,7 +18,7 @@ diff -urN --no-dereference xorg-proto-clean/include/X11/Xos.h xorg-proto-workdir
  
  # include <string.h>
 -# if defined(__SCO__) || defined(__UNIXWARE__) || defined(__sun) || defined(__CYGWIN__) || defined(_AIX) || defined(__APPLE__) || defined(__FreeBSD__)
-+# if defined(__SCO__) || defined(__UNIXWARE__) || defined(__sun) || defined(__CYGWIN__) || defined(_AIX) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__vinix__)
++# if defined(__SCO__) || defined(__UNIXWARE__) || defined(__sun) || defined(__CYGWIN__) || defined(_AIX) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__willowos__)
  #  include <strings.h>
  # else
  #  ifndef index
@@ -30,7 +30,7 @@ diff -urN --no-dereference xorg-proto-clean/include/X11/Xos_r.h xorg-proto-workd
    (p).pwp )
  
 -#elif !defined(_POSIX_THREAD_SAFE_FUNCTIONS) && !defined(__APPLE__)
-+#elif !defined(_POSIX_THREAD_SAFE_FUNCTIONS) && !defined(__APPLE__) && !defined(__vinix__)
++#elif !defined(_POSIX_THREAD_SAFE_FUNCTIONS) && !defined(__APPLE__) && !defined(__willowos__)
  # define X_NEEDS_PWPARAMS
  typedef struct {
    struct passwd pws;
diff --git a/patches/xorg-server/jinx-working-patch.patch b/patches/xorg-server/jinx-working-patch.patch
index 48afe01..e61b9d6 100644
--- a/patches/xorg-server/jinx-working-patch.patch
+++ b/patches/xorg-server/jinx-working-patch.patch
@@ -294,7 +294,7 @@ diff -urN --no-dereference xorg-server-clean/os/access.c xorg-server-workdir/os/
  #endif
  
 -#if defined(SVR4) ||  (defined(SYSV) && defined(__i386__)) || defined(__GNU__)
-+#if defined(SVR4) ||  (defined(SYSV) && defined(__i386__)) || defined(__GNU__) || defined(__vinix__)
++#if defined(SVR4) ||  (defined(SYSV) && defined(__i386__)) || defined(__GNU__) || defined(__willowos__)
  #include <sys/utsname.h>
  #endif
  #if defined(SYSV) &&  defined(__i386__)
diff --git a/patches/zlib/jinx-working-patch.patch b/patches/zlib/jinx-working-patch.patch
index 0289c33..77002cc 100644
--- a/patches/zlib/jinx-working-patch.patch
+++ b/patches/zlib/jinx-working-patch.patch
@@ -6,7 +6,7 @@ diff -urN --no-dereference zlib-clean/configure zlib-workdir/configure
    fi
    case "$uname" in
 -  Linux* | linux* | *-linux* | GNU | GNU/* | solaris*)
-+  Linux* | linux* | *-linux* | GNU | GNU/* | solaris* | vinix*)
++  Linux* | linux* | *-linux* | GNU | GNU/* | solaris* | willowos*)
          case "$mname" in
          *sparc*)
              LDFLAGS="${LDFLAGS} -Wl,--no-warn-rwx-segments" ;;
diff --git a/recipes/base b/recipes/base
index 5b0f2b2..fe0b865 100644
--- a/recipes/base
+++ b/recipes/base
@@ -4,4 +4,4 @@ name=base
 skip_pkg_check=yes
 version=0.0
 revision=1
-deps="base-files kernel init bash binutils bzip2 coreutils diffutils findutils gawk gcc gmp grep gzip less make mpc mpfr nano ncurses pcre2 readline sed tar tzdata util-vinix xbps xz zlib zstd"
+deps="base-files kernel init bash binutils bzip2 coreutils diffutils findutils gawk gcc gmp grep gzip less make mpc mpfr nano ncurses pcre2 readline sed tar tzdata util-willowos xbps xz zlib zstd"
diff --git a/recipes/init b/recipes/init
index 0d8bb9f..7d248c9 100644
--- a/recipes/init
+++ b/recipes/init
@@ -17,7 +17,7 @@ build() {
     if [ "$PROD" = "true" ]; then
         PROD_FLAG="-prod"
     fi
-    VCROSS_COMPILER_NAME=${OS_TRIPLET}-gcc v -os vinix -gc none $PROD_FLAG -cflags "$TARGET_CFLAGS" -ldflags "$TARGET_LDFLAGS" .
+    VCROSS_COMPILER_NAME=${OS_TRIPLET}-gcc v -os willowos -gc none $PROD_FLAG -cflags "$TARGET_CFLAGS" -ldflags "$TARGET_LDFLAGS" .
 
     set +x
 }
diff --git a/recipes/libgpg-error b/recipes/libgpg-error
index 0e84342..97bd5cd 100644
--- a/recipes/libgpg-error
+++ b/recipes/libgpg-error
@@ -10,7 +10,7 @@ hostdeps="gcc pkg-config"
 deps="core-libs"
 
 prepare() {
-    cp -v src/syscfg/lock-obj-pub.$ARCHITECTURE-unknown-linux-gnu.h src/syscfg/lock-obj-pub.vinix-mlibc.h
+    cp -v src/syscfg/lock-obj-pub.$ARCHITECTURE-unknown-linux-gnu.h src/syscfg/lock-obj-pub.willowos-mlibc.h
 
     autotools_recursive_regen
 }
diff --git a/recipes/tinyvvm b/recipes/tinyvvm
index 86ac93e..56213b0 100644
--- a/recipes/tinyvvm
+++ b/recipes/tinyvvm
@@ -16,7 +16,7 @@ build() {
 
         VCROSS_COMPILER_NAME=${OS_TRIPLET}-gcc \
     v \
-        -os vinix \
+        -os willowos \
         -gc none \
         -prod \
         -autofree \
diff --git a/recipes/util-vinix b/recipes/util-vinix
index 251c029..6f1f4b9 100644
--- a/recipes/util-vinix
+++ b/recipes/util-vinix
@@ -1,10 +1,10 @@
 #! /bin/sh
 
-name=util-vinix
+name=util-willowos
 skip_pkg_check=yes
 version=0.0git
 revision=1
-source_dir="util-vinix"
+source_dir="util-willowos"
 hostdeps="gcc v"
 deps="core-libs"
 
@@ -14,7 +14,7 @@ build() {
     make -j1 \
         PROD="$PROD" \
         CC=${OS_TRIPLET}-gcc \
-        VFLAGS="-os vinix -gc none" \
+        VFLAGS="-os willowos -gc none" \
         CFLAGS="$TARGET_CFLAGS" \
         LDFLAGS="$TARGET_LDFLAGS"
 }
diff --git a/util-vinix/chsh/main.v b/util-vinix/chsh/main.v
index fd0a5f8..f068b01 100644
--- a/util-vinix/chsh/main.v
+++ b/util-vinix/chsh/main.v
@@ -34,7 +34,7 @@ fn main() {
 				exit(0)
 			}
 			'--version' {
-				println('chsh from util-vinix')
+				println('chsh from util-willowos')
 				exit(0)
 			}
 			'-s', '--shell' {
diff --git a/util-vinix/chsh/v.mod b/util-vinix/chsh/v.mod
index dae2d77..b4b5f18 100644
--- a/util-vinix/chsh/v.mod
+++ b/util-vinix/chsh/v.mod
@@ -1,6 +1,6 @@
 Module {
 	name: 'CHSH'
-	description: 'chsh utility for util-vinix'
+	description: 'chsh utility for util-willowos'
 	version: '0.0.0'
 	license: 'GPL-2.0'
 	dependencies: []
diff --git a/util-vinix/fetch/main.v b/util-vinix/fetch/main.v
index 4b660c9..bb1e647 100644
--- a/util-vinix/fetch/main.v
+++ b/util-vinix/fetch/main.v
@@ -26,7 +26,7 @@ fn main() {
 				exit(0)
 			}
 			'--version' {
-				println('fetch from util-vinix')
+				println('fetch from util-willowos')
 				exit(0)
 			}
 			else {
diff --git a/util-vinix/fetch/v.mod b/util-vinix/fetch/v.mod
index a500609..4e86913 100644
--- a/util-vinix/fetch/v.mod
+++ b/util-vinix/fetch/v.mod
@@ -1,6 +1,6 @@
 Module {
 	name: 'Fetch'
-	description: 'Fetch utility for util-vinix'
+	description: 'Fetch utility for util-willowos'
 	version: '0.0.0'
 	license: 'GPL-2.0'
 	dependencies: []
diff --git a/util-vinix/lscpu/main.v b/util-vinix/lscpu/main.v
index 86d97d3..c174722 100644
--- a/util-vinix/lscpu/main.v
+++ b/util-vinix/lscpu/main.v
@@ -18,7 +18,7 @@ fn main() {
 				exit(0)
 			}
 			'--version' {
-				println('lscpu from util-vinix')
+				println('lscpu from util-willowos')
 				exit(0)
 			}
 			else {
diff --git a/util-vinix/lscpu/v.mod b/util-vinix/lscpu/v.mod
index 68a014d..ae64e4b 100644
--- a/util-vinix/lscpu/v.mod
+++ b/util-vinix/lscpu/v.mod
@@ -1,6 +1,6 @@
 Module {
 	name: 'LSCPU'
-	description: 'lscpu equivalent for util-vinix'
+	description: 'lscpu equivalent for util-willowos'
 	version: '0.0.0'
 	license: 'GPL-2.0'
 	dependencies: []
diff --git a/util-vinix/mount/main.v b/util-vinix/mount/main.v
index c7db011..bae1b27 100644
--- a/util-vinix/mount/main.v
+++ b/util-vinix/mount/main.v
@@ -24,7 +24,7 @@ fn main() {
 				exit(0)
 			}
 			'--version' {
-				println('mount from util-vinix')
+				println('mount from util-willowos')
 				exit(0)
 			}
 			'-t' {
diff --git a/util-vinix/mount/v.mod b/util-vinix/mount/v.mod
index 261d756..2256723 100644
--- a/util-vinix/mount/v.mod
+++ b/util-vinix/mount/v.mod
@@ -1,6 +1,6 @@
 Module {
 	name: 'Mount'
-	description: 'mount equivalent for util-vinix'
+	description: 'mount equivalent for util-willowos'
 	version: '0.0.0'
 	license: 'GPL-2.0'
 	dependencies: []
